\begindata{text,537746824}
\textdsversion{12}
\template{default}
\define{datamember
menu:[Word~5,Data Member]
attr:[Flags Underline Int Set]}
\define{staticdatamember
menu:[Word,Static Data Member]
attr:[Flags Underline Int Set]}
\define{memberfunction
menu:[Word~5,Member Function]
attr:[Flags Underline Int Set]}
\define{virtualmemberfunction
menu:[Word~5,Virtual Member Function]
attr:[Flags Underline Int Set]}
\define{staticmemberfunction
menu:[Word~5,Static Member Function]
attr:[Flags Underline Int Set]}
\define{argument
menu:[Word~5,Argument]
attr:[FontFace Italic Int Set]}
\define{globalvariable
menu:[Word~5,Global Variable]
attr:[FontFace Italic Int Set]}
\define{filescopevariable
menu:[Word~5,File Scope Variable]
attr:[FontFace Italic Int Set]}
\define{localvariable
menu:[Word~5,Local Variable]
attr:[FontFace Italic Int Set]}
\define{class
menu:[Word~5,Class]
attr:[FontFace Bold Int Set]}
\define{type
menu:[Word~5,Type]
attr:[FontFace Italic Int Set]}
\define{constructor
menu:[Word~5,Constructor]
attr:[Flags Underline Int Set]}
\define{destructor
menu:[Word~5,Destructor]
attr:[Flags Underline Int Set]}
\define{comment
menu:[Region~4,Comment]
attr:[FontFace Italic Int Set]}
\define{constant
menu:[Word~5,Constant]
attr:[FontFace Bold Int Set]}
\define{filename
menu:[Word~5,File Name]
attr:[FontFamily AndyType Int 0]}
\define{filescopefunction
menu:[Word~5,File Scope Function]
attr:[FontFace Bold Int Set]
attr:[FontFace Italic Int Set]}
\define{classobject
menu:[Word~5,Class Object]
attr:[Flags Underline Int Set]
attr:[FontFace Italic Int Set]}
\define{keyword
}
\define{string
}
\define{preproc
}
\define{linecomment
}
\define{paramname
}
\majorheading{\bigger{\bigger{\bigger{\bigger{Overview of Programming in 
Andrew \


}}}}
\bigger{Andrew User Interface System}

V\bigger{ersion 8   (October 1996)

}}


\bold{\indent{\indent{\indent{\indent{Andrew Consortium

School of Computer Science

Carnegie Mellon University

5000 Forbes Avenue

Pittsburgh, PA 15213-3891

USA}}}}

}
\indent{Phone:			\bold{(412) 268-6710}

Fax:			\bold{(412) 268-5576}

Web:			\bold{http://www.cs.cmu.edu/~AUIS}

Demo:			\bold{finger @atk.cs.cmu.edu}

Archives:		\bold{ftp.andrew.cmu.edu:  /pub/AUIS}

Bugs:			\bold{\bold{info-andrew-bugs@andrew.cmu.edu

}}Info & Subscriptions:	\bold{info-andrew-request@andrew.cmu.edu}}



\indent{\indent{


In the documentation, the source directory will be referred to as 
\typewriter{$/} and the destination as \typewriter{$ANDREWDIR/}.

}}
\indent{\indent{If you are reading an all-ASCII version of this file, the 
version in Andrew format is in the distribution at:}}


\center{\typewriter{$ANDREWDIR}}\typewriter{\center{\typewriter{/}}doc/DEVEL\
OPER/AndrewProgramming.ez}\smaller{









\smaller{\bigger{Copyright 1996 Carnegie Mellon University.  All rights 
reserved. Please see further copyrights and disclaimer at the end of this 
file.}}}

\begindata{bp,538014248}
Version 2
n 0
\enddata{bp,538014248}
\view{bpv,538014248,0,0,0}

\bold{\bigger{\bigger{1.	Introduction}}}


The two most important Andrew objects are dataobject and view.  Dataobjects 
store persistent information and translate it for transfer to and from 
files, while a views displays a screen image of some dataobject and 
provides a userinterface for modifying it.



\bold{\bold{\bigger{\bigger{2.	dataobject}}}}\section{


2.1	SetAttributes}


\keyword{\type{void}} 
dataobject::\virtualmemberfunction{SetAttributes}(\type{\keyword{struct} 
attributes  *}\argument{attributes});

This method provides an interface for the \class{buffer} system to 
communicate various bits of information to a \classobject{dataobject} when 
it is being read into a \classobject{buffer}.  The first thing a 
\virtualmemberfunction{SetAttributes} implementation should do is call the 
\virtualmemberfunction{SetAttributes} method of the base class. 
 SetAttributes should then step through the attributes linked list, so the 
code would be something like:


	\example{void 
\class{thisobj}::\virtualmemberfunction{SetAttributes}(\type{struct 
attributes *}\argument{attributes}) \{

	\class{baseobj}::\virtualmemberfunction{SetAttributes}(\argument{attributes\
}); 	while(\argument{attributes}) \{

		if(strcmp(\argument{attributes}->key, "mykey-for-string")==0)

 		\{

			\filescopefunction{MyHacking}(\argument{attributes}->value.string);

		\}

		if(strcmp(\argument{attributes}->key, "mykey-for-integer)==0)

 		\{

			\filescopefunction{MyHacking}(\argument{attributes}->value.integer);

		\}

		\argument{attributes}=\argument{attributes}->next;

	\}

\}}\example{

}
The strings used in this example could be anything, likewise the MyHacking 
function call could be replaced with any processing required.  Currently 
one common attribute is defined:


\indent{\typewriter{key:readonly	type:integer	values:TRUE/FALSE}

If \constant{TRUE}, then the object is being read from a read-only file so 
it should not allow changes.  Otherwise changes should be allowed.}



\section{2.2	Read/Write}


\bold{2.2.1}	\keyword{\subsection{ATK Datastream Format}


The ATK Datastream Format (ADF) is designed to be a 7-bit printable ASCII 
representation for storing ATK dataobjects.  \



The basic format of ADF files is:


\\begindata\{\class{typename}, UniqueID\}

...data...

\\enddata(\class{typename}, UniqueID\}


The typename is the result of calling \virtualmemberfunction{GetTypeName}() 
on the dataobject.  The UniqueID is the result of calling 
\virtualmemberfunction{GetID}() on the dataobject.


Ideally the format used by the dataobjects should be able to survive email 
transport as well as simple file exchange.  A few simple rules will enable 
ADF files to survive most email transport:


1.  No trailing spaces on any line.

2.  No lines longer than 76 characters.

3.  No non-printable characters other than newline, tab and space.


These rules have been reasonably effective in protecting data from 
corruption during email transport, but it is known that they are not 
sufficient for all transports.  The safest way to encode your data is to 
use the MIME format as the native format.  Unfortunately the support for 
doing so currently leaves much to be desired.  In particular the 
\staticmemberfunction{ToQP} function from the \class{mailobj} class isn't 
available unless AMS (messages in particular) is installed, and the 
to64/from64 functions only operate between files.  Thus currently the 
safest way to write your data is to open a temporary file and output text 
or binary data, and then call to64(tempfile,outfile), and then unlink the 
tempfile.  Note that if you use a binary format you should take care to use 
a standard byte order on all platforms, and to never store data structures 
directly.  The layout of structures is NOT standard across platforms and 
there is no guarantee that it will even be possible to create structures on 
one platform that match the layout of those on another.  The drawbacks of 
using the base64 format supported by to64/from64 include the fact that 
plain text data will be expanded by 4/3, and in any case the resulting data 
is not human readable.  If these drawbacks cannot be tolerated just write 
your data in plain 7 bit ASCII, following the three rules described above.



\subsection{2.2.2	The Methods}


\type{long}} \class{dataobject}::\virtualmemberfunction{Write}(\type{FILE 
 *}\argument{file}, \keyword{\type{long}}  \argument{writeID}, 
\keyword{\type{int}}  \argument{level})

ATK objects should store their data in their ATK datastream format unless 
level is 0 in which case the object can choose to write itself in some 
other format.


Because ATK supports embedded \classobject{dataobjects} and  multiple 
\classobject{views} of the same data object, there is a mechanism to insure 
that a\classobject{ dataobject} does not write itself in the same file more 
than once.  This is accomplished by a \class{dataobject} datum called the 
\datamember{writeID}.  The caller of the \bold{\virtualmemberfunction{Write}} 
method on the top level object generates a \argument{WriteID  }(by calling 
\class{im}::\staticmemberfunction{GetWriteID}()), and passes that as the 
\argument{writeID} argument.  If the method encounters an embedded data 
object which needs to write itself, it passes the \argument{writeID} 
argument to the embedded object's \virtualmemberfunction{Write} method.

 \


\example{\keyword{\type{long}} 
\class{thisobj}::\virtualmemberfunction{Write}(\type{FILE 
 *}\argument{file}, \keyword{\type{long}}  \argument{writeID}, 
\keyword{\type{int}}  \argument{level}) \{

    \keyword{if} (\virtualmemberfunction{GetWriteID}() != 
\argument{writeID})  \{

        fprintf(\argument{file}, \string{"\\\\begindata\{%s,%ld\}\\n"}, 
\virtualmemberfunction{GetTypeName}(), \virtualmemberfunction{GetID}());

		// Optionally write any data from the base class.

		\class{baseobj}::\virtualmemberfunction{Write}(\argument{file}, 
\argument{writeID}, \argument{level});	\


		// so if we are refered to by children we don't

		// get stuck in a loop.

        \virtualmemberfunction{SetWriteID}(\argument{writeID});

		// And any objects this object uses.

		\type{long} 
\localvariable{mid}=\datamember{memberobj}->\virtualmemberfunction{Write}(\
\argument{file}, \argument{writeID}, 1);

		// ... write any additional member objects

		// or data here.

        fprintf(\argument{file}, \string{"\\\\enddata\{%s,%ld\}\\n", 
\virtualmemberfunction{GetTypeName}(), }\virtualmemberfunction{GetID}());

    \}


    \keyword{return} \virtualmemberfunction{GetID}();

\}}


If any of the base classes have data which you would like to write out then 
a call to the base class's \virtualmemberfunction{Write} Method should be 
included.  If \class{thisobj} uses any other \classobject{dataobjects} 
whose data should be saved their \virtualmemberfunction{Write} methods 
should be called.


Any given embedded object will only be written once per invocation of 
\virtualmemberfunction{Write} on the toplevel object.  Thus if the 
dataobject is using other \classobject{dataobjects} which it may share with 
still other \classobject{dataobjects} it cannot assume that the 
\virtualmemberfunction{Write} call it makes will actually generate any 
output.  If this situation may arise then instead of just calling the 
member's \virtualmemberfunction{Write} method the \class{dataobject} should 
call \virtualmemberfunction{Write} and then output the id returned from the 
call.  The read routine will then use that number to look up the referenced 
object.


Note that no provision is made to signal failure except via the error 
indication on the file pointer.


\keyword{\type{long}} 
\class{dataobject}::\virtualmemberfunction{Read}(\type{FILE 
 *}\argument{file}, \keyword{\type{long}}  \argument{id})

The \virtualmemberfunction{Read} method should fill in the 
\classobject{dataobject} with the data from file in the same format as 
written by the \virtualmemberfunction{Write} method.  If a special format 
is supported for top level objects, the first few bytes of the file should 
be examined to determine if that format is being used.  If the datastream 
format is being read the most important requirement is that under all 
circumstances the \virtualmemberfunction{Read} method must consume all the 
input upto and including the 
\\enddata\{\class{typename},\argument{id}\}\\n.  (Where typename is the 
name of the class, and id is from the \argument{id} argument.)  Several 
return value are defined for Read:


\preproc{#define	\constant{dataobject_NOREADERROR}	0}

\preproc{#define	\constant{dataobject_PREMATUREEOF}	1}

\preproc{#define	\constant{dataobject_NOTATKDATASTREAM} 2}

\preproc{#define	\constant{dataobject_MISSINGENDDATAMARKER} 3}

\preproc{#define	\constant{dataobject_OBJECTCREATIONFAILED}	4}

#define	\constant{dataobject_BADFORMAT} 5


\constant{dataobject_NOREADERROR} indicates a successful read operation.

\constant{dataobject_PREMATUREEOF} indicates the input file was incomplete.

\constant{dataobject_NOTATKDATASTREAM} indicates the data was not in a 
format the object understands.

\constant{dataobject_MISSINGENDDATAMARKER} indicates that the appropriate 
\\enddata\{typename,id\} was never found.

\constant{dataobject_OBJECTCREATIONFAILED} indicates that a subobject being 
read in could not be created.

\section{
2.3	ReadOtherFormat/WriteOtherFormat

}
\virtualmemberfunction{ReadOtherFormat} and 
\virtualmemberfunction{WriteOtherFormat} are intended to support additional 
formats for ATK \class{dataobjects} in addition to the native ATK 
datastream.  Currently the only other supported format is MIME, which is 
represented by the \constant{dataobject_OTHERFORMAT_MAIL} constant used as 
the \argument{usagetype} parameter to these two functions.  See also 
ToQP(atkams/messages/lib/mailobj.C), to64, fromqp, and from64 in 
overhead/util/lib/encode.c.  Implementing 
\virtualmemberfunction{WriteOtherFormat} or 
\virtualmemberfunction{ReadOtherFormat} isn't really useful yet unless 
atkams/messages/lib/text822.C is updated to use your \class{dataobject} 
when certain MIME types are received.\type{

long} 
\class{dataobject}::\virtualmemberfunction{WriteOtherFormat}(\type{FILE 
 *}\argument{file}, \keyword{\type{long}}  \argument{writeID}, 
\keyword{\type{int}}  \argument{level}, \keyword{\type{int}} 
 \argument{usagetype}, \type{\keyword{char}  *}\argument{boundary})

\argument{boundary} is only needed for the duration of 
\virtualmemberfunction{WriteOtherFormat}, it may be on the stack, or in 
memory freed after the call to WriteOtherFormat.


WriteOtherFormat should be implemented by derived classes if there is an 
equivalent MIME type which could represent the data.  Otherwise the default 
implementation which writes the inset as an application/andrew-inset should 
be sufficient.  If WriteOtherFormat is implemented, it should start its 
output with:


\example{fprintf(\argument{file}, \string{"\\n--%s\\nContent-type: 
\bold{<x-major>}/<\bold{x-minor}>\\nContent-Transfer-Encoding: %s\\n"}, 
\argument{boundary, }"\bold{<quoted-printable or base64 probably>}");}


Where x-major and x-minor form the appropriate MIME type.  In actual use 
you will probably also want to include a Content-Transfer-Encoding above as 
well.  The rest of the body should use the standard format if the 
content-type is a standard one, and should follow all the appropriate MIME 
rules in any case.  (See rfc's 1521 and 1522.)


\type{boolean} 
\class{dataobject}::\virtualmemberfunction{ReadOtherFormat}(\type{FILE 
 *}\argument{file}, \type{\keyword{char}  *}\argument{fmt} , 
\type{\keyword{char}  *}\argument{encoding}, \type{\keyword{char} 
 *}\argument{description})\argument{

fmt}, \argument{encoding} and \argument{description} are only needed for 
the duration of \virtualmemberfunction{ReadOtherFormat}, they may be on the 
stack, or in memory freed after the call to 
\virtualmemberfunction{ReadOtherFormat}.


\virtualmemberfunction{ReadOtherFormat} should decide just how/if it can 
read the data by examining the \argument{fmt} and \argument{encoding} 
parameters.  If the data cannot be read or the reading fails the 
\argument{file} should be left at the same position and \constant{FALSE} 
should be returned.  \



\section{2.4	SetModified}


\type{void} \class{dataobject}::\virtualmemberfunction{SetModified}();

\type{long} \class{dataobject}::\virtualmemberfunction{GetModified}();


The \virtualmemberfunction{SetModified} protocol allows a 
\classobject{dataobject} to indicate whether it has been changed in such a 
way that it should be re-written to permanent storage.  For example when a 
character is typed into a \classobject{text} object running under ez, the 
\virtualmemberfunction{SetModified} is called to assign a new modification 
number to the \classobject{text}.  When \classobject{buffer}'s 
\virtualmemberfunction{ObservedChanged} method is called it calls 
\virtualmemberfunction{GetModified} on the \classobject{text} and if the 
return value is greater than the value \virtualmemberfunction{buffer} has 
stored it marks the \virtualmemberfunction{buffer} as modified.



\chapter{3.	Fonts}


static \type{\class{fontdesc} 
*}\class{fontdesc}::\staticmemberfunction{Create}(\type{char 
*}\argument{FontName}, \type{long} \argument{FontStyle}, \type{long} 
\argument{FontSize});


Creates a 'font descriptor' which is used with the cursor, graphic and view 
classes to select a font for drawing text, or for selecting a cursor glyph.

\argument{FontName} may be one of "times", "helvetica", "courier", 
"symbol", "andy", "andysans", or "andytype".  The andy* font names are 
synonyms for "times", "helvetica" and "courier" respectively, except that a 
'fudge addition' (2 by default) is applied to the size of the font in 
points.  Under X the "times", "helvetica", "courier", "symbol" and other 
valid X font family names may be used.


\argument{FontStyle} is an 'or' of the following values:


\preproc{#define \constant{fontdesc_All}		-	1	// All the attributes}

\preproc{#define \constant{fontdesc_Plain}		0	// No modifier, the base font}

\preproc{#define \constant{fontdesc_Bold}		1	// A bold version of the font}

\preproc{#define \constant{fontdesc_Italic}		2	// An italic version of the 
font}

\preproc{#define \constant{fontdesc_Shadow}		4	// No X support.}

\preproc{#define \constant{fontdesc_Fixed}		8	// A fixed width version of 
the

							// results in courier unless

							// the given FontName actually

							// is fixed width.}

\preproc{#define \constant{fontdesc_Outline} 		16	// No X support.}

\preproc{#define \constant{fontdesc_Thin}		32	// No X support.}

\preproc{#define \constant{fontdesc_Black}		64	// No X support.}

\preproc{#define \constant{fontdesc_Medium}		128	// A demibold version of 
the font.}

\preproc{#define \constant{fontdesc_Heavy}		256	// No X support}

\preproc{#define \constant{fontdesc_Condense} 	512	// A condensed version 
of the font.}


\argument{FontSize} is the size desired in points.


static \type{boolean} 
\class{fontdesc}::\staticmemberfunction{ExplodeFontName}(\type{char 
*}\argument{fontName}, \type{char *}\argument{familyName}, \type{long} 
\argument{bufSize}, \type{long *}\argument{fontStyle}, \type{long 
*}\argument{fontSize});

Parses \argument{fontName} in the format:

<family name><optional "-" or "-s"><point size><style modifiers>


 Where the style modifiers consist of the following single modifier codes:

     b    bold

     i    italic

     f    fixed width    (This is bogus and should disappear)

     s    shadow


If there is no font size in the name (i.e. no numbers in the name), and the 
entire name is returned as the familyName and the size and style are set to 
0.  Otherwise the \argument{familyName} string is filled in (up to 
\argument{bufSize} bytes including a terminating NUL.), and 
*\argument{fontStyle} and *\argument{fontSize} are initialized with the 
corresponding values from the \argument{fontName}.

This routine is useful in converting a preference setting or other user 
selection into data suitable for 
\class{fontdesc}::\staticmemberfunction{Create}.


\type{
char *}\class{fontdesc}::\virtualmemberfunction{GetFontFamily}();

Returns the font family.


\type{long} \class{fontdesc}::\virtualmemberfunction{GetFontSize}();

Returns the size of the font in points.


\type{long} \class{fontdesc}::\virtualmemberfunction{GetFontStyle}();

Returns the mask of styles applied to the font.  (See 
\class{fontdesc}::\staticmemberfunction{Create}.)


\type{\class{graphic} 
*}\class{fontdesc}::\virtualmemberfunction{CvtCharToGraphic}(\type{\class{gr\
aphic} *}\argument{gr}, \type{char} \argument{SpecialChar});

Creates a \classobject{graphic} from which you can copy all or part of the 
character \argument{specialChar} in \classobject{fontdesc} to screen using 
the \class{graphic}::\virtualmemberfunction{BitBlt} method on \argument{gr}.


\type{long} 
\class{fontdesc}::\virtualmemberfunction{StringSize}(\type{\class{graphic} 
*}\argument{gr}, \type{char *}\argument{string}, \type{long 
*}\argument{XSpacing}, \type{long *}\argument{YSpacing});

Returns the spacing from the first pixel of \argument{string} to the first 
pixel after the \argument{string} if it is drawn in the given 
\classobject{graphic} \argument{gr} in this font.  \argument{gr} is the 
\classobject{graphic} the information should be computed for. 
*\argument{XSpacing} is filled in with the same value as is returned. 
 *\argument{YSpacing} is set to 0 under X.\type{


long} 
\class{fontdesc}::\virtualmemberfunction{TextSize}(\type{\class{graphic} 
*}\argument{gr}, \type{char *text}, \type{long} \argument{n}, \type{long 
*}\argument{XSpacing}, \type{long *}\argument{YSpacing});

Returns the spacing from the first pixel of \argument{text} to the first 
pixel after the \argument{n}th character in \argument{text} if it is drawn 
in the given \classobject{graphic} \argument{gr} in this font. 
 \argument{gr} is the \classobject{graphic} the information should be 
computed for. *\argument{XSpacing} is filled in with the same value as is 
returned.  *\argument{YSpacing} is set to 0 under X.


\type{long} 
\class{fontdesc}::\virtualmemberfunction{StringBoundingBox}(\type{\class{gra\
phic} *}\argument{gr}, \type{char *}\argument{string}, \type{int 
*}\argument{width}, \type{int *}\argument{height});

Returns the width and height (in *\argument{width} and *\argument{height}) 
of the rectangle which contains all the pixels touched by drawing 
\argument{string} in \argument{gr} with this font.


\type{short 
*}\class{fontdesc}::\virtualmemberfunction{WidthTable}(\type{\class{graphic} 
*}\argument{gr});

Returns a table of 256 shorts, each giving the width of the corresponding 
character in the font.  The returned data should be freed with free.


\type{short 
*}\class{fontdesc}::\virtualmemberfunction{HeightTable}(\type{\class{graphic\
} *}\argument{gr});

Returns a table of 256 shorts, each giving the width of the corresponding 
character in the font.  The returned data should be freed with free.


\type{struct FontSummary 
}*\class{fontdesc}::\virtualmemberfunction{FontSummary}(\type{\class{graphic\
} *}\argument{gr});\keyword{

struct} FontSummary \{

    \keyword{short} maxWidth;	\comment{/* the max char width over the whole 
font */}

    \keyword{short} maxHeight;	\comment{/* the max above+below for the 
whole font */}

    \keyword{short} newlineHeight;\comment{/* recommended newline distance 
for the font */}

    \keyword{short} maxSpacing;	\comment{/* the max spacing in x direction 
*/}

    \keyword{short} maxBelow;	\comment{/* the max below for the whole font 
*/}

    \keyword{short} maxLeft;	\comment{/* the max to the left of the origin 
*/}

\};

Returns a pointer to FontSummary structure giving statistics on this font 
when used with \argument{gr}.


\keyword{\type{void}} 
\class{fontdesc}::\virtualmemberfunction{CharSummary}(\type{\class{graphic} 
*}\argument{gr}, \keyword{\type{char}} \argument{LookUpChar}, 
\type{\keyword{struct} fontdesc_charInfo *}\argument{returnedInfo});

\keyword{struct} fontdesc_charInfo \{

    \keyword{short} width;			\comment{/* Width of bounding box */}

    \keyword{short} height;			\comment{/* Height of bounding box */}

    \keyword{short} xOriginOffset;	        \comment{/* X offset from left 
of bb */}

    \keyword{short} yOriginOffset;		\comment{/* Y offset from top of bb */}

    \keyword{short} xSpacing;		\comment{/* hor dist from this origin to 
next*/}

    \keyword{short} ySpacing;		\comment{/* vert dist from this origin to 
next */}

\};

Fills in *\argument{returnedInfo} with the statistics on the 
\argument{LookUpChar} in this font when used with \argument{gr}.


\type{boolean} \class{fontdesc}::\memberfunction{CharValid}(\type{char} 
\argument{c});

Returns \constant{TRUE} if the character c is defined in this font, 
otherwise it returns \constant{FALSE}.


\chapter{
4.	Cursors}


\type{\class{cursor} 
*}\class{cursor}::\staticmemberfunction{Create}(\type{\class{view} 
*}\argument{v});

Creates a \classobject{cursor} for use with view \argument{v}.


\type{void} 
\class{cursor}::\virtualmemberfunction{SetGlyph}(\type{\class{fontdesc} 
*}\argument{f}, \type{short} \argument{ch});

Sets the \classobject{cursor}'s glyph to be the character \argument{ch} in 
the font selected by \argument{f}.


\type{void} \class{cursor}::\virtualmemberfunction{SetStandard}(\type{short} 
\argument{ch});

Sets the \classobject{cursor}'s glyph to be the character \argument{ch} in 
the standard font.  The characters available in the standard font include:


\preproc{#define \constant{Cursor_Arrow}			1}

\preproc{#define \constant{Cursor_Gunsight}			2}

\preproc{#define \constant{Cursor_Cross}			3}

\preproc{#define \constant{Cursor_Wait}				4}

\preproc{#define \constant{Cursor_HorizontalBars}		5}

\preproc{#define \constant{Cursor_LowerRightCorner}	6}

\preproc{#define \constant{Cursor_UpperLeftCorner}	7}

\preproc{#define \constant{Cursor_VerticalBars}		8}

\preproc{#define \constant{Cursor_DangerousBend}	9}

\preproc{#define \constant{Cursor_Caret}			10}

\preproc{#define \constant{Cursor_VerticalArrows}		11}

\preproc{#define \constant{Cursor_HorizontalArrows}	12}

\preproc{#define \constant{Cursor_Octagon}			13}

\preproc{#define \constant{Cursor_LeftPointer}		14}

\preproc{#define \constant{Cursor_RightPointer}		15}

\preproc{#define \constant{Cursor_CrossHairs}		16}

\preproc{#define \constant{Cursor_DownPointer}		17}

\preproc{#define \constant{Cursor_UpPointer}		18}

\preproc{#define \constant{Cursor_Cutter}			19}

\preproc{#define \constant{Cursor_LargeUpArrow}		20}

\preproc{#define \constant{Cursor_LargeDownArrow} 	21}

\preproc{#define \constant{Cursor_EnclosedDot}		22}

\preproc{#define \constant{Cursor_SmallCross}		23}

\preproc{#define \constant{Cursor_SmallLeftPointer}	24}

\preproc{#define \constant{Cursor_SmallRightPointer}	25}

\section{

}\chapter{5.	view}

\section{
5.1	Creating a View}


First the object itself must be created of course:

\type{\class{view} *}v=new \class{testview};

Then usually the view will be associated with a dataobject:

v->SetDataObject(testdata);


\section{5.2	Destroying a View}


Since \class{view} is a derived class of \class{traced} (indirectly) it 
must be destroyed by calling its \virtualmemberfunction{Destroy}() method:

v->Destroy();


\section{5.3	Dataobject Interfacing}


These methods deal with testing whether a dataobject is compatible with a 
view, and setting up the connections between the view and the data.


\type{boolean} \class{view}::\virtualmemberfunction{CanView}(\type{char 
*}\argument{Type});

Returns \constant{TRUE} if this view can view a \class{dataobject} of 
\argument{Type}, otherwise it returns \constant{FALSE}.  The default 
implementation just returns \constant{TRUE}.


\type{\class{dataobject} *}\class{view}::\memberfunction{GetDataObject}();

Returns the \classobject{dataobject} associated with the 
\classobject{view}, or \constant{NULL} if no \classobject{dataobject} is 
associated with the \classobject{view}.


\type{void} 
\class{view}::\virtualmemberfunction{SetDataObject}(\type{\class{dataobject} 
*}\argument{dobj});

Sets the \classobject{dataobject} (\argument{dobj}) associated with the 
\classobject{view}.  The \classobject{view} will observe \argument{dobj} 
and hold a reference to it.  The \argument{dobj} cannot be destroyed until 
the \classobject{view} releases this reference, either when the 
\classobject{view} is destroyed, or when a new \classobject{dataobject} is 
set for it.    (See Change Notification and Screen Updates.)


\section{5.4	Scrolling and Other Application Layers}


These methods are used to obtain a view which performs any services which 
the view called thinks are appropriate for its use in the context of an 
application.  The most common such view is a scrollbar or other scrolling 
device.


\type{\class{view} 
*}\class{view}::\virtualmemberfunction{GetApplicationLayer}();

Returns the 'application layer' for the \classobject{view}.  Usually this 
will be a \classobject{scroll view}, but it may be some other 
\classobject{view}.  In any case the returned \classobject{view} should be 
inserted and linked into the \classobject{view} tree in place of the 
original \classobject{view}.  Note that 
\virtualmemberfunction{GetApplicationLayer} may return the view which was 
passed in if no application layer is desired.


\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{DeleteApplicationLayer}(\type{\class{vi\
ew} *}\argument{applicationLayer});

When an application layer is no longer needed 
\virtualmemberfunction{DeleteApplicationLayer} should be called to destroy 
it.


\section{5.5	The IM}


\type{\class{im} *}\class{view}::\memberfunction{GetIM}();

Returns the im associated with the view.  This is useful for checking 
whether the view is connected to any display hardware, and for getting the 
im for a variety of manipulations on the window.


\section{5.6	Coordinate Conversion}


These methods adjust coordinates in a parent's coordinate system so that 
they are relative to a child's coordinate system.


\type{long} \class{view}::\memberfunction{EnclosedXToLocalX}(\type{long} 
\argument{parentx});

Returns the coordinate \argument{parentx} adjusted for use in the child's 
coordinate system.  (When called on the child view.)


\type{long} \class{view}::\memberfunction{EnclosedYToLocalY}(\type{long} 
\argument{parenty});

Returns the coordinate \argument{parenty} adjusted for use in the child's 
coordinate system.  (When called on the child view.)


\section{5.7	Colormaps}


\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{WantColormap}(\type{\class{view} 
*}\argument{requestor}, \type{\class{colormap} **}\argument{cmap});

\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{ReceiveColormap}(\type{\class{colormap} 
*}\argument{cmap});

\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{LoseColormap}(\type{\class{colormap} 
*}\argument{cmap});

\type{\class{colormap} **}\class{view}::\memberfunction{GetColormap}();

\type{\class{colormap} **}\class{view}::\memberfunction{CurrentColormap}();


\section{5.8	Mouse Input}


\type{\class{view} *}\class{view}::Hit (\type{\keyword{enum} 
view_MouseAction} \argument{action}, \keyword{\type{long}} \argument{x}, 
\keyword{\type{long}} \argument{y}, \keyword{\type{long}} 
\argument{numberOfClicks});

\type{char 
*}\class{view}::\virtualmemberfunction{WantInformation}(\type{char 
*}\argument{key});


\virtualmemberfunction{Hit} is called when the user has changed the mouse 
state, depressing a button, moving it with a button depressed, or releasing 
a button.  (If dag&drop support is compiled in Hit is also called for file 
drops, but this support is fairly rudimentary and may be changed.)


The cases are distinguished by the type parameter as follows:


\indent{\constant{view_LeftDown} --  The left mouse button was pressed.

\constant{view_LeftUp} -- The left mouse button was released.

\constant{view_LeftMovement} -- The mouse was moved with the left mouse 
button pressed.

\constant{view_RightDown} -- The right mouse button was pressed.

\constant{view_RightUp} -- The right mouse button was released.

\constant{view_RightMovement} -- The mouse was moved with the right mouse 
button pressed.

\constant{view_LeftFileDrop} -- A file was dropped with the left mouse 
button.

\constant{view_MiddleFileDrop} -- A file was dropped with the middle mouse 
button.

\constant{view_RightFileDrop} -- A file was dropped with the right mouse 
button.

}
The \argument{x} and \argument{y} parameters indicate where within the view 
the mouse was at the time of the change.  numberofClicks indicates how many 
times a mouse button has been pressed consecutively at the same location.


If the mouse hit is within a child of the view then the child's 
\virtualmemberfunction{Hit} method should be called after appropriately 
modifying the \argument{x} and \argument{y} coordinates and the return 
value from that call should be returned by \virtualmemberfunction{Hit}. 
 This will be covered in more detail in the section titled Substrates.


A view with no children must return a pointer to itself (\argument{this}).


When running under the X Window System 
\virtualmemberfunction{WantInformation} can be used within the 
\virtualmemberfunction{Hit} method to find out what modifier keys are 
pressed.  The call \virtualmemberfunction{WantInformation}("hit_modifiers") 
will return a string containing upto 3 characters.  An 's' will be present 
if the shift key is pressed, 'c' for the control key, and 'm' for the meta 
key.  The call \virtualmemberfunction{WantInformation}("hit_all_modifiers") 
is the same as "hit_modifiers" except that the lock keys are also checked, 
caps/shift lock is represent by an 'l', and num lock is represented by an 
'n'.  It follows of course that "hit_all_modifiers" may return up to 5 
characters.  The string returned by \virtualmemberfunction{WantInformation} 
will be overwritten on subsequent calls.


\section{5.9	Screen Updates}

\subsection{
5.9.1	Drawing}


\type{\class{graphic} *}\class{view}::\memberfunction{GetDrawable}();

Returns the \classobject{graphic} object actually representing the display. 
 This is needed in some of the calls below to indicate the destination for 
some BitBlt operations for example.


\type{void} \class{view}::\memberfunction{BitBlt}(\type{struct rectangle 
*}\argument{SrcRect},

	\type{\class{graphic} *}\argument{DestGraphic},

	\type{struct point *}\argument{DstOrigin},

	\type{struct rectangle *}\argument{ClipRect})

\type{void} \class{view}::\memberfunction{BitBltSize}(	\type{long} 
\argument{srcX},

				\type{long} \argument{srcY},

				\type{long} \argument{dstX},

				\type{long} \argument{dstY},

				\type{long} \argument{Width},

				\type{long} \argument{Height}, \


				\type{\class{graphic} *}\argument{DstGraphic},

				\type{long} \argument{clipX},

				\type{long} \argument{clipY},

				\type{long} \argument{clipWidth},

				\type{long} \argument{clipHeight});

Transfers the area \argument{SrcRect} in this \classobject{view} to 
\argument{DestGraphic}, with the upper left of the source appearing at 
\argument{DstOrigin} in the \argument{DestGraphic}.  The \argument{ClipRect} 
argument is ignored.  If part of the area indicated by \argument{SrcRect} 
is obscured the results are undefined.


The \memberfunction{BitBltSize} form of this function fills in the 
structures and calls \memberfunction{BitBlt}.


\type{\class{graphic} *}\class{view}::\memberfunction{BlackPattern}();

Returns a graphic suitable for use as a tile argument in the fill methods. 
 This graphic rquests a solid fill with the foreground color.


\type{\class{graphic} 
*}\class{view}::\memberfunction{GrayPattern}(\type{short} 
\argument{IntensityNum}, \type{short} \argument{IntensityDenom});

Returns a \classobject{graphic} suitable for use as a tile argument in the 
fill methods.

This graphic requests a pattern which is 
\argument{IntensityNum}*100/\argument{IntensityDenom} % foreground and 
(100-\argument{IntensityNum}*100/\argument{IntensityDenom})% background.


\type{\class{graphic} *}\class{view}::\memberfunction{WhitePattern}();

Returns a graphic suitable for use as a tile argument in the fill methods. 
 This graphic rquests a solid fill with the background color.

void ClearClippingRect();

Removes any clipping in effect.


static \type{void} 
\class{graphic}::\staticmemberfunction{ComputeShadow}(\type{long} 
\argument{br},

							\type{long} \argument{bg},

							\type{long} \argument{bb},

							\type{long} *\argument{rr},

							\type{long} *\argument{rg},

							\type{long} *\argument{rb,}

							\type{int} \argument{shadow});

static \type{void} 
\class{graphic}::\staticmemberfunction{ComputeShadowDouble}(double 
\argument{br},

	double \argument{bg},

	double \argument{bb},

	double *\argument{rr},

	double *\argument{rg},

	double *\argument{rb},

	int \argument{shadow});


For a given background color \argument{br},\argument{ bg}, \argument{bb}, 
(range 0-65535) this function computes the color for the specified 
\argument{shadow} and stores it in 
*\argument{rr},*\argument{rg},*\argument{rb}.  The shadow value must be one 
of:


\constant{shadows_PRESSED} is for use in the background of the button while 
it is pressed.

\constant{shadows_TOPSHADOW} requests the color for the upper left of the 
shadow.

\constant{shadows_BOTTOMSHADOW} requests the color for the bottom right of 
the shadow.


\staticmemberfunction{ComputerShadowDouble} uses ranges from 0.0 to 1.0 
instead of 0 to 65535.


\type{\class{colormap} **}\class{view}::\memberfunction{CurrentColormap}();

Returns the currently installed colormap.


\type{\class{colormap} **}\class{view}::\memberfunction{GetColormap}();

Returns the private colormap for this \classobject{view}, or \constant{NULL} 
if none has been set.


\type{long} \class{view}::\memberfunction{DisplayClass}();

Returns a bit mask that describes the display that the application is 
using.  The return value consists of the appropriate symbols bitwise-or'ed 
together.  The set of possible values includes symbols for the six display 
classes defined by X11, plus additional symbols defined by the graphic 
class:


\typewriter{\indent{graphic_Monochrome

graphic_Color

graphic_PseudoColor

graphic_GrayScale

graphic_DirectColor

graphic_TrueColor

graphic_StaticColor

graphic_StaticGray}}


All color displays will have \typewriter{graphic_Color}  or'ed in with the 
appropriate display class symbol. StaticGray displays with a colormap of 
size 2 will have \typewriter{graphic_Monochrome} or'ed in.


\type{void} \class{view}::\memberfunction{DrawArc}(\type{struct rectangle 
*}\argument{EnclRect},

	\type{short} \argument{StartAngle},

	\type{short} \argument{OffsetAngle});

\type{void} \class{view}::\memberfunction{DrawArcSize}(\type{long} 
\argument{x},

	\type{long} \argument{y},

	\type{long} \argument{width},

	\type{long} \argument{height},

	\type{short} \argument{StartAngle},

	\type{short} \argument{OffsetAngle});

Draws an arc which is a portion of the oval that would fill the rectangle 
\argument{EnclRect}.  The arc begins at \argument{StartAngle} degrees and 
extends for \argument{OffsetAngle} degrees, where angles are measured 
clockwise from North.

\memberfunction{DrawArcSize} fills in the rectangle and calls 
\memberfunction{DrawArc}.

\begindata{figure,538136856}
$origin 254 -149
$printscale 1.000000 1.000000
#none 0
\begindata{figogrp,1272576}
\figattr{
}
$ 0 293 -134 889 842
$endatt
\enddata{figogrp,1272576}
\begindata{figogrp,12756000}
attrs: -1 1 10 black 12 0 andy 0 8 0 5 0
$ 0 366 -85 816 552
$endatt
\enddata{figogrp,12756000}
\begindata{figoell,12062632}
attrs: -1 1 10 black 12 0 andy 0 8 0 5 0
$ 428 -12
$ 646 410
$endatt
\enddata{figoell,12062632}
\begindata{figorect,12055712}
attrs: 0 1 10 white 12 0 andy 0 8 0 5 0
$ 370 -81
$ 365 543
$endatt
\enddata{figorect,12055712}
\begindata{figorect,12057304}
attrs: 0 1 10 white 12 0 andy 0 8 0 5 0
$ 620 212
$ 557 250
$endatt
\enddata{figorect,12057304}
\begindata{figorect,12059496}
attrs: -1 1 10 black 12 0 andy 0 8 0 5 0
$ 425 -9
$ 646 416
$endatt
\enddata{figorect,12059496}
#end
\begindata{figotext,12756912}
attrs: -1 1 10 black 10 0 andysans 1 8 0 5 0
$ 429 505
$ 0 0
StartAngle=040=075=0400=000
$endatt
\enddata{figotext,12756912}
\begindata{figotext,12654560}
attrs: -1 1 10 black 10 0 andysans 1 8 0 5 0
$ 492 -96
$ 0 0
EnclRect=000
$endatt
\enddata{figotext,12654560}
\begindata{figospli,12821856}
attrs: -1 1 10 black 10 0 andysans 1 4 1 48 0
$$ 0 5 0 0
$ 473 -102
$ -115 19
$ -147 114
$ -121 172
$ -70 185
$endatt
\enddata{figospli,12821856}
\begindata{figotext,9445848}
attrs: -1 1 10 black 10 0 andysans 1 4 1 48 0
$ 556 204
$ 0 0
Arc=000
$endatt
\enddata{figotext,9445848}
\begindata{figospli,12810288}
attrs: -1 1 10 black 10 0 andysans 1 4 1 48 0
$$ 0 4 0 0
$ 748 204
$ 109 -6
$ 173 -51
$ 212 -128
$endatt
\enddata{figospli,12810288}
\begindata{figotext,12797552}
attrs: -1 1 10 black 10 0 andysans 1 8 0 5 0
$ 441 620
$ 0 0
OffsetAngle=07590=000
$endatt
\enddata{figotext,12797552}
#end
\enddata{figure,538136856}
\view{figview,538136856,1,172,143}

\type{void}  \class{view}::\memberfunction{DrawLine}(\type{long} 
\argument{DeltaX}, \type{long} \argument{DeltaY});

Draws a line in the foreground color from the current point to the point 
CurrentX+\argument{DeltaX},CurrentY+\argument{DeltaY}.  The current point 
is moved to CurrentX+\argument{DeltaX},CurrentY+\argument{DeltaY}.

\begindata{figure,538154456}
$origin 79 -119
$printscale 1.000000 1.000000
#none 0
\begindata{figogrp,12827416}
\figattr{
}
$ 0 358 121 788 863
$endatt
\enddata{figogrp,12827416}
\begindata{figotext,1122816}
\figattr{
shade:8
color:black
linewidth:1
rrectcorner:10
fontsize:10
fontstyle:0
fontfamily:andy
textpos:0
}
$ 469 121
$ 0 0
current=040point=000
$endatt
\enddata{figotext,1122816}
\begindata{figoplin,1122560}
\figattr{
shade:2
color:black
linewidth:1
rrectcorner:10
fontsize:10
fontstyle:0
fontfamily:andy
textpos:0
arrowsize:4
arrowpos:3
arrow:48
}
$$ 0 2 0 0
$ 460 326
$ 0 467
$endatt
\enddata{figoplin,1122560}
\begindata{figoplin,1123584}
\figattr{
shade:2
color:black
linewidth:1
rrectcorner:10
fontsize:10
fontstyle:0
fontfamily:andy
textpos:0
arrowsize:4
arrowpos:3
arrow:48
}
$$ 0 2 0 0
$ 446 857
$ 637 0
$endatt
\enddata{figoplin,1123584}
\begindata{figotext,1124608}
\figattr{
shade:2
color:black
linewidth:1
rrectcorner:10
fontsize:10
fontstyle:0
fontfamily:andy
textpos:0
}
$ 745 896
$ 0 0
DeltaX=000
$endatt
\enddata{figotext,1124608}
\begindata{figotext,1124352}
\figattr{
shade:2
color:black
linewidth:1
rrectcorner:10
fontsize:10
fontstyle:0
fontfamily:andy
textpos:0
}
$ 402 357
$ -1 -30
D=012e=012l=012t=012a=012Y=000
$endatt
\enddata{figotext,1124352}
\begindata{figogrp,11592896}
\figattr{
shade:8
color:black
linewidth:1
rrectcorner:10
fontsize:10
fontstyle:0
fontfamily:andy
textpos:0
}
$ 0 426 216 52 64
$endatt
\enddata{figogrp,11592896}
\begindata{figoell,908288}
\figattr{
shade:8
color:black
linewidth:1
rrectcorner:10
fontsize:10
fontstyle:0
fontfamily:andy
textpos:0
}
$ 430 220
$ 43 55
$endatt
\enddata{figoell,908288}
#end
\begindata{figogrp,11592896}
\figattr{
shade:8
color:black
linewidth:1
rrectcorner:10
fontsize:10
fontstyle:0
fontfamily:andy
textpos:0
}
$ 0 1094 787 52 64
$endatt
\enddata{figogrp,11592896}
\begindata{figoell,908288}
\figattr{
shade:8
color:black
linewidth:1
rrectcorner:10
fontsize:10
fontstyle:0
fontfamily:andy
textpos:0
}
$ 1098 791
$ 43 55
$endatt
\enddata{figoell,908288}
#end
\begindata{figoplin,11233752}
attrs: 8 3 10 black 10 0 andy 0 4 0 48 2
$$ 0 2 0 0
$ 492 281
$ 570 499
$endatt
\enddata{figoplin,11233752}
\begindata{figotext,12678104}
attrs: 8 3 10 black 10 0 andy 0 4 0 48 2
$ 1062 377
$ 0 0
line=000
$endatt
\enddata{figotext,12678104}
\begindata{figospli,12530448}
attrs: 8 1 10 black 10 0 andy 0 3 1 48 0
$$ 0 4 0 0
$ 947 377
$ -77 -45
$ -147 -13
$ -211 64
$endatt
\enddata{figospli,12530448}
#end
\enddata{figure,538154456}
\view{figview,538154456,2,220,187}

\type{void} \class{view}::\memberfunction{DrawLineTo}(\type{long} 
\argument{XEnd}, \type{long} \argument{YEnd});

Draws a line from the current point to the point \argument{XEnd}\italic{, 
}\argument{YEnd}.  The current point is moved to \argument{XEnd}\italic{, 
}\argument{YEnd}.


\type{void} \class{view}::\memberfunction{DrawLineToPt}(\type{struct point 
*}\argument{LineEnd});

Draws a line from the current point to the point \argument{LineEnd}.  The 
current point is moved to \argument{LineEnd}.


\type{void} \class{view}::\memberfunction{DrawOval}(\type{struct rectangle 
*}\argument{Rect});

\type{void} \class{view}::\memberfunction{DrawOvalSize}(\type{long} 
\argument{x}, \type{long} \argument{y}, \type{long} \argument{width}, 
\type{long} \argument{height});

Draws an oval bounded by \argument{Rect}.  \memberfunction{DrawOvalSize} 
fills in a rectangle and calls \memberfunction{DrawOval}.


\type{void} \class{view}::\memberfunction{DrawPath}(\type{struct point 
*}\argument{PointArray},  \type{short} \argument{PointCount});

Draws a series of \argument{PointCount} lines described by the list of 
points defined by \argument{PointArray}. The last point in 
\argument{PointArray} is not connected to the first point.


\type{void} \class{view}::\memberfunction{DrawPolygon}(\type{struct point 
*}\argument{PointArray}, \type{short} \argument{PointCount});

Draws a sided, enclosed figure by drawing \argument{PointCount}+1 lines 
between the points defined in \argument{PointArray}. The last point in 
\argument{PointArray} is connected to the first point.


\type{void} \class{view}::\memberfunction{DrawRect}(\type{struct rectangle 
*}\argument{Rect});

\type{void} \class{view}::\memberfunction{DrawRectSize}(\type{long} 
\argument{left}, \type{long} \argument{top}, \type{long} \argument{width}, 
\type{long} \argument{height});

Draws a rectangle with corners at (\argument{left}, \argument{top}), 
(\argument{left}+\argument{width}, \argument{top}), 
(\argument{left}+\argument{width}, \argument{top}+\argument{height}), and 
(\argument{left}, \argument{top}+\argument{height}).

\begindata{figure,538178360}
$origin 254 -73
$printscale 1.000000 1.000000
#none 0
\begindata{figogrp,1122560}
\figattr{
}
$ 0 274 23 748 592
$endatt
\enddata{figogrp,1122560}
\begindata{figotext,1124608}
\figattr{
shade:2
color:black
linewidth:1
rrectcorner:10
fontsize:10
fontstyle:0
fontfamily:andy
textpos:0
}
$ 414 23
$ 0 0
Rect=000
$endatt
\enddata{figotext,1124608}
\begindata{figorect,540830200}
\figattr{
shade:-1
color:black
linewidth:1
rrectcorner:10
fontsize:10
fontstyle:0
fontfamily:andy
textpos:0
}
$ 306 106
$ 695 482
$endatt
\enddata{figorect,540830200}
\begindata{figogrp,541475448}
attrs: -1 1 10 black 8 0 andy 0 8 2 48 0
$ 0 601 187 139 389
$endatt
\enddata{figogrp,541475448}
\begindata{figotext,541439384}
attrs: -1 1 10 black 8 0 andy 0 8 0 5 0
$ 696 300
$ 0 0
left+width=000
$endatt
\enddata{figotext,541439384}
\begindata{figotext,541473368}
attrs: -1 1 10 black 8 0 andy 0 8 0 5 0
$ 652 400
$ 0 0
left=000
$endatt
\enddata{figotext,541473368}
\begindata{figotext,541474040}
attrs: -1 1 10 black 8 0 andy 0 8 0 5 0
$ 657 187
$ 0 0
top=000
$endatt
\enddata{figotext,541474040}
\begindata{figotext,541474760}
attrs: -1 1 10 black 8 0 andy 0 8 0 5 0
$ 645 488
$ 0 0
top+height=000
$endatt
\enddata{figotext,541474760}
#end
\begindata{figoplin,541369592}
attrs: -1 1 10 black 8 0 andy 0 4 1 48 0
$$ 0 2 0 0
$ 644 156
$ 7 -63
$endatt
\enddata{figoplin,541369592}
\begindata{figoplin,541476488}
attrs: -1 1 10 black 8 0 andy 0 4 1 48 0
$$ 0 2 0 0
$ 914 288
$ 75 0
$endatt
\enddata{figoplin,541476488}
\begindata{figoplin,541478872}
attrs: -1 1 10 black 8 0 andy 0 4 1 48 0
$$ 0 2 0 0
$ 576 394
$ -270 0
$endatt
\enddata{figoplin,541478872}
\begindata{figoplin,541479624}
attrs: -1 1 10 black 8 0 andy 0 4 1 48 0
$$ 0 2 0 0
$ 688 519
$ -6 63
$endatt
\enddata{figoplin,541479624}
#end
\enddata{figure,538178360}
\view{figview,538178360,3,139,124}

\type{void} \class{view}::\memberfunction{DrawRRect}(\type{struct rectangle 
*}\argument{OuterBox}, \type{struct rectangle *}\argument{CornerBox});

\type{void} \class{view}::\memberfunction{DrawRRectSize}(\type{long} 
\argument{left}, \type{long} \argument{top}, \type{long} \argument{width}, 
\type{long} \argument{height},

					\type{long} \argument{cornerWidth}, long \argument{cornerHeight});

Draws a rectangle whose bounds are described by \argument{OuterBox }(or 
\argument{left, top, width, height} for 
\memberfunction{DrawRRectSize})\italic{.}  Each corner is rounded with an 
arc of an oval such that the rounded portion has the height and width of 
\argument{CornerBox} (or \argument{cornerWidth, cornerHeight} for 
\memberfunction{DrawRRectSize}).

\begindata{figure,538192616}
$origin 154 -226
$printscale 1.000000 1.000000
#none 0
\begindata{figogrp,1273088}
\figattr{
}
$ 0 302 -55 893 655
$endatt
\enddata{figogrp,1273088}
\begindata{figorrec,12151336}
\figattr{
shade:-1
color:black
linewidth:1
rrectcorner:30
fontsize:10
fontstyle:0
fontfamily:andy
textpos:0
}
$ 306 -50
$ 884 645
$endatt
\enddata{figorrec,12151336}
\begindata{figorect,12146904}
\figattr{
shade:-1
color:black
linewidth:1
rrectcorner:30
fontsize:10
fontstyle:0
fontfamily:andy
textpos:0
}
$ 307 -51
$ 192 191
$endatt
\enddata{figorect,12146904}
\begindata{figotext,12148240}
\figattr{
shade:-1
color:black
linewidth:1
rrectcorner:30
fontsize:12
fontstyle:0
fontfamily:andysans
textpos:1
}
$ 416 320
$ 0 0
CornerBox=000
$endatt
\enddata{figotext,12148240}
\begindata{figospli,9444384}
\figattr{
shade:-1
color:black
linewidth:1
rrectcorner:30
fontsize:12
fontstyle:0
fontfamily:andysans
textpos:1
arrowsize:4
arrowpos:1
arrow:48
}
$$ 0 4 0 0
$ 711 254
$ -1 -69
$ -59 -178
$ -174 -184
$endatt
\enddata{figospli,9444384}
#end
\enddata{figure,538192616}
\view{figview,538192616,4,193,153}

\type{void} \class{view}::\memberfunction{DrawString}(\type{char 
*}\argument{String}, \type{short} \argument{Operation});

\type{void} \class{view}::\memberfunction{DrawText}(\type{char 
*}\argument{String}, \type{long} \argument{Length}, \type{short} 
\argument{Operation});

Draws the characters in the nul-terminated \argument{String} in the current 
font at the current point.  The spacial relationship between the string 
drawn and the current position is specified by \argument{Operation}.  If 
the value of \argument{Operation} is 0, \constant{graphic_ATBASELINE} and 
\constant{graphic_ATLEFT} will be used as defaults.


\memberfunction{DrawText} operates identically to 
\memberfunction{DrawString} except that the first \argument{Length} 
characters are drawn, irrespective of nul-termination.


Values for \argument{Operation} are constructed by or-ing together a 
horizontal and a vertical alignment option. The horizontal alignment 
options are: \



(X, and Y) denote the current X and Y point set in the view and graphic.

\constant{\constant{graphic_NOMOVEMENT}}  -- the origin of the string will 
be at X.

\constant{graphic_ATRIGHT}  --  the rightmost part of the string will be at 
X.

\constant{graphic_ATLEFT}  --  the leftmost part of the string will be at X.

\constant{graphic_BETWEENLEFTANDRIGHT}  --  the center of the string will 
be at X.


The vertical alignment options are: \



\constant{graphic_NOMOVEMENT}  --  the origin of the string will be at Y.

\constant{graphic_ATTOP}  --  the topmost part of the string will be at Y.

\constant{graphic_ATBOTTOM}  --  the bottommost part of the string, 
including any descenders, will be at Y.

\constant{graphic_ATBASELINE}  --  the baseline of the string will be at Y.

\constant{graphic_BETWEENTOPANDBASELINE}  --  the center point of the 
string will be at Y.  The center is calculated from the topmost part of the 
string to the bottomost part, which will include descenders.

\constant{graphic_BETWEENTOPANDBOTTOM}  --  the center of the string will 
be at Y.  The center is calculated from the topmost part of the string to 
the baseline of the string.  No account is taken of descenders. This is 
likely to look better than \constant{graphic_BETWEENTOPANDBASELINE} in most 
cases.


\type{void} \class{view}::\memberfunction{DrawTrapezoid}(\type{long} 
\argument{topX}, \type{long} \argument{topY},

					\type{long} \argument{topWidth},

					\type{long} \argument{bottomX}, \type{long} \argument{bottomY},

					\type{long} \argument{bottomWidth});

Draws a trapezoid with corners at (\argument{topX}, \argument{topY}), 
(\argument{topX}+\argument{topWidth}, \argument{topY}), 
(\argument{bottomX}, \argument{bottomY}), and 
(\argument{bottomX}+\argument{bottomWidth}, \argument{bottomY}).

\begindata{figure,538248168}
$origin 0 0
$printscale 1.000000 1.000000
#none 0
\begindata{figogrp,538847336}
\figattr{
}
$ 0 676 256 1528 696
$endatt
\enddata{figogrp,538847336}
\begindata{figotext,541464024}
attrs: -1 1 10 black 8 0 andy 0 8 0 5 0
$ 864 288
$ 0 0
topX,=040topY=000
$endatt
\enddata{figotext,541464024}
\begindata{figotext,541464792}
attrs: -1 1 10 black 8 0 andy 0 8 0 5 0
$ 1872 288
$ 0 0
topX+topWidth,=040topY=000
$endatt
\enddata{figotext,541464792}
\begindata{figotext,541465512}
attrs: -1 1 10 black 8 0 andy 0 8 0 5 0
$ 720 864
$ 0 0
bottomX,=040bottomY=000
$endatt
\enddata{figotext,541465512}
\begindata{figotext,541466360}
attrs: -1 1 10 black 8 0 andy 0 8 1 48 0
$ 2160 864
$ 0 0
bottomX+bottomWidth,=040bottomY=000
$endatt
\enddata{figotext,541466360}
\begindata{figoplin,541911336}
attrs: -1 1 10 black 8 0 andy 0 4 1 48 0
$$ 0 2 0 0
$ 864 288
$ 144 144
$endatt
\enddata{figoplin,541911336}
\begindata{figoplin,541893336}
attrs: -1 1 10 black 12 0 andy 0 4 0 5 0
$$ 1 5 0 0
$ 1008 432
$ 720 0
$ 576 288
$ 144 288
$ 0 0
$endatt
\enddata{figoplin,541893336}
\begindata{figoplin,541426648}
attrs: -1 1 10 black 8 0 andy 0 4 1 48 0
$$ 0 2 0 0
$ 2016 288
$ -288 144
$endatt
\enddata{figoplin,541426648}
\begindata{figoplin,541912296}
attrs: -1 1 10 black 8 0 andy 0 4 1 48 0
$$ 0 2 0 0
$ 2160 864
$ -576 -144
$endatt
\enddata{figoplin,541912296}
\begindata{figoplin,541914744}
attrs: -1 1 10 black 8 0 andy 0 4 1 48 0
$$ 0 2 0 0
$ 720 864
$ 432 -144
$endatt
\enddata{figoplin,541914744}
#end
\enddata{figure,538248168}
\view{figview,538248168,5,0,207}

\type{void} \class{view}::\memberfunction{EraseRect}(\type{struct rectangle 
*}\argument{Rect});

\type{void} \class{view}::\memberfunction{EraseRect}(\type{long} 
\argument{left}, \type{long} \argument{top}, \type{long} \argument{width}, 
\type{long} \argument{height});

Clears the \argument{Rect} (or \argument{left}, \argument{top}, 
\argument{width}, \argument{height}) to the background color.  The width by 
height pixels will be cleared at left,top and proceeding down and to the 
right.


\type{void} \class{view}::\memberfunction{EraseVisualRect}();

Clears the area of the view which is visible to the background color.


\type{void} \class{view}::\memberfunction{FillArc}(\type{struct rectangle 
*}\argument{EnclRect},

				\type{short} \argument{StartAngle},

				\type{short} \argument{OffsetAngle},

				\type{\class{graphic} *}\argument{Tile});\type{

void} \class{view}::\memberfunction{FillArcSize}(\type{long} 
\argument{left}, \type{long} \argument{top},

				\type{long} \argument{width}, \type{long} \argument{height},

				\type{short} \argument{StartAngle},

				\type{short} \argument{OffsetAngle},

				\type{\class{graphic} *}\argument{Tile});


An arc is drawn with its center at (\argument{left}+\argument{width}/2, 
\argument{top}+\argument{height}/2), extending to potentially touch pixels 
with x coordinates between \argument{left} and 
\argument{left}+\argument{width}-1 inclusive, and y coordinates between 
\argument{top} and \argument{top}+\argument{height}-1 inclusive.  The arc 
begins at \argument{StartAngle} degrees and sweeps through 
\argument{OffsetAngle} degrees, where degrees are measured clockwise from 
North.  The area is filled with the pattern defined by \argument{Tile}. 
  (See \memberfunction{GrayPattern}.)  If \argument{Tile} is \constant{NULL} 
then a solid fill with the foreground color will be done.


\type{void} \class{view}::\memberfunction{FillOval}(\type{struct rectangle 
*}\argument{Rect}, \type{\class{graphic} *}\argument{Tile});

\type{void} \class{view}::\memberfunction{FillOvalSize}(\type{long} 
\argument{left}, \type{long} \argument{top},

					\type{long} \argument{width}, \type{long} \argument{height},

					\type{\class{graphic} *}\argument{Tile});


Fills the region described by an oval bounded by the box defined by a 
rectangle with a upper left-hand corner at (\argument{left},\argument{ 
top})\argument{ } and which is \argument{width} by \argument{height} pixels 
in size. The area is filled with the pattern defined by \argument{Tile}. 
  If \argument{Tile} is \constant{NULL} then a solid fill with the 
foreground color will be done.


\type{void} \class{view}::\memberfunction{FillPolygon}(\type{struct point 
*}\argument{PointArray},

				\type{short} \argument{PointCount},

				 \type{\class{graphic} *}\argument{Tile});


Fills the region described by the sided, enclosed figure by drawing lines 
from the points defined in \argument{PointArray}. The last point in 
\argument{PointArray} is connected to the first point. The region is filled 
with the pattern defined by \argument{Tile}.   If \argument{Tile} is 
\constant{NULL} then a solid fill with the foreground color will be done.


\type{void} \class{view}::\memberfunction{FillRect}(\type{struct rectangle 
*}\argument{Rect}, \type{\class{graphic} *}\argument{Tile});

\type{void} \class{view}::\memberfunction{FillRectsize}(\type{long} 
\argument{left}, \type{long} \argument{top},

				\type{long} \argument{width}, \type{long} \argument{height},

				\type{\class{graphic} *}\argument{Tile});

Fills the pixels which lie between \argument{left} and 
\argument{left}+\argument{width}-1 inclusive and \argument{top} and 
\argument{top}+\argument{height}-1 inclusive with the given 
\argument{Tile}.  If \argument{Tile} is \constant{NULL} then a solid fill 
with the foreground color will be done.


\type{void} \class{view}::\memberfunction{FillRgn}(\type{\class{region} 
*}\argument{Region}, \type{graphic *}\argument{Tile});

Fills the \argument{Region} with \argument{Tile}.  If \argument{Tile} is 
\constant{NULL} then a solid fill with the foreground color will be done.


\type{void} \class{view}::\memberfunction{FillRRect}(\type{struct rectangle 
*}\argument{OuterBox},

			   	\type{struct rectangle *}\argument{CornerBox},

				\type{\class{graphic} *}\argument{Tile});

\type{void} \class{view}::\memberfunction{FillRRectSize}(\type{long} 
\argument{left}, \type{long} \argument{top},

					\type{long} \argument{width}, \type{long} \argument{height},

					\type{long} \argument{cornerWidth}, \type{long} \argument{cornerHeight},

					\type{\localvariable{graphic} *}\argument{Tile});


Fills a rectangle bounded by the box defined by a rectangle with a upper 
left-hand corner at (\argument{left},\argument{ top}) and which is 
\argument{width} by \argument{height} pixels in size.  The rounding of each 
corner is tangent to a horizontal line at a point \argument{cornerWidth} 
pixels from the corner and to a vertical line \argument{cornerHeight} 
pixels from a corner. The region is filled with the pattern defined by 
\argument{Tile}, which may be \constant{NULL} to specify the foreground 
color.


\type{void} \class{view}::\memberfunction{FillTrapezoid}(\type{long} 
\argument{topX}, \type{long} \argument{topY},

					\type{long} \argument{topWidth},

					\type{long} \argument{bottomX}, \type{long} \argument{bottomY},

					\type{long} \argument{bottomWidth},

					\type{\class{graphic} *}\argument{Tile});


Fills the horizontal trapezoid whose top line extends \argument{topWidth} 
pixels to the right from (\argument{topX}, \argument{topY}) and whose 
bottom line extends \argument{bottomWidth} pixels to the right from 
(\argument{bottomX}, \argument{bottomY}). The region is filled with the 
pattern defined by \argument{Tile}, which may be \constant{NULL} to specify 
the foreground color.


\type{void} \class{view}::\memberfunction{FlushGraphics}();


Ensures that drawing commands are sent to the display server immediately.


\type{void} \class{view}::\memberfunction{GetBackgroundColor}(\type{char 
**}\argument{colorName},

						\type{long *}\argument{red},

						\type{long *}\argument{green},

						\type{long *}\argument{blue});

Returns the currently set background color. If the color was originally 
specified with a string name, *\argument{colorName} is set to that string, 
otherwise it is set to \constant{NULL}.  The value *\argument{red}, 
*\argument{green}, and *\argument{blue} are set from the current color. 
 (Whether is was set numerically or with a string name.)


\type{void} \class{view}::\memberfunction{GetBGColor}(\type{double 
*}\argument{red}, \type{double *}\argument{green}, \type{double 
*}\argument{blue});

Sets *\argument{red}, *\argument{green}, and *\argument{blue} as real 
numbers between 0.0 and 1.0 which describe the current background color.


\type{void} \class{view}::\memberfunction{GetClippingRect}(\type{struct 
rectangle *}\argument{Rect});

Sets *\argument{Rect} to a rectangle such that drawing oiperations to the 
graphic will not draw outside the rectangle.  If the graphic has a clipping 
region, the bounding box of this region is used. (Note that in this case, 
there may be areas which won't be drawn but which are within the 
rectangle.)  Otherwise, if there is a clipping rectangle, it is used. 
 Otherwise, the visual rectangle is used.


\type{\class{region} 
*}\class{view}::\memberfunction{GetClippingRegion}(\type{\class{region} 
*}\argument{Region});

If the graphic has a clipping region and \argument{Region} is not 
\constant{NULL}, the clipping region is copied into \argument{*Region} and 
\argument{Region} is returned.  Otherwise NULL is returned.


\type{void} \class{view}::\memberfunction{GetCurrentPt}(\type{struct point 
*}\argument{Point});

Returns copies the current point into *\argument{Point}.


static \type{void} 
\class{view}::\staticmemberfunction{GetDefaultColors}(\type{char 
**}\argument{foreground}, \type{char **}\argument{background});

Returns the current defaults for views which have no \argument{foreground} 
or \argument{background} explicitly set.


\type{long} \class{view}::\memberfunction{GetEnclosedBottom}();

Returns the Y coordinate in the parent's coordinate system of the last line 
of pixels at the bottom of the view.


\type{void} \class{view}::\memberfunction{GetEnclosedBounds}(\type{struct 
rectangle *}\argument{Rect});

Initializes \argument{Rect} with the location of the view in the parent's 
coordinate system.  The upper left pixel of the view is at 
(\argument{Rect}->left, \argument{Rect}->top) and the lower right is at 
(\argument{Rect}->left+\argument{Rect}->width, 
\argument{Rect}->top+\argument{Rect}->height-1).


\type{long} \class{view}::\memberfunction{GetEnclosedHeight}();

Returns the height of the view in the parent's coordinate system.


\type{long} \class{view}::\memberfunction{GetEnclosedLeft}();

Returns the leftmost X coordinate of the view in the parent's coordinate 
system.\type{


long} \class{view}::\memberfunction{GetEnclosedRight}();

Returns the rightmost X coordinate of the view in the parent's coordinate 
system.\type{


long} \class{view}::\memberfunction{GetEnclosedTop}();

Returns the topmost Y coordinate of the view in the parent's coordinate 
system.\type{


long} \class{view}::\memberfunction{GetEnclosedWidth}();

Returns the width of the view in the parent's coordinate system.


\type{void} \class{view}::\memberfunction{GetFgColor}(\type{double 
*}\argument{red}, \type{double *}\argument{green}, \type{double 
*}\argument{blue});

Returns real numbers between 0.0 and 1.0 in *\argument{red}, 
*\argument{green} and *\argument{blue} that describe the currently set 
foreground color.


\type{\class{fontdesc} *}\class{view}::\memberfunction{GetFont}();

Returns the current font for this \classobject{view}.


\type{void} \class{view}::\memberfunction{GetForegroundColor}(\type{char 
**}\staticmemberfunction{colorName},

						\type{long *}\argument{red},

						\type{long *}\argument{green},

						\type{long *}\argument{blue});

Returns the currently set foreground color. If \argument{colorName} was 
originally used to specify the color, both it and the resultant RGB values 
are returned. Otherwise only the RGB values are returned and *colorName is 
set to \constant{NULL}.


\type{long} \class{view}::\memberfunction{GetHorizontalResolution}();

Returns the horizontal resolution of the display in pixels per inch. 
 Typical values are around 75 and 100 dpi.


\type{short} \class{view}::\memberfunction{GetLineCap}();

Returns the line cap style in effect.  The values are as described for 
\memberfunction{SetLineCap}.


\type{void} \class{view}::\memberfunction{GetLineDash}(\type{char 
**}\argument{dashPattern},

					\type{int *}\argument{dashOffset},

					\type{short *}\argument{dashType});

Returns the current dash parameters in effect as set by the last call to 
\memberfunction{SetLineDash}.  *\argument{dashPattern} is \constant{NULL} 
if no dash pattern is in effect.


\type{short} \class{view}::\memberfunction{GetLineJoin}()

Returns the line join style in effect.  The value are as described for 
\memberfunction{SetLineJoin}.


\type{short} \class{view}::\memberfunction{GetLineWidth}();

Returns the current line width in pixels.  The line width defaults to 1 
pixel.


\type{long} \class{view}::\memberfunction{GetLogicalBottom}();

Returns the Y coordinate of the bottommost row of pixels in the view's 
coordinate system.


\type{void} \class{view}::\memberfunction{GetLogicalBounds}(\type{struct 
rectangle *}\argument{Rect});

Returns the left and top members of \argument{Rect} are initialized with 
the logical origin of the \classobject{view}, the width and height members 
are initialized with the logical size of the \classobject{view}.


\type{long} \class{view}::\memberfunction{GetLogicalLeft}();

Returns the X coordinate of the leftmost column of pixels in the 
\classobject{view}'s coordinate system.


\type{long} \class{view}::\memberfunction{GetLogicalRight}();

Returns the X coordinate of the rightmost column of pixels in the 
\classobject{view}'s coordinate system.


\type{long} \class{view}::\memberfunction{GetLogicalTop}();

Returns the Y coordinate of the topmost row of pixels in the 
\classobject{view}'s coordinate system.


\type{long} \class{view}::\memberfunction{GetLogicalWidth}();

Returns the logical width of the \classobject{view}.


\type{void} \class{view}::\memberfunction{GetPatternOrigin}(\type{long 
*}\argument{xpos}, \type{long *}\argument{ypos});

Fills in xpos and ypos with the offset to use when applyingTile patterns in 
drawing operations.


\type{short} \class{view}::\memberfunction{GetSpaceShim}();

Returns the amount of extra space to be included between words when using 
\memberfunction{DrawString} or \memberfunction{DrawText}.


\type{short} \class{view}::\memberfunction{GetTransferMode}();

Returns the transfer mode mask.  The possible values are as for 
\memberfunction{SetTransferMode}.


\type{long} \class{view}::\memberfunction{GetVerticalResolution}();

Returns the vertical resolution of the display in dots per inch.  Typical 
values are around 75 and 100 dpi.


\type{long} \class{view}::\memberfunction{GetVisualBottom}();

Returns the Y coordinate of the bottommost row of pixels in the view's 
coordinate system.


\type{void} \class{view}::\memberfunction{GetVisualBounds}(\type{struct 
rectangle *}\argument{Rect});

Returns the left and top members of \argument{Rect} are initialized with 
the visual origin of the \classobject{view}, the width and height members 
are initialized with the visual size of the \classobject{view}.


\type{long} \class{view}::\memberfunction{GetVisualLeft}();

Returns the X coordinate of the leftmost column of pixels in the 
\classobject{view}'s coordinate system.


\type{\class{region} 
*}\class{view}::\memberfunction{GetVisualRegion}(\type{\class{region} 
*}\argument{Region});

A region representing the entire drawable area of the view in the view's 
coordinate system will be copied into *\argument{Region}.


\type{long} \class{view}::\memberfunction{GetVisualRight}();

Returns the X coordinate of the rightmost column of pixels in the 
\classobject{view}'s coordinate system.


\type{long} \class{view}::\memberfunction{GetVisualTop}();

Returns the Y coordinate of the topmost row of pixels in the 
\classobject{view}'s coordinate system.


\type{long} \class{view}::\memberfunction{GetVisualWidth}();

Returns the visual width of the \classobject{view}.


\type{char *}\class{view}::\memberfunction{GetWindowManagerType}();

Returns "X11" under the X Window System, returns "wm" under the obsolete 
CMU WM window system.


\type{boolean} \class{view}::\argument{IsImageInverted}();

Returns \constant{TRUE} if the \classobject{pixelimage} data returned by 
\memberfunction{ReadPixImage} has 1 representing white and 0 for black, or 
\constant{FALSE} otherwise.


\type{void} \class{view}::\memberfunction{Move}(\type{long} 
\argument{DeltaX}, \type{long} \argument{DeltaY});

Move the current point to (currentX + \argument{DeltaX}, currentY + 
\argument{DeltaY}).


\type{void} \class{view}::\memberfunction{MoveLogicalOrigin}(\type{long} 
\argument{DeltaX}, \type{long} \argument{DeltaY});

Moves the logical origin to (currentLogicalX + \argument{DeltaX}, 
currentLogicalY + \argument{DeltaY}).


\type{void} \class{view}::\memberfunction{MoveTo}(\type{long} 
\argument{NewX}, \type{long} \argument{NewY});

Moves the current point to (\argument{NewX}, \argument{NewY}).


\type{void} \class{view}::\memberfunction{MoveToPt}(\type{struct point 
*}\argument{Point});

Moves the current point to \argument{Point}.


\type{void} \class{view}::\memberfunction{ReadPixImage}(\type{long} 
\argument{SrcX},

	\type{long} \argument{SrcY},

	\type{\class{pixelimage} *}\argument{DestPixels},

	\type{long} \argument{DestX},

	\type{long} \argument{DestY},

	\type{long} \argument{width},

	\type{long} \argument{height});

Copies data from the rectangle (\argument{SrcX}, \argument{SrcY}, 
\argument{width}, \argument{height}) in the \filescopefunction{view} to 
(\argument{DestX}, \argument{DestY}) in the *\argument{DestPixels} 
\classobject{pixelimage}.  \class{pixelimage} supports only monochrome 
images.  See \memberfunction{IsImageInverted} to determine if a 1 or 0 in 
the returned data represents white or black or vice versa.


\type{void} \class{view}::\memberfunction{SetBackgroundColor}(\type{char 
*}\argument{colorName},

						\type{long} \argument{red},

						\type{long} \argument{green},

						\type{long} \argument{blue});

Sets the backgound color. If \argument{colorName} is \constant{NULL},  the 
\argument{red}, \argument{green}, and \argument{blue} values are used, 
otherwise \argument{colorName} is used to look up the RGB values.


\type{void} \class{view}::\memberfunction{SetBGColor}(\type{double} 
\argument{red},

				\type{double} \argument{green},

				\type{double} \argument{blue});

Sets background color.  The \argument{red}, \argument{green}, and 
\argument{blue} real numbers are values  between 0.0 and 1.0 that describe 
the desired background color.


\type{void} \class{view}::\memberfunction{SetClippingRect}\type{(struct 
rectangle *}\argument{AdditionalRect});

\type{void} \class{view}::\memberfunction{SetClippingRectSize}(\type{long} 
\argument{left}, \type{long} \argument{top},

						\type{long} \argument{width}, \type{long} \argument{height});

Sets an additional clip rectangle.  Drawing outside the rectangle including 
(\argument{left}, \argument{top}) in the upper left, and 
(\argument{left}+\argument{width}-1, \argument{top}+\argument{height}-1) in 
the lower right will be ignored.


\type{void} 
\class{view}::\memberfunction{SetClippingRegion}(\type{\class{region} 
*}\argument{Region});

Sets an additional clipping criterion.  Drawing outside of \argument{Region} 
will be ignored.


static \type{void} 
\class{view}::\staticmemberfunction{SetDefaultColors}(\type{char 
*}\argument{foreground}, \type{char *}\argument{background});

Sets the default \argument{foreground} and \argument{background} colors for 
views which haven't had any foreground or background color explicitly set.


\type{void} \class{view}::\memberfunction{SetFGColor}(\type{double} 
\argument{red}, \type{double} \argument{green}, \type{double} 
\argument{blue});

Sets the foreground color.  The \argument{red}, \argument{green}, and 
\argument{blue} real numbers are values  between 0.0 and 1.0 that describe 
the desired foreground color.


\type{void} \class{view}::\memberfunction{SetFgToShadow}(\type{int} 
\argument{shadow});

Sets the foreground color to the appropriate color for the given 
\argument{shadow} code.  The color selected is based on the current 
background color.  The available shadow codes are:

\constant{shadows_PRESSED} is for use in the background of the button while 
it is pressed.

\constant{shadows_TOPSHADOW} requests the color for the upper left of the 
shadow.

\constant{shadows_BOTTOMSHADOW} requests the color for the bottom right of 
the shadow.


\type{void} \class{view}::\memberfunction{SetFont}(\type{\class{fontdesc} 
*}\argument{Font});

Sets the current font for \memberfunction{DrawString} and 
\memberfunction{DrawText} operations.


\type{void} \class{view}::\memberfunction{SetForegroundColor}(\type{char 
*}\argument{colorName},

						\type{long} \argument{red},

						\type{long} \argument{green},

						\type{long} \argument{blue});

Sets the foregound color. If \argument{colorName} is \constant{NULL},  the 
\argument{red}, \argument{green}, and \argument{blue} values are used, 
otherwise \argument{colorName} is used to look up the RGB values.


\type{void} \class{view}::\memberfunction{SetLineCap}(\type{short} 
\argument{NewLineCap});

Sets the line cap style, which defines how the endpoints of a path are 
drawn (under X11). The \paramname{\argument{NewLineCap}} argument can be 
any of the following symbols:


\constant{graphic_CapButt} -- The line is square at the endpoint 
(perpendicular to the slope of the line) with no projection beyond.

\constant{graphic_CapNotLast} -- Same as graphic_CapButt, except for a line 
width of zero, the final endpoint is not drawn.

\constant{graphic_CapRound} -- The line has a circular arc with the 
diameter equal to the line width, centered on the endpoint.

\constant{graphic_CapProjecting} -- The line is square at the end, but the 
path continues beyond the endpoint for a distance equal to half the line 
width.


The default line cap is \constant{graphic_CapButt}.

 \


\type{void} \class{view}::\memberfunction{SetLineDashes}(\type{char 
*}\argument{dashPattern}, \type{int} \argument{dashOffset},

					\type{short} \argument{dashType});

Sets the current line dash style for line drawing (under X11). The 
\argument{dashPattern} argument is an array of characters whose integer 
values specify the pattern of on-off dashes desired. This array must be 
terminated with a 0 (zero) value. The \argument{dashOffset} argument 
defines the phase of the pattern, specifying how many pixels into the 
\argument{dashPattern} the pattern should actually begin on any single line 
drawing operation. The \argument{dashType} argument can be any of the 
following symbols:


\constant{graphic_LineSolid} -- Solid, non-dashed lines.

\constant{graphic_LineDoubleDash} -- Even and odd elements of the 
dashPattern are drawn in the foreground and background colors, respectively.

\constant{graphic_LineOnOffDash}\typewriter{ }-- Only the even elements of 
the \italic{dashPattern} are drawn.


A \constant{NULL} \paramname{\argument{dashPattern}} argument will set the 
graphic state to draw solid lines. Solid lines are drawn by default until 
\memberfunction{SetLineDashes} is called.


\type{void} \class{view}::\memberfunction{SetLineJoin}(\type{short} 
\argument{NewLineJoin});

Sets the line join style, which defines how corners are drawn for wide 
lines (under X11). The \argument{NewLineJoin} argument can be any of the 
following symbols:


\constant{graphic_JoinMiter} -- The outer edges of two lines extend to meet 
at an angle. If the angle is less than 11 degrees, then a 
\constant{graphic_JoinBevel} style join is used instead.

\constant{graphic_JoinRound} -- The corner is a circular arc with the 
diameter equal to the line width, centered on the joinpoint.

\constant{graphic_JoinBevel} -- The corner has \constant{graphic_CapButt} 
style endpoints, with the triangular notch filled.


The default line join is \constant{graphic_JoinMiter}.

 \


\type{void} \class{view}::\memberfunction{SetLineWidth}(\type{short} 
\argument{NewLineWidth});

Sets the line width to \argument{NewLineWidth} pixels. 
 (\argument{NewLineWidth} should be limited to the range 0 to 255.)

\type{void} \class{view}::\memberfunction{SetLogicalOrigin}(\type{long} 
\argument{NewX}, \type{long} \argument{NewY});

Sets the logical origin of the view to (\argument{NewX}, \argument{NewY}).


\type{void} \class{view}::\memberfunction{SetLogicalOriginPt}(\type{struct 
point *}\argument{Point});

Sets the logical origin of the view to \argument{Point}.


\type{void} \class{view}::\memberfunction{SetPatternOrigin}(\type{long} 
\argument{xpos}, \type{long} \argument{ypos});

Sets the origin for tile patterns used with fill operations to 
(\argument{xpos}, \argument{ypos}).  If filled regions have been blitted, 
this call can be used in conjunction with \memberfunction{GetPatternOrigin} 
by adding the delta x and delta y of the blit to the pattern origin.


\type{void} \class{view}::\memberfunction{SetSpaceShim}(\type{short} 
\argument{Space});

Sets the amount of \argument{Space} in pixels used to represent a space 
between words when using \memberfunction{DrawText} or 
\memberfunction{DrawString}.


\type{void} \class{view}::\memberfunction{SetTransferMode}(\type{short} 
\argument{NewTransferMode});

Sets the transfer mode for drawing.  The transfer mode specifies how each 
source element, S, and each destination element, D, should combine to 
produce the result.  The source and destination each have four elements, so 
there are sixteen possible ways to combine them. You can construct the 
transfer mode by forming boolean combinations from the graphic constants 
\constant{graphic_SOURCE} and \constant{graphic_DESTINATION} directly.  For 
convenience, the following common combinations have been defined as well: \



\constant{graphic_COPY}  --  The bit values are from the source

\constant{graphic_OR}  -- The bit values result from OR-ing the source and 
the destination

\constant{graphic_XOR}  -- The bit values result from an exclusive or of 
the source and the destination

\constant{graphic_AND}  -- The bit values result from an AND-ing the source 
and destination

\constant{graphic_WHITE}  -- The bit values are the foreground.

\constant{graphic_BLACK}  -- The bit values are the background.

\constant{graphic_INVERT}  -- The bit values are the opposite of the 
destination (if foreground, background; if background, foreground)


The default is \constant{graphic_COPY}. \



\type{void} \class{view}::\memberfunction{WriteImage}(\type{long} 
\argument{DestX}, \type{long} \argument{DestY},

				\type{\class{image} *}\argument{Image},

				\type{long} \argument{SrcX}, \type{long} \argument{SrcY},

				\type{long} \argument{width}, \type{long} \argument{height});

Copies a rectangular area (\argument{SrcX}, \argument{SrcY}, 
\argument{width}, \argument{height}) from the \argument{Image} (possibly 
full color) to the \classobject{view} at (\argument{DestX}, 
\argument{DestY}).

  \


\type{void} \class{view}::\memberfunction{WritePixImage}(\type{long} 
\argument{DestX}, \type{long} \argument{DestY},

				\type{\class{pixelimage} *Pix}\argument{Image},

				\type{long} \argument{SrcX}, \type{long} \argument{SrcY},

				\type{long} \argument{width}, \type{long} \argument{height});

Applies a rectangular area (\argument{SrcX}, \argument{SrcY}, 
\argument{width}, \argument{height}) from the \argument{PixImage} to the 
\classobject{view} at (\argument{DestX}, \argument{DestY}).  Pixels set in 
the source represent the current foreground color and pixels not set 
represent the current background color.  These values and the transfer mode 
determine the effect of applying the \classobject{pixelimage}.


\subsection{5.9.2	Updates}

\type{
void} \class{view}::\virtualmemberfunction{FullUpdate}(

	\type{enum view_UpdateType} \argument{type},

	\type{long} \argument{left},

	\type{long} \argument{top},

	\type{long} \argument{width},

	\type{long} \argument{right});

\type{void} \class{view}::\virtualmemberfunction{Update}();

\type{void} 
\class{view}::\virtualmemberfunction{WantUpdate}(\type{\class{view} 
*}\argument{requestor});

\type{void} 
\class{view}::\virtualmemberfunction{ObervedChanged}(\type{\class{observable\
} *}\argument{changed}, \type{long} \argument{changetype});

\type{void} 
\class{view}::\virtualmemberfunction{NotifyObservers}(\type{long} 
\argument{changetype});  \comment{// Called on the dataobject.

}
\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{PostCursor}(\type{\keyword{struct} 
rectangle *}\argument{rec},\type{\class{cursor} *}\argument{cursor}) ;

\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{RetractCursor}(\type{\class{cursor} 
*}\argument{cursor}) ;

\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{RetractViewCursors}(\type{\type{view} 
*}\argument{requestor});	\


These methods help maintain the visual image of the inset on screen and the 
placement of any cursors used.


\virtualmemberfunction{FullUpdate} is called whenever some or all of the 
\class{view} needs to be redrawn, when the \class{view} has been moved, or 
when it has been removed from the screen entirely.  The cases are 
distinguished by the\indent{ }\argument{type} parameter as follows:


\indent{\constant{view_FullRedraw} --  The \class{view} should be 
completely redrawn, any cursors should retracted and then reposted. The 
parameters \argument{left}, \argument{top}, \argument{width} and 
\argument{height} are ignored.


\constant{view_PartialRedraw}  --  The \class{view} should be redrawn 
within the rectangle specified by the parameters \argument{left}, 
\argument{top}, \argument{width}, and \argument{height}.   Further partial 
redraws will follow.  A \italic{\class{view}} receiving this call may defer 
the update until it receives the \constant{view_LastPartialRedraw}.


\constant{view_LastPartialRedraw}  --  The \class{view} should be redrawn 
within the rectangle specified by the parameters \argument{left}, 
\argument{top}, \argument{width}, and \argument{height}.  This is the last 
partial redraw.


\constant{view_MoveNoRedraw}  --  The redraw request is occurring because 
the \italic{\class{view}} is being moved.  If the \class{view} has posted 
cursors they should be rectracted and then reposted.  (So that they will be 
moved to the new location.)


\constant{view_Remove}  --  The redraw request is occurring because the 
\italic{\bold{view}} is being removed from the screen.   The \class{view} 
should retract all cursors that it has posted.  (Otherwise they will remain 
on screen.)}


\virtualmemberfunction{FullUpdate} should not have any side effects aside 
from drawing and posting cursors.  In particular 
\virtualmemberfunction{FullUpdate} must not call 
\virtualmemberfunction{WantInputFocus}, 
\virtualmemberfunction{PostKeyState}, nor \virtualmemberfunction{PostMenus}.


\virtualmemberfunction{Update} is called in response to a 
\virtualmemberfunction{WantUpdate} call.  In turn a 
\virtualmemberfunction{WantUpdate} call is usually made from the 
\class{view}'s \virtualmemberfunction{ObservedChanged} method,  its 
\virtualmemberfunction{Hit} method, or its 
\virtualmemberfunction{RecieveInputFocus}/\virtualmemberfunction{LoseInputFo\
cus} methods.  However, a \virtualmemberfunction{WantUpdate} call may be 
made anywhere at any time. When the underlying data in an inset is modified 
the code performing the modification will call 
\virtualmemberfunction{NotifyObservers} on the 
\indent{ }\class{dataobject}.  The \virtualmemberfunction{ObservedChanged} 
method in the \classobject{view} will then call 
\virtualmemberfunction{WantUpdate} if the change is something which should 
be reflected on screen.  When a \classobject{view} wants to provide 
feedback during an on-going mouse operation, it should do that by updating 
information in the \classobject{view} and calling 
\virtualmemberfunction{WantUpdate}.


The simplest implementation of \virtualmemberfunction{Update} is:


\type{void} \class{testview}::\virtualmemberfunction{Update}() \{

	\virtualmemberfunction{FullUpdate}(\constant{view_FullRedraw}, 0, 0, 0, 0);

\}


This can be highly inefficient of course, since it just causes the whole 
inset to be redraw from scratch.  It is better for 
\virtualmemberfunction{Update} to use information about the previous state 
of the view and the desired state to perform only those operations which 
are required to update the visual image and any cursors used.


\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{PostCursor}(\type{\keyword{struct} 
rectangle *}\argument{rec},\type{\class{cursor} *}\argument{cursor});

Posts a \argument{cursor} over the area of the view indicated by 
\argument{rec}.


\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{RetractCursor}(\type{\class{cursor} 
*}\argument{cursor});

Retracts the indicated \argument{cursor}.


\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{RetractViewCursors}(\type{\type{view} 
*}\argument{requestor});

Retracts all cursors posted by the \argument{requestor}.


\section{5.10	Keyboard and Menu Input

}
\type{void} \class{bind}::BindList(\type{\keyword{struct} bind_Description 
*}\argument{bl}, \type{\class{keymap} *}\argument{km}, 
\type{\class{menulist} *}\argument{ml},\type{ \keyword{struct} 
ATKregistryEntry  *}\argument{type});

\type{void} 
\class{view}::\virtualmemberfunction{PostKeyState}(\type{\class{keystate} 
*}\argument{ks});

\type{void} 
\class{view}::\virtualmemberfunction{PostMenus}(\type{\class{menulist} 
*}\argument{ml});

\type{void} 
\class{view}::\virtualmemberfunction{WantInputFocus}(\type{\class{view} 
*}\argument{requestor});

\type{\class{view} *}\class{view}::Hit (\type{\keyword{enum} 
view_MouseAction} \argument{action}, \keyword{\type{long}} \argument{x}, 
\keyword{\type{long}} \argument{y}, \keyword{\type{long}} 
\argument{numberOfClicks});

\type{void} \class{view}::\virtualmemberfunction{ReceiveInputFocus}();

\type{void} \class{view}::\virtualmemberfunction{LoseInputFocus}();

\type{boolean} \class{view}::\virtualmemberfunction{AcceptingFocus}();

\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{Traverse}(\type{\keyword{enum} 
view_Traversal} \argument{trav});

(\virtualmemberfunction{Traverse} is not implemented anywhere yet.)


A new mechanism has recently been implemented for writing the functions to 
interface an inset to keyboard and menu input.  However, nearly all 
existing code still uses the old method, so that method will be covered 
here.


The classes involved in keyboard and menu input include \class{view}, 
\class{proctable}, \class{keymap}, \class{keystate}, \class{menulist} and 
\class{bind}.  To use these classes each of their .H files should be 
included:  \


\indent{\filename{proctable.H

keymap.H

menulist.H

bind.H}}


(\filename{view.H} will presumably be included via the .H file for the 
class being implemented.)


The bind class provides a convenient way to list all the key and menu 
bindings in one place and initialize \class{keymap} and \class{menulist} 
objects from that list.  The listing is kept in the form of arrays of 
\type{struct bind_Description}.  The elements of that struct are:


\type{char *}\datamember{procName};

\bold{User invocation name}.  In addition to allowing users to invoke a 
procedure by typing the sequence of keys it is bound to, like other 
applications ATK allows users to invoke a procedure by its name.  For 
example in EMACS the user can save the current file by typing 
\italic{Ctrl-x Ctrl-s} or by typing \italic{ESC-X write-current-file.} The 
user invocation name is the name the user types to invoke the procedure, 
for example, \italic{write-current-file}.  Unlike EMACS, under ATK the name 
should begin with the name of the \class{view} to avoid collisions among 
dynamically loaded objects.


\type{char *}\datamember{keyVector};

\bold{Key sequence.}  This is the \smaller{ASCII} string representation for 
the sequence of keys that the user will type to invoke the function.  For 
example, Ctrl-x Ctrl-s would be represented as \italic{" \\030\\023"}. \



\type{long} \datamember{keyRock};

\bold{Key data.}  The data, if any, that should be passed to the procedure 
when the user invokes the procedure through the key sequence.  In this 
case, the data is a "rock," or constant value.   Although the type is a 
long, traditionally this is either a character, or a pointer.  (In the 
latter case a cast is required of course.)


\type{char *}\datamember{menuEntry};

\bold{Menu entry.}  The menu, if any, that will invoke the procedure. \



\type{long} \datamember{menuRock};

\bold{Menu data.}  The data, if any, that should be passed to the procedure 
when the user invokes the procedure through the menu item.  In this case, 
the data is a "rock," or constant value. (Just like the key data.)


\type{long} \datamember{menuMask};

\bold{Menu mask.}  The mask, if any, that controls the circumstances under 
which the menu item will appear.  For example, EZ uses menu masks to 
control the menus that appear when a region is selected and when there is 
no selected region.  It should be 0 unless you want to use them. \



\type{proctable_fptr} \datamember{proc};

\bold{Procedure.}  A pointer to the procedure.  If the procedure is not 
given, the module name must be given.  (See \datamember{module} below.) 
 The named module should supply the procedure.  For example, EZ invokes the 
spelling module without supplying a pointer to the procedure and the 
spelling module supplies it.  The procedure should take two arguments, an 
 \type{\class{ATK} *} and a \type{long}, and it should return a long.  Most 
procedures will need to cast the two arguments to more useful types.


\type{char} *\datamember{doc};

\bold{Brief documentation.}  A string that gives a brief description of the 
procedure (something suitable for a command-line description \italic{a la} 
 \smaller{EMACS} \italic{apropos}).  For example, 
\italic{write-current-file} might have the description "Saves current 
file." \



\type{char} *\datamember{module};

\bold{Module name.}  The name of the module in which the procedure can be 
found.   This module will be loaded automatically the first time the 
binding is invoked.


An Example

In \bold{helloworldview.C} we find two key bindings for the class 
\italic{\bold{helloworldview}} are described by the array, 
\bold{helloworldviewBindings}:


\example{static \type{struct bind_Description} 
\filescopevariable{helloworldviewBindings}[]=\{

	\{"helloworldview-center", /* Invocation name */

		"\\003",	/* Cntrl-c */

		0,		/* Data passed to Center */

		NULL,		/* Menu entry */

		0,		/* Menu data */

		0,		/* Menu masks */

		\filescopefunction{Center},	/* Procedure to call */

		"Center helloworld string."\}, /* Brief description */

	\{"helloworldview-invert", /* Innocation name */

		"\\011",	/* Cntrl-i */

		0,		/* Data passed to Invert */

		"HelloWorld,Invert",		/* Menu entry */

		0,		/* Menu data */

		0,		/* Menu masks */

		\filescopefunction{Invert},	/* Procedure to call */

		"Invert the string."\}, /* Brief description */

	\constant{NULL}			/* End of array */

\};}


\filescopefunction{Center} and \filescopefunction{Invert} would be defined 
previously in helloworldview.C with the signature:


static \type{long }\filescopefunction{Func}(\type{\class{ATK} 
*}\argument{obj}, \type{long} \argument{rock});


Whenever the user chooses the appropriate menu item or types the 
appropriate key sequence \filescopefunction{Func} will be called with a 
pointer to the appropriate object and the rock specified in the 
\type{bind_Description}.


Once an array of \type{bind_Description} objects has been created the next 
step is to use it to initialize a \classobject{keymap} and 
\classobject{menulist}.  The usual method is to start by creating one 
\classobject{keymap} and one \classobject{menulist} per class.  These 
objects or pointers to them may be static class member variables, or simply 
global or file scope variables.  (In the case of global variables they 
should be uniquely named, e.g. with a classname_ prefix.)  For example 
where the class \class{helloworldview} has an 
\staticmemberfunction{InitializeClass} member:


\example{static \type{\class{keymap} *}\filescopevariable{classkeymap};

static \type{\class{menulist} *}\filescopevariable{classmenulist};


\type{boolean} 
\class{helloworldview}::\staticmemberfunction{InitializeClass}() \{

	// ...

	\filescopevariable{classkeymap}=new \class{keymap};

	\filescopevariable{classmenulist}=new \class{menulist};

	bind::BindList(\filescopevariable{helloworldviewBindings}, 
\filescopevariable{classkeymap}, \filescopevariable{classmenulist}, 
&\globalvariable{helloworldview_ATKregistry_});

	// ...

\}

}If the class has no \staticmemberfunction{InitializeClass} member other 
arrangements should be made to initialize these objects once.


The next step is to create the \classobject{keystate} and 
\classobject{menulist} objects for each instance of the class.  Here the 
instance members \datamember{mykeystate} and \datamember{mymenulist} of the 
\class{helloworldviewclass} are initialized in the constructor:\indent{

}\example{\constructor{helloworldview::helloworldview}() \{

	// ...


	\datamember{mykeystate}=\class{keystate}::\staticmemberfunction{Create}(thi\
s, \filescopevariable{classkeymap});

	\datamember{mymenulist}=\filescopevariable{classmenulist}->\
\virtualmemberfunction{DuplicateML}(this);

	// ...

\}}

\indent{
}\example{\destructor{helloworldview::~helloworldview}() \{

	// ...

	delete \datamember{mykeystate};

	delete \datamember{mymenulist};

	// ...

\}}\indent{

}
To actually make these bindings available when the \classobject{view} has 
the input focus \virtualmemberfunction{PostKeyState} and 
\virtualmemberfunction{PostMenus} must be overridden.  For example:


\example{void 
\class{helloworldview}::\virtualmemberfunction{PostKeyState}(\type{\class{ke\
ystate} *}\argument{ks}) \{

	ks->next=NULL;

	// The above is needed to

	// dissociate this keystate

	// from any other keystates

	// it may have been used with

	// previously.

	keystate 
*\localvariable{result}=\datamember{mykeystate}->\virtualmemberfunction{AddA\
fter}(\argument{ks});

	\class{view}::\virtualmemberfunction{PostKeyState}(\localvariable{result});

\}


void 
\class{helloworldview}::\virtualmemberfunction{PostMenus}(\type{\class{menul\
ist} *}\argument{ml}) \{

	mymenulist->ClearChain();

	// The above is needed to

	// dissociate this menulist

	// from any other menulists

	// it may have been used with

	// previously.

	if(\localvariable{ml}) 
\datamember{mymenulist}->\virtualmemberfunction{ChainAfterML}(\argument{ml},\
 0);

	\class{view}::\virtualmemberfunction{PostMenus}(\datamember{mymenulist});

\}}


Note that either or both of \argument{ks} and \argument{ml} may be 
\constant{NULL}, in which case \virtualmemberfunction{PostKeyState} and/or 
\virtualmemberfunction{PostMenus} should post the class's own keybindings 
and/or menus only.


The use of \virtualmemberfunction{AddAfter} and 
\virtualmemberfunction{ChainAfterML} indicate that any menus or keybindings 
posted by children of a \classobject{helloworldview} will be overridden by 
any conflicting bindings in the \classobject{keystates} and 
\classobject{menulists} for the \classobject{helloworldview}.  If the child 
\classobject{view}'s bindings should take precedence 
\virtualmemberfunction{AddBefore} and \virtualmemberfunction{ChainBefore} 
should be used instead.


If \class{helloworldview} is not derived directly from \class{view}, then 
the base class should be used in place of \class{view} in the calls to 
\virtualmemberfunction{PostKeyState} and \virtualmemberfunction{PostMenus} 
in the example above.


Now everything is in place so that once a \classobject{helloworldview} has 
the input focus its bindings will be made available.  To acquire the 
 input focus a view must call \virtualmemberfunction{WantInputFocus}. 
 \virtualmemberfunction{WantInputFocus} must only be called in response to 
a user's action.  For example, a click in the view should usually trigger a 
\virtualmemberfunction{WantInputFocus} call:


\example{\type{\class{view} *}\class{helloworldview}::Hit 
(\type{\keyword{enum} view_MouseAction} \argument{action}, 
\keyword{\type{long}} \argument{x}, \keyword{\type{long}} \argument{y}, 
\keyword{\type{long}} \argument{numberOfClicks}) \{

	// ...

	switch(action) \{

		// ...

		case view_LeftDown:

		case view_RightDown:

		// ...

		WantInputFocus();

		//...

		break;

		//...

	\}

\}}


Now \class{helloworldview} is completely capable of responding to menu and 
key bindings.  \



Views which accept keyboard and menu input should give some visual 
indication of when they have the input focus.  To achieve this they should 
override \virtualmemberfunction{ReceiveInputFocus} and 
\virtualmemberfunction{LoseInputFocus}, for example:


\example{\type{void} 
\class{helloworldview}::\virtualmemberfunction{ReceiveInputFocus}() \{

	\class{view}::\virtualmemberfunction{ReceiveInputFocus}();

	if(!\datamember{havefocus}) \{

		\datamember{havefocus}=\constant{TRUE};

		\virtualmemberfunction{WantUpdate}(this);

	\}

\}


\type{void} 
\class{helloworldview}::\virtualmemberfunction{LoseInputFocus}() \{

	\class{view}::\virtualmemberfunction{LoseInputFocus}();

	if(\datamember{havefocus}) \{

		\datamember{havefocus}=FALSE;

		\virtualmemberfunction{WantUpdate}(this);

	\}

\}}


As with \virtualmemberfunction{PostMenus} and 
\virtualmemberfunction{PostKeyState}, the actual base class should be used 
in place of \class{view} in the calls to 
\virtualmemberfunction{ReceiveInputFocus} and 
\virtualmemberfunction{LoseInputFocus} above.  In this example 
\datamember{havefocus} tracks whether the \classobject{helloworldview} has 
the input focus, and screen updates are requested whenever 
\datamember{havefocus} changes.


Views which don't accept the input focus should override 
\virtualmemberfunction{AcceptingFocus} and simply return \constant{FALSE}.


\section{5.11	Change Notification}


\type{void} 
\class{observable}::\virtualmemberfunction{NotifyObservers}(\type{long} 
\argument{change});

\type{void} 
\class{observable}::\virtualmemberfunction{ObservedChanged}(\type{\class{obs\
ervable} *}\argument{changed}, \type{long} \argument{change});

\type{void} 
\class{observable}::\virtualmemberfunction{AddObserver}(\type{\class{observa\
ble} *}\argument{observer});

\type{void} 
\class{observable}::\virtualmemberfunction{RemoveObserver}(\type{\class{obse\
rvable} *}\argument{observer});


The \virtualmemberfunction{NotifyObservers} protocol allows objects to 
communicate when changes have taken place and the nature of those changes. 
 \virtualmemberfunction{AddObserver} is called to add an 
\classobject{observable} to be notified of any changes in the object. 
 \virtualmemberfunction{RemoveObserver} naturally removes an 
\classobject{observable} from the list of \classobject{observables} to be 
notified of changes in the object.  When 
\virtualmemberfunction{NotifyObservers} is called it calls the 
\virtualmemberfunction{ObservedChanged} methods on all the observers of the 
object, passing a pointer to the changed \classobject{observable}, and the 
long \argument{change} describing the nature of the change. 
 ObservedChanged should ignore values of \argument{change} which it doesn't 
recognize.


Just before an \classobject{observable} object is destroyed, 
\virtualmemberfunction{NotifyObservers} is called with 
\constant{observable_OBJECTDESTROYED}.


Most other uses of \virtualmemberfunction{NotifyObservers} use 
\constant{observable_OBJECTCHANGED} (which is 0), but they can use any 
value for \argument{change} except -1 (which corresponds to 
\constant{observable_OBJECTDESTROYED}).  \



The \class{view} and \class{dataobject} classes use the 
\virtualmemberfunction{NotifyObservers} protocol to signal for screen 
updates when a \classobject{dataobject} is modified.  When a 
\classobject{dataobject} is modified the code performing the modification 
should usually call SetModified, and then call 
\virtualmemberfunction{NotifyObservers} with 
\constant{observable_OBJECTCHANGED}, or another appropriate value as 
understood by the observer's \virtualmemberfunction{ObservedChanged} 
method. The default \virtualmemberfunction{ObservedChanged} method in view 
will call \virtualmemberfunction{WantUpdate} if the value passed to 
\virtualmemberfunction{NotifyObservers} was not 
\constant{observable_OBJECTDESTROYED}. Multiple modifications may be made 
between calls to  \virtualmemberfunction{SetModified} and 
\virtualmemberfunction{NotifyObservers} but the calls should be made before 
control returns to the user.


\section{5.12	Scrolling}


\type{\class{ScrollInterface} 
*}\class{view}::\virtualmemberfunction{GetScrollInterface}();

Returns the \classobject{ScrollInterface} object recommended by the 
\class{view}'s author.

\paragraph{
}\bold{5.12.1	}\bold{Header Files

}
scrolling.H:	for ScrollInterface, ScrollRegion and associated declarations.

scroll.H: 		for scroll and associated declarations.


\bold{5.12.2	The Scroll Class

}
static \type{\class{scroll} 
*}\class{scroll}::\staticmemberfunction{Create}(\type{\class{view} 
*}\argument{view}, \type{int} \argument{location});

stati\keyword{c} \type{\class{scroll} 
*}\class{scroll}::\staticmemberfunction{CreateScroller}(\type{\class{ScrollI\
nterface} *}s, \type{\class{view} *\argument{view}}, \type{int} 
\argument{location}, \type{\keyword{char} 
*}\argument{scrollClass}=\constant{NULL});

\keyword{static} \type{\class{scroll} 
*}\class{scroll}::\staticmemberfunction{CreateScroller}(\type{\class{view} 
*\argument{view}}, \type{int} \argument{location}, 
\argument{\type{\keyword{char} *}scrollClass}=\constant{NULL});

\keyword{static} \type{\class{scroll} 
*}\class{scroll}::\staticmemberfunction{CreateCustomScroller}(\type{\class{v\
iew} *\argument{view}}, \type{int} \argument{location}, 
\argument{\type{\keyword{char} *}scrollClass}=\constant{NULL});


These are the functions which should be used to create a new scrollbar, 
panner, or scrollbar+panner for a given \argument{view}.  The 
\argument{location} argument is a bit-wise 'or' of the constants 
\constant{scroll_LEFT}, \constant{scroll_RIGHT}, \constant{scroll_TOP}, and 
\constant{scroll_BOTTOM}.  The Create function creates a scroll object for 
the \classobject{view} with the \classobject{view}'s default 
\class{ScrollInterface}.  The \argument{scrollClass} argument to the 
\staticmemberfunction{CreateScroller} methods and the 
\staticmemberfunction{CreateCustomScroller} method indicates the name of a 
derived class of scroll which will provide the scrolling user interface, 
the \type{\class{scroll} *} returned will actually point to an object of 
the named class.  Currently \class{scroll}, \class{panner}, and 
\class{scpanner} are available. \class{oscroll} is the old, obsolete 
scrolling class.  The 
\staticmemberfunction{CreateScroller}(\type{\class{ScrollInterface} 
*}\argument{s},\type{\class{view} *},\type{int},\type{char *}) method 
creates a scroller using the \class{ScrollInterface} \argument{s}.  A 
\class{ScrollInterface} class is a class derived from 
\class{ScrollInterface} which implements scrolling for a particular derived 
class of \class{view}.  \class{ScrollInterfaces} will be described in 
detail later in this document.  \staticmemberfunction{CreateCustomScroller} 
creates a scroller just like \staticmemberfunction{CreateScroller}, except 
that no \classobject{ScrollInterface} is installed, and 
\classobject{ScrollRegions} for the dot, elevator and endzone regions of 
the scrollbar are not installed.  The \staticmemberfunction{ScrollRegions} 
and the \class{ScrollInterface} must be set before the scrollbar can be 
used.


\keyword{\type{void}} 
\class{scroll}::\virtualmemberfunction{SetLocation}(\keyword{\type{int}} 
\argument{location});

Sets which scrolling axes are desired and where the components controlling 
them should be placed.  The possibilities are:


\constant{scroll_LEFT}

\constant{scroll_RIGHT}

\constant{scroll_LEFT}|\constant{scroll_TOP}

\constant{scroll_LEFT}|\constant{scroll_BOTTOM}

\constant{scroll_RIGHT}|\constant{scroll_TOP}

\constant{scroll_RIGHT}|\constant{scroll_BOTTOM}


\keyword{\type{int}} \class{scroll}::\virtualmemberfunction{GetLocation}();

Returns a bitmask indicating which scrolling axes are desired and where the 
components controlling them should be placed.


\keyword{\type{int}} 
\class{scroll}::\virtualmemberfunction{GetCurrentLocation}();

Returns a bitmask indicating which scrolling axes are currently in use and 
where the components controlling them are placed.


 \keyword{\type{void}} 
\class{scroll}::\virtualmemberfunction{SetParameters}(\keyword{\type{long}} 
\argument{endzone}, \keyword{\type{long}} \argument{bar}, 
\keyword{\type{int}} \argument{without}, \keyword{\type{int}} 
\argument{with});

 \keyword{\type{void}} 
\class{scroll}::\virtualmemberfunction{GetParameters}\type{(\keyword{long} 
*}\argument{endzone}, \type{\keyword{long} *}\argument{bar}, 
\type{\keyword{int} *}\argument{without}, \type{\keyword{int} 
*}\argument{with});

\leftindent{\argument{endzone}: The minimum number of pixels the scrollbar 
must have to display the endzones.

\argument{bar}: The minimum number of pixles to try to put a scrollbar in.

\argument{without}: The minimum size for the elevator given that the 
scrollbar is currently without endzones.

\argument{with}: The minimum size of the elevator when the scrollbar is 
displayed with endzones.

}
\keyword{\type{void}} 
\class{scroll}::\virtualmemberfunction{SetWidth}(\keyword{\type{long}} 
\argument{newWidth});

Sets the width of the scrollbar in pixels.


\keyword{\type{long}} \class{scroll}::\virtualmemberfunction{GetWidth}();

Returns the width of the scrollbar in pixels.


\keyword{\type{void}} 
\class{scroll}::\virtualmemberfunction{SetDotWidth}(\keyword{\type{long}} 
\argument{newWidth});

Sets the width of the dot in pixels.


\keyword{\type{long}} \class{scroll}::\virtualmemberfunction{GetDotWidth}();

Returns the width of the dot in pixels.


\keyword{\type{void}} 
\class{scroll}::\virtualmemberfunction{SetEndZoneLength}(\keyword{\type{long\
}} \argument{newHeight});

Sets the number of pixels (in the axis of the scrollbar) used for the 
endzone.


\keyword{\type{long}} 
\class{scroll}::\virtualmemberfunction{GetEndZoneLength}();

Returns the number of pixels (in the axis of the scrollbar) used for the 
endzone.


\keyword{\type{void}} 
\class{scroll}::\virtualmemberfunction{SetEndToBarSpace}(\keyword{\type{long\
}} \argument{space});

Sets the number of pixels between the endzones and the scrollbar.


\keyword{\type{long}} 
\class{scroll}::\virtualmemberfunction{GetEndToBarSpace}();

Returns the number of pixels between the endzones and the scrollbar.


\keyword{\type{void}} 
\class{scroll}::\virtualmemberfunction{SetView}(\type{\class{view} 
*}\argument{view});

Sets the child \classobject{view} and the scrollee to \argument{view}.  See 
\virtualmemberfunction{SetChild} and \virtualmemberfunction{SetView} below.


\keyword{\type{void}} 
\class{scroll}::\virtualmemberfunction{SetChild}(\type{\class{view} 
*}\argument{child});

Sets the \argument{child} view to be displayed within the box next to the 
scrollbar.  Normally this is called by \virtualmemberfunction{SetView}.


\keyword{\type{void}} 
\class{scroll}::\virtualmemberfunction{SetScrollee}(\type{\class{view} 
*}\argument{scrollee});

Sets the view (\argument{scrollee}) to be scrolled.   Normally this is 
called by \virtualmemberfunction{SetView}.


\type{\class{view} *}\class{scroll}::\virtualmemberfunction{GetChild}();

Returns the \classobject{view} being displayed by the scroll object.


\type{\class{view} *}\class{scroll}::\virtualmemberfunction{GetScrollee}();

Returns the \classobject{view} being scrolled by the scroll object.


\keyword{\type{void}} 
\class{scroll}::\virtualmemberfunction{SetElevatorWidth}(\keyword{\type{long\
}} \argument{newWidth});

Sets the width of the elevator within the scrollbar.


\keyword{\type{long}} 
\class{scroll}::\virtualmemberfunction{GetElevatorWidth}();

Returns the width of the elevator within the scrollbar;

\keyword{\type{void}} 
\class{scroll}::\virtualmemberfunction{SetWindowPadding}(\keyword{\type{long\
}} \argument{newPadding});

Sets the number of pixels worth of padding between the sides of the scroll 
view and the area where the scrollbars and the view are drawn.


\keyword{\type{long}} 
\class{scroll}::\virtualmemberfunction{GetWindowPadding}();

Returns the number of pixels worth of padding between the sides of the 
scroll view and the area where the scrollbars and the view are drawn.


\keyword{\type{void}} 
\class{scroll}::\virtualmemberfunction{SetViewPadding}(\keyword{\type{long}} 
\argument{newPadding});

Sets the number of pixels worth of padding around the child view the scroll 
object is displaying.


\keyword{\type{long}} 
\class{scroll}::\virtualmemberfunction{GetViewPadding}();

Returns the number of pixels worth of padding around the child view the 
scroll object is displaying.


\type{void} 
\class{scroll}::\memberfunction{SetInterface}(\type{\class{ScrollInterface} 
*}\argument{si});

Sets the \classobject{ScrollInterface} object to be used for scrolling the 
scrollee.  The \classobject{ScrollInterface} object is owned by the 
\classobject{scroll} object, it should not be destroyed by any other code 
and must be allocated with new.


ScrollInterface *\class{scroll}::\memberfunction{Interface}();

Returns the \classobject{ScrollInterface} object being used to scroll the 
scrollee.


\type{void} \class{scroll}::\memberfunction{SetRegion}(\type{enum 
scroll_Regions} \argument{sr}, \type{\class{ScrollRegion} *}\argument{r});

Sets the \classobject{ScrollRegion} object (\argument{r}) used to represent 
the indicated region (\argument{sr}).  The regions are:

\constant{scroll_Elevator}

\constant{scroll_Dot}

\constant{scroll_LeftEnd}

\constant{scroll_RightEnd}

\constant{scroll_UpperEnd}

\constant{scroll_BottomEnd}

See the section below about \class{ScrollInterfaces} and 
\class{ScrollRegions}.


ScrollRegion *\class{scroll}::\memberfunction{Region}(\type{enum 
scroll_Regions} \argument{sr});

Returns the \classobject{ScrollRegion} object being used for the indicated 
region.


\type{void} 
\class{scroll}::\memberfunction{SetCustomInterface}(\type{\class{ScrollInter\
face} *}\argument{s});

Sets the \classobject{ScrollInterface} object to be used for scrolling the 
scrollee.  The caller retains ownership of the \classobject{ScrollInteface} 
and should free it once the \classobject{scroll} object is destroyed or no 
longer used.

\type{void} \memberfunction{SetStandardRegions}(\type{int} 
\argument{location});

Installs the standard \classobject{ScrollRegion} objects for a given 
\argument{location} given as a bitmask as described above.


\bold{5.12.3	The ScrollInterface Class}


The \class{ScrollInterface} class provides the common abstraction used to 
scroll any view.  There should be a derived class of \class{ScrollInterface} 
for any class which wishes to provide its own scrolling.


\type{void} 
\class{ScrollInterface}::\virtualmemberfunction{Absolute}(\type{long} 
\argument{totalx}, \type{long} \argument{x}, \type{long} \argument{totaly}, 
\type{long} \argument{y});

Positions the view it controls so that the coordinate 
(x*client_width/totalx,y*client_height/totaly) in the otal space of the 
view is in the upper left corner of its on-screen area.  If totalx or 
totaly is zero that axis must be ignored, but any scrolling indicated for 
the other axis should be performed.


\type{void} 
\class{ScrollInterface}::\virtualmemberfunction{ScreenDelta}(\type{long} 
\argument{dx}, \type{long} \argument{dy});

Positions the view it controls so that the data which was at (dx,dy) 
on-screen (logically) to be shifted to (0,0).  Negative values of dx and dy 
indicate scrolling the appropriate amounts of data on-screen.


\type{void} 
\class{ScrollInterface}::\virtualmemberfunction{Shift}(\type{scroll_Directio\
n} \argument{direction});

Shifts the view so that one new unit is displayed in the indicated 
direction.  The directions are:


\constant{scroll_Up}

\constant{scroll_Down}

\constant{scroll_Right}

\constant{scroll_Left}


for example, \constant{scroll_Up} on a \classobject{textview} would back up 
one line to display the line before the top line in the 
\classobject{textview}.


\type{void} 
\class{ScrollInterface}::\virtualmemberfunction{Extreme}(\type{scroll_Direct\
ion} \argument{direction});

Shifts the view so that the far end of the data in the indicated direction 
is displayed.  For example, in textview scroll_Up would show the beginning 
of the document.


\type{void} 
\class{ScrollInterface}::\virtualmemberfunction{UpdateRegions}(\class{scroll\
} &\argument{scrollerview});

The \classobject{ScrollRegion} objects installed in the 
\argument{scrollerview} object should be updated for the current status of 
the \classobject{view} being scrolled.  This usually involves calling 
\virtualmemberfunction{SetRanges} on the \constant{scroll_Dot} and 
\constant{scroll_Elevator} \classobject{ScrollRegion} objects.


\bold{5.12.4}	The \class{ScrollRegion}, \class{ScrollRegionDot}, 
\class{ScrollRegionElevator}, and \class{ScrollRegionEndzone} Classes


A \classobject{ScrollRegion} is any one of three active components in a 
scrollbar.  The dot, the elevator, or an endzone.  Normally only 
\class{ScrollRegionDot} and \class{ScrollRegionElevator} are used directly, 
and then all that is needed is calls to

\example{ 
\argument{scrollerview}.\memberfunction{Region}(\constant{scroll_Elevator})-\
>\virtualmemberfunction{SetRanges}(xrange, xstart, xend, yrange, ystart, 
yend);


// and/or

\argument{scrollerview}.\memberfunction{Region}(\constant{scroll_Dot})->\
\virtualmemberfunction{SetRanges}(xrange, xstart, xend, yrange, ystart, 
yend);

}
 in the \virtualmemberfunction{UpdateRegions} method of a 
\class{ScrollInterface} derived class  to set the values based on the state 
of the \classobject{view} being scrolled.


In the future this document should be extended to cover deriving new 
\class{ScrollRegion} classes.


\section{5.13	Size & Placment Negotiation}


\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{GetOrigin}(\keyword{\type{long}} 
\argument{width}, \keyword{\type{long}} \argument{height}, 
\keyword{\type{long}} *\argument{originX}, \keyword{long} 
*\argument{originY});

\type{void} 
\class{view}::\virtualmemberfunction{DesiredSize}(\keyword{\type{long}} 
\argument{width}, \keyword{\type{long}} \argument{height}, 
\type{\keyword{enum} view_DSpass} \argument{pass}, \type{\keyword{long} 
*}\argument{dWidth}, \type{\keyword{long} *}\globalvariable{dheight});

\type{void} 
\class{view}::\virtualmemberfunction{WantNewSize}(\type{\class{view} 
*}\argument{requestor});

The 
\virtualmemberfunction{WantNewSize},\virtualmemberfunction{DesiredSize}, 
and \virtualmemberfunction{GetOrigin} methods implement the protocols by 
which a substrate and its children negotiate the space to be allocated to 
the child, and where the child should be relative to some base-line.  (esp. 
in text.)  \



\virtualmemberfunction{GetOrigin} is called on a child by a susbtrate which 
plans to include its child in a horizontal or vertical list with text 
and/or with other insets.  The purpose is to allow the child to request 
that it be displayed above/below, left/right of the baseline (as defined 
bby the substrate).  For example to place the label of a 
\begindata{sbutton,538505768}
Datastream version: 10
1 1 1 Rows 1
\newprefs

\style
4
\font
andysans16b
\topshadow
#bd9978
\top
#ab753c
\bottomshadow
#a16018
\name
Default
\endprefs

\label
sbutton
\litp
False
\sensitive
True
\prefs
0
\done

\enddata{sbutton,538505768}
\view{sbttnav,538505768,6,0,0} in line with the text surrounding it the 
\virtualmemberfunction{GetOrigin} method in \class{sbuttonv} uses 
information about the font it is using and the borders it will draw to set 
*\argument{originY} so that the text within the button lines up with the 
text outside.


\virtualmemberfunction{DesiredSize} is called on a child by a substrate to 
inquire as to the screen space needed by the child.   The \argument{width} 
and \argument{height} parameters indicate the parent's preference. 
 Typically the parent doesn't care and just passes in maximum values.  The 
\argument{pass} argument indicates which of \argument{width} and 
\argument{height} are fixed by the parent and which are flexible.  The 
possible values for pass are \constant{view_NOSET} (meaning both width and 
height are flexible), \constant{view_WIDTHSET}, \constant{view_HEIGHTSET}. 
 The *\argument{desiredWidth} and *\argument{desiredHeight} arguments must 
be filled in with the child's desired size.  The return value is the 
bit-wise 'or' of the following values:

\indent{
\constant{view_FIXED				}The size is fixed, that is, not flexible.


\constant{view_WIDTHSMALLER		}The width could be made smaller.


\constant{view_WIDTHLARGER		}The width could be made larger.


\constant{view_WIDTHFLEXIBLE}		The width is flexible.


\constant{view_HEIGHTSMALLER	}The height could be made smaller.


\constant{view_HEIGHTLARGER		}The height could be made larger.


\constant{view_HEIGHTFLEXIBLE	}The height is flexible.

}
\virtualmemberfunction{WantNewSize} is called by a child view when it needs 
a new size.  Perhaps because it has more data to display, or because its 
font size or other parameters have changed.  The call 
\virtualmemberfunction{WantNewSize}(\argument{this}) in a member function 
is the typical means of invoking it.  This call will let the substrate know 
the child wants a new size, if the substrate might allow a change it will 
call the child's \virtualmemberfunction{GetDesiredSize} and possibly 
\virtualmemberfunction{GetOrigin} methods to discover what size and 
position are desired.


\section{5.14	Substrates}


A substrate is a view designed to display and manage one or more views 
within itself.  \



A substrate is responsible for connecting its children to the view tree 
(and thus the actual display device), and passing along various requests 
such as FullUpdates, or WantExposures, or recursive searches.


\type{void} \class{view}::\virtualmemberfunction{FullUpdate}(

	\type{enum view_UpdateType} \argument{type},

	\type{long} \argument{left},

	\type{long} \argument{top},

	\type{long} \argument{width},

	\type{long} \argument{right});


Based on the type parameter the FullUpdate method of a substrate has a few 
additional responsibilities.  First, if the type is one of the redraw types 
any children which are to be visible must be linked into the view tree and 
allocated space in the parent.  For example if child is a member of 
testview:


\example{void testview::FullUpdate(\type{

	enum view_UpdateType} \argument{type},

	\type{long} \argument{left},

	\type{long} \argument{top},

	\type{long} \argument{width},

	\type{long} \argument{right}) \{

// ...

if(child->GetIM()!=GetIM() && (type==view_FullRedraw || 
type==view_PartialRedraw || type=view_LastPartialRedraw)) \{

	// Link it into the view tree.  This may also

	// be done in the parent's LinkTree method.

	child->LinkTree(this);


\}

if(/* child's area has changed */ TRUE) \{

	// Just force it into the upper left 50x50 area.

	// If the view is to be moved to another area

	// within the parent, just call InsertView again

	// within Update, or FullUpdate before calling

	// the child's FullUpdate.

	child->InsertView(this, 0, 0, 50, 50);	\


\}

// ...}


On the basis of the type parameter the remaining responsibilities are:

\example{
// all of the following fragments are typically under a switch(type)

}
\indent{\constant{view_FullRedraw} --  The FullUpdate method of any visible 
children should be called with a view_UpdateType of view_FullRedraw or 
view_LastPartialRedraw.  E.g.:


\example{case view_FullRedraw:}

\example{child->FullUpdate(view_FullRedraw, 0, 0, 0, 0);


// or


child->FullUpdate(view_LastPartialRedraw, 0, 0, child->GetVisualWidth(), 
child->GetVisualHeight());

}
\constant{view_PartialRedraw}  --  If the given area intersects the area of 
a child the partial redraw should be passed to the child.  E.g.:

	\


\example{case view_PartialRedraw:

case view_LastPartialRedraw:}

\example{struct rectangle childvisualbounds;

struct rectangle update, childupdate;


child->GetVisualBounds(&childvisualbounds);


// EnclosedXToLocalX and EnclosedYToLocalY convert

// coordinates in the parents frame of reference

// to coordinates in the child's frame.

rectangle_SetRectSize(&update, child->EnclosedXToLocalX(left), 
child->EnclosedYToLocalY(top), width, height);


rectangle_IntersectRect(&childupdate, &update, &childvisualbounds);


child->FullUpdate(type, childupdate.left, childupdate.top, 
childupdate.width, childupdate.height);}


Alternatively the redraw may be postponed until the last partial redraw 
arrives.


\constant{view_LastPartialRedraw}  --  If view_PartialRedraws are passed to 
the child then this should behave just like a view_PartialRedraw. 
 Otherwise this should either call FullUpdate on the child with a type of 
view_FullRedraw.  Alternately it may make one or more FullUpdate calls on 
the child with types of view_PartialRedraw or view_LastPartialRedraw such 
that all the areas which have been given view_PartialRedraw or 
view_LastPartialRedraw calls are covered in the update calls passed to the 
child.


\constant{view_MoveNoRedraw}  --  This should be passed on to any children. 
 The left, top, width, and height may be ignored.


\constant{view_Remove}  --  This also should be passed on to any children. 
 The left, top, width, and height may be ignored.}


\type{\class{view} *}\class{view}::Hit (\type{\keyword{enum} 
view_MouseAction} \argument{action}, \keyword{\type{long}} \argument{x}, 
\keyword{\type{long}} \argument{y}, \keyword{\type{long}} 
\argument{numberOfClicks});

If the given x, y coodinates are within a child that child's Hit method 
should be called as follows:


// add info about locating the right child XXX

\example{view *result=child->Hit(action, child->EnclosedXToLocalX(x), 
child->EnclosedYToLocalY(y), numberOfClicks);

// ...

return result;}


Note that the return value should be the return value from the child's Hit 
method.


\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{LinkTree}(\class{view} 
*\argument{parent});

This method is called to connect a child view with its parent.  The first 
thing it should do is call the \virtualmemberfunction{LinkTree} method in 
the immediate base class, e.g.:


\example{\class{base}::\virtualmemberfunction{LinkTree}(\argument{parent})}


Then if parent is \constant{NULL} any children linked in should also have 
their LinkTree method called with a \constant{NULL} \argument{parent}.


If \argument{parent} is non-\constant{NULL} the 
child->\virtualmemberfunction{LinkTree}(\staticmemberfunction{this}) should 
be called on any children which should or may be visible.  This may be 
postponed until just before the \virtualmemberfunction{InsertView} and 
\virtualmemberfunction{FullUpdate} for the child.


Then if \argument{parent} is non-\constant{NULL} and 
\virtualmemberfunction{GetIM}() returns non-\constant{NULL} any display 
queries can be made (\virtualmemberfunction{DisplayClass}() for example), 
and colors may be allocated. \



\keyword{\type{void}} 
\class{view}::\memberfunction{InsertViewRegion}(\type{\class{view} 
*}\argument{parent}, \type{\class{region} *}\argument{region});

\keyword{\type{void}} 
\class{view}::\memberfunction{InsertView}(\type{\class{view} 
*}\argument{parent}, \type{\keyword{struct} rectangle 
*}\argument{enclosingRect});

\keyword{\type{void}} 
\class{view}::\memberfunction{InsertViewSize}(\type{\class{view} 
*}\argument{parent}, \keyword{\type{long}} \argument{xOriginInParent}, 
\keyword{\type{long}} \globalvariable{yOriginInParent}, \keyword{\type{long}} 
\argument{width}, \keyword{\type{long}} \argument{height});

These methods allocate space in the parent for a child view to be drawn in. 
 \virtualmemberfunction{InsertViewRegion} supports using a region object to 
describe an arbitrary area for the view to draw in. 
 \memberfunction{InsertView} and \memberfunction{InsertViewSize} allow a 
simple rectangular area to be allocated.


\keyword{\type{void}} \class{view}::\virtualmemberfunction{InitChildren}();

When this method is called all child views should be allocated and linked 
into the view tree.


\type{boolean} 
\class{view}::\virtualmemberfunction{RecSearch}(\type{\keyword{struct} 
SearchPattern *}\argument{pat}, \type{boolean} \argument{toplevel});

\type{boolean} 
\class{view}::\virtualmemberfunction{RecSrchResume}(\type{\keyword{struct} 
SearchPattern *}\argument{pat});

\type{boolean} 
\class{view}::\virtualmemberfunction{RecSrchReplace}(\type{\class{dataobject\
} *}\argument{text}, \keyword{\type{long}} \argument{pos}, 
\keyword{\type{long}} \argument{len});

\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{RecSrchExpose}(\type{\keyword{const} 
\keyword{struct} rectangle &}\argument{logical}, \type{\keyword{struct} 
rectangle &}\globalvariable{hit});

These functions implement the recursive search protocol.  This protocol 
allows an entire document to be searched for text matching a regular 
expression.  The search will include any descendants of the original 
\classobject{view} which support the recsearch protocol.


\virtualmemberfunction{RecSearch} initiates a search (if \argument{toplevel} 
is \constant{TRUE}) or recurses into a descendent \classobject{view} (if 
\argument{toplevel} is \constant{FALSE}).  It should search through the 
data in an intuitive order, recursing into any child \classobject{views} as 
they are encountered.  When a hit is found the position and the fact that a 
hit was found should be recorded in the \classobject{view} and 
\constant{TRUE} should be returned.  If no hit is found 
\virtualmemberfunction{RecSearch} should return \constant{FALSE}. 
 Typically \virtualmemberfunction{RecSearch} itself will simply set the 
starting point of the search and call \virtualmemberfunction{RecSrchResume} 
to perform the actual search.


\virtualmemberfunction{RecSrchResume} resumes a search after a hit has been 
found by a previous \virtualmemberfunction{RecSearch} or 
\virtualmemberfunction{RecSrchResume} call.


\virtualmemberfunction{RecSrchReplace} replaces the current hit with the 
\argument{len} characters at position \argument{pos} in the \argument{text}.


\virtualmemberfunction{RecSrchExpose} should ensure that the hit is 
displayed in the logical area of the \classobject{view}.  The \argument{hit} 
is filled in with the position of the hit assuming the \classobject{view} 
will be drawn with the given \argument{logical} area. 
 \virtualmemberfunction{RecSrchExpose} will typically use 
\virtualmemberfunction{WantExposure} to ensure the proper display.


\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{WantExposure}(\type{\class{view} 
*}\argument{child}, \type{\keyword{struct} rectangle 
*}\argument{childrect});

This method attempts to ensure that the given rectangle within the child is 
visible.  \staticmemberfunction{childrect} is in the child's coordinate 
system, it can be converted to the parent's system by adding 
\argument{child}->\memberfunction{GetEnclosedLeft}() to the left and 
child->\memberfunction{GetEnclosedTop}() to the top coordinate.  If the 
child is movable and the requested childrect falls outside the logical 
bounds of the parent the child should be moved to bring the 
\argument{childrect} within the parent's logical bounds.

If the \argument{childrect} (before or after scrolling) is within the 
logical bounds of the parent the grandparent's 
\virtualmemberfunction{WantExposure} method should be called with the 
converted childrect. \



\type{void} 
\class{view}::\virtualmemberfunction{WantUpdate}(\type{\class{view} 
*}\argument{requestor});

Usually the default implementation of this method will be sufficient.  The 
default implementation simply passes the request up to the parent. 
 Eventually the request will be passed to a \classobject{view} (the 
\classobject{im} if nothing else), which will arrange for the 
\argument{requestor}'s \virtualmemberfunction{Update} method to be called 
to update the screen image.  A typical call is something like: 
 \virtualmemberfunction{WantUpdate}(\constant{this}).  If a \class{view} 
 class needs more detailed control of when its children are allowed to 
redraw a \virtualmemberfunction{WantUpdate} method can be implemented. 
 This implementation would record the \virtualmemberfunction{WantUpdate} 
requests, and request updates for itself.  \virtualmemberfunction{Update} 
would be implemented so that it called the \virtualmemberfunction{Update} 
methods for all the requestors whose \virtualmemberfunction{WantUpdate} 
calls were recorded.


\keyword{\type{void}} \class{view}::\virtualmemberfunction{UnlinkTree}();

If a \classobject{view} is linked into a view tree it should be unlinked 
before being destroyed, or if it is being removed from the screen.  A 
typical call is something like: 
 \datamember{child}->\virtualmemberfunction{UnlinkTree}(). 
 \virtualmemberfunction{UnlinkTree} should not be implemented in derived 
classes. See \virtualmemberfunction{LinkTree} instead.


\type{boolean} 
\class{view}::\virtualmemberfunction{IsAncestor}(\type{\class{view} 
*}\argument{possibleAncestor});

\virtualmemberfunction{IsAncestor} checks whether 
\argument{possibleAncestor} is an ancestor of the \classobject{view}.  If 
so it returns \constant{TRUE}, otherwise it returns \constant{FALSE}.


\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{UnlinkNotification}(\type{\class{view} 
*}\argument{unlinkedTree});

\virtualmemberfunction{UnlinkNotification} will be called on the ancestors 
of any view which is unlinked with \virtualmemberfunction{UnlinkTree}.  It 
can be overridden if there is a need for the \classobject{view} to react 
when its descendant is unlinked.  It is important that all 
implementations of \virtualmemberfunction{UnlinkNotification} include a 
call such as:


\example{\datamember{parent}->\virtualmemberfunction{UnlinkNotification}(\
\argument{unlinkedTree});}


before any further processing.


\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{ChildLosingInputFocus}();

\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{ChildReceivingInputFocus}();

These methods are called for each ancestor of a view losing or receiving 
the input focus.

\section{
5.15	X Selections}


\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{LoseSelectionOwnership}();

\keyword{\type{long}} 
\class{view}::\virtualmemberfunction{WriteSelection}(\type{FILE 
*}\argument{out});\section{


5.16	Cut & Paste


5.17	Printing}

\section{
5.18	Message Line/Dialog Box Input}


The message line is an area at the bottom of the window set off from the 
main area which can be used to input or display simple iso-8859 strings, 
and to ask multiple choice questions.  (Including plain ASCII, iso-8859-1, 
or whatever character set the message line font supports.)  The same 
interface allows the input or display to be done in simple dialog boxes as 
well.


See message.ref.doc for more information.


\section{5.19	Handlers


}\section{5.20	Printing}


\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{PrintPSDoc}(\type{FILE 
*}\argument{outfile}, \keyword{\type{long}} \argument{pagew}, 
\keyword{\type{long}} \argument{pageh});

\keyword{\type{void}} 
*\class{view}::\virtualmemberfunction{GetPSPrintInterface}(\type{\keyword{ch\
ar} *}\argument{printtype});

\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{DesiredPrintSize}(\keyword{\type{long}} 
\argument{width}, \keyword{\type{long}} \argument{height}, 
\type{\keyword{enum} view_DSpass} \argument{pass}, \type{\keyword{long} 
*}\argument{desiredwidth}, \type{\keyword{long} *}\argument{desiredheight});

\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{PrintPSRect}(\type{FILE 
*}\argument{outfile}, \keyword{\type{long}} \argument{logwidth}, 
\keyword{\type{long}} \argument{logheight}, \type{\keyword{struct} 
rectangle *}\argument{visrect});

\type{\keyword{struct} view_printoptlist 
*}\class{view}::\virtualmemberfunction{PrintOptions}();

\keyword{\type{long}} 
\class{view}::\virtualmemberfunction{GetPrintOption}(\type{\class{atom} 
*}\argument{popt});

\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{SetPrintOption}(\type{\keyword{struct} 
view_printopt *}\argument{vopt}, \keyword{\type{long}} \argument{value});

\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{Print}(\type{FILE *}\argument{file}, 
\type{\keyword{char} *}\argument{processor}, \type{\keyword{char} 
*}\argument{finalFormat}, \type{boolean} \argument{topLevel});

\type{\class{view} *}Hit (\type{\keyword{enum} view_MouseAction} 
\argument{action}, \keyword{\type{long}} \argument{x}, \keyword{\type{long}} 
\argument{y}, \keyword{\type{long}} \argument{numberOfClicks});\section{

}\section{
5.21	Resource Manager}


These methods implement the old way of doing resources.  At a future date 
they may be documented or replaced with the new way.


\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{SetName}(\type{\class{atomlist} 
*}\argument{name});

\type{\class{atomlist} *}\class{view}::\virtualmemberfunction{GetName}();

\type{\class{atomlist} *}\class{view}::\virtualmemberfunction{GetClass}();

\keyword{short} 
\class{view}::\virtualmemberfunction{GetParameter}(\type{\class{atomlist} 
*}\argument{name}, \type{\class{atom} *}\argument{type}, \type{long 
*}\argument{datum});

\keyword{short} 
\class{view}::\virtualmemberfunction{GetResource}(\type{\class{atomlist} 
*}\argument{name}, \type{\class{atomlist} *}class_\argument{c}, 
\type{\class{atom} *}\argument{type}, \type{long\type{ *}}\argument{datum});

\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{GetManyParameters}(\type{struct\type{ 
}resourceList *}\argument{resources}, \type{\class{atomlist} 
*}\argument{name}, \type{\class{atomlist} *}class_\argument{c});		      \


\keyword{\type{void}} 
\class{view}::\virtualmemberfunction{PostResource}(\type{\class{atomlist} 
*}\argument{path}, \type{\class{atom} *}\argument{type}, 
\keyword{\type{long}} \argument{datum});

\section{
}\section{5.22	WantInformation}

\section{
5.23	Triggers}



\chapter{6.	An Inset That Works}


Demonstrate a working inset and walk through the code describing the 
various protocols and data structures.



\chapter{7.	An Inset That Doesn't Work}


Starting with a buggy inset implementation, demonstrate the use of build 
time messages, purify and xdb to locate bugs.

\indent{\section{
7.1	Procotol and Datastructure Bugs}

\section{7.2	General Coding Bugs}

\indent{\subsection{Uninitialized Memory Reads}

\subsection{NULL Pointer Dereferencing}

\subsection{Free Memory Reads}

\subsection{Freeing Unallocated Memory}

\subsection{Writing Into String Literals}

\subsection{Memory Leaks}

\subsection{Aggregate Initialization of Local Variables}

\subsection{For-Loop Variable Scope}}}



\chapter{8.	C++ Features}


\indent{\section{Inline Functions}

\section{Static Member Functions}

\section{Virtual Member Functions}

\section{Normal Member Functions}

\section{Function & Operator Overloading}

\section{Conversion Functions}

\section{Global Objects with Constructors and Destructors}

}

\chapter{9.	Dangerous C++ Features}


New features,  features not yet widely implemented, and features 
incompatible with ATK.

\indent{\section{
Templates}

\section{Virtual Inheritance}

\section{Multiple Inheritance}

\section{Exceptions}

\section{bool, mutable, & other new keywords}

}
\chapter{10.	Overview of ATK Insets & Classes


	}\indent{\section{10.1	ATKregistryEntry}


\type{const char 
*}\class{ATKregistryEntry}::\virtualmemberfunction{GetTypeName}();

Returns the name of the class this \classobject{ATKregistryEntry} 
represents.


\type{boolean} 
\class{ATKregistryEntry}::\virtualmemberfunction{IsType}(\type{const 
\class{ATKregistryEntry} *}\argument{typeobject});

\type{boolean} 
\class{ATKregistryEntry}::\virtualmemberfunction{IsType}(\type{const char 
*}\argument{classname});

\type{boolean} 
\class{ATKregistryEntry}::\virtualmemberfunction{IsType}(\type{const 
\class{ATK} *}\argument{typeobject});

\virtualmemberfunction{IsType} in any of these forms returns \constant{TRUE} 
if the argument represents a base class of the class represented by this 
\classobject{ATKregistryEntry}, otherwise it returns \constant{FALSE}.

\section{
10.2	ATK}


\type{\class{ATKregistryEntry} 
*}\class{ATK}::\virtualmemberfunction{ATKregistry}();

Returns the \classobject{ATKregistryEntry} representing the actual class of 
the object.


static\type{ int &}\class{ATK}::\staticmemberfunction{DynamicLoadTrace}();

Assigning a non-zero value to this reference will cause the dynamic loading 
code to print informational message while it operates.


static \type{\class{ATKregistryEntry} 
*}\class{ATK}::\staticmemberfunction{LoadClass}(\type{const char 
*}\argument{classname});

Returns the \classobject{ATKregistryEntry} for \argument{classname}, 
loading it dynamically if needed.


static \type{boolean} 
\class{ATK}::\staticmemberfunction{IsLoaded}(\type{const char 
*}\argument{classname});

Returns \constant{TRUE} if \argument{classname} is already loaded. 
Otherwise it returns \argument{FALSE}.


\type{\class{ATK} *}\class{ATK}::\virtualmemberfunction{NewFromObject}();

Creates a new object of the same type as the object it is called on.


static \type{\class{ATK} 
*}\class{ATK}::\staticmemberfunction{NewObject}(\type{const char 
*}\argument{classname});

Creates a new object of type classname.


\type{const boolean} 
\class{ATK}::\virtualmemberfunction{IsType}(\type{const 
\class{ATKregistryEntry} *}\argument{classent});

\type{const boolean} 
\class{ATK}::\virtualmemberfunction{IsType}(\type{const char 
*}\argument{classname});

\type{const boolean} 
\class{ATK}::\virtualmemberfunction{IsType}(\type{const \class{ATK} 
*}\argument{typeobject});\virtualmemberfunction{

IsType} in any of these forms returns \constant{TRUE} if the argument 
represents a base class of this object's class,  otherwise it returns 
\constant{FALSE}.


static \type{const boolean} 
\class{ATK}::\staticmemberfunction{IsTypeByName}(\type{const char *}sub, 
\type{const char *}super);

Returns \constant{TRUE} if the class \argument{sub} derived from the class 
\argument{super}, otherwise it returns \constant{FALSE}.


\type{const char *}\class{ATK}::\virtualmemberfunction{GetTypeName}();

Returns the class name of the object.


\section{10.3	environ


}\subsection{10.3.1	Environment Variables}


static \type{void} 
\class{environ}::\staticmemberfunction{PutPrinter}(\type{char 
*}\argument{printer});

Sets the printer environment variable(s) so that the printing system will 
direct files to the appropriate \argument{printer}.  The \argument{printer} 
argument may reference a temporary string, a copy will be made.


static \type{char *}\class{environ}::\staticmemberfunction{GetPrinter}();

Retrieves the current setting of the printer environment variable(s).  The 
returned pointer is in internal storage which may be freed on subsequent 
calls to \staticmemberfunction{Delete}, 
\staticmemberfunction{DeletePrinter}, \staticmemberfunction{Put}, or 
\staticmemberfunction{PutPrinter}.


static \type{void} \class{environ}::\staticmemberfunction{DeletePrinter}();

Removes any settings of the printer environment variable(s).


static \type{void} \class{environ}::\staticmemberfunction{Put}(\type{char 
*}\argument{variable}, \type{char *}\argument{value});

Adds or changes an environment \argument{variable} to have the given 
\argument{value}.  The \argument{variable} and \argument{value} arguments 
may reference temporary strings, copies of them will be made.


static \type{void} 
\class{environ}::\staticmemberfunction{Delete}(\type{char 
*}\argument{variable});

Removes any setting for the named environment \argument{variable}.


static \type{char *}\class{environ}::\staticmemberfunction{Get}(\type{char 
*}\argument{variable});

Retrieves the current setting of the named environment \argument{variable}. 
 The returned pointer is in internal storage which may be freed on 
subsequent calls to \staticmemberfunction{Delete}, 
\staticmemberfunction{DeletePrinter}, \staticmemberfunction{Put}, or 
\staticmemberfunction{PutPrinter}.


\subsection{10.3.2	Preferences}


Preferences (profiles) and configuration files are of the form:


keyname: value

# or

programname.keyname: value

# or

*.keyname: value


Pound signs at the start of a line indicate a comment.


When looking up a preference with the \staticmemberfunction{GetProfile} 
functions below first any preferences added by 
\staticmemberfunction{AddStringProfile} are checked, then the first 
existing file named in the PROFILES environment variable, and then the 
first existing file named in the GLOBALPROFILES environment variable.  If 
PROFILES is not set the default files to be checked are ~/preferences, and 
~/.preferences.  If GLOBALPROFILES is not set the default file to check is 
$ANDREWDIR/lib/global.prf.  (Where $ANDREWDIR is the environment variable 
if it is set, or the compiled in default otherwise.)  The first matching 
entry found will the value returned.  An entry without a program name or 
one with a program name of '*' will match any request for the given 
keyname.  Otherwise the programname must match the current program name. 
 (The matching is case insensitive.)


static \type{char 
*}\class{environ}::\staticmemberfunction{GetProfile}(\type{char 
*}\argument{preference});

Retrieves the current setting of the named \argument{preference} as a 
string.  The returned pointer is in internal storage which may be 
invalidated by future calls.


static \type{boolean} 
\class{environ}::\staticmemberfunction{GetProfileSwitch}(\type{char 
*}\argument{preference}, \type{boolean} \argument{defaultValue});

Retrieves the current setting of the named \argument{preference} as a 
boolean value, substituting the \argument{defaultValue} if there is no 
setting.


static \type{long} 
\class{environ}::\staticmemberfunction{GetProfileInt}(\type{char 
*}\argument{preference}, \type{long} \argument{defaultValue});

Retrieves the current setting of the named \argument{preference} as an 
integer value, substituting the \argument{defaultValue} if there is no 
setting.


static \type{boolean} 
\class{environ}::\staticmemberfunction{ProfileEntryExists}(\type{char 
*}\argument{preference}, \type{boolean} \argument{useDefault});

Tests whether a preference is set.  If \argument{useDefault} is 
\constant{FALSE} then wildcarded entries in the preferences will be 
ignored, otherwise they will match as for the 
\staticmemberfunction{GetProfile}* functions.  The first matching entry 
will cause \staticmemberfunction{ProfileEntryExists} to return 
\constant{TRUE}.  If there is no matching entry it will return 
\constant{FALSE}.


static \type{char 
*}\class{environ}::\staticmemberfunction{GetConfiguration}(\type{char 
*}\argument{key});

Retrieves a the system-wide configuration setting named by \argument{key}. 
 These settings are generally  placed where only system administrators can 
modify them.  See 'help Setup' for more information.  The returned pointer 
is in internal storage which may be invalidated by future calls.


static \type{char 
*}\class{environ}::\staticmemberfunction{AndrewDir}(\type{char 
*}\argument{path});

Returns a full path given a \argument{path} relative to the top of the 
installed tree.  E.g. to get the full path to $ANDREWDIR/lib/atk, the call 
would be \staticmemberfunction{AndrewDir}("lib/atk").  The returned pointer 
is in internal storage which will be overwritten on the next call.


static \type{char 
*}\class{environ}::\staticmemberfunction{LocalDir}(\type{char 
*}\argument{path});

Returns a full path given a \argument{path} relative to the top of the 
'local' tree.  The current 'local' directory is used to find such things as 
console LACC files, local help files, and the required subscriptions for 
AMS.  This is usually /usr/local.  The returned pointer is in internal 
storage which will be overwritten on the next call.


static \type{struct configurelist 
*}\class{environ}::\staticmemberfunction{ReadConfigureFile}(\type{char 
*}\argument{filename});

ReadConfigureFile opens an arbitrary file to be read using the same 
conventions as a preferences file.  The struct configurelist pointer should 
be saved for subsequent use in calls to GetConfig.


static \type{char 
*}\class{environ}::\staticmemberfunction{GetConfig}(\type{struct 
configurelist *}\argument{cList}, \type{char *}\argument{key}, 
\type{boolean} \argument{usedefault});

Looks up the setting named by \argument{key} in the configuration file 
represented by \argument{cList}.  If \argument{usedefault} is 
\constant{TRUE} then wildcards will be allowed for the program name, 
otherwise only an exact match on the program name will be allowed.  The 
returned string will be the value of the named setting, or \constant{NULL} 
if no matching setting was found.  Note that all strings returned from 
\staticmemberfunction{GetConfig} will be invalidated when 
\staticmemberfunction{FreeConfigureList} is called on \argument{cList}. \



static \type{void} 
\class{environ}::\staticmemberfunction{FreeConfigureList}(\type{struct 
configurelist *}\argument{cList});

Once  a configuration file is no longer needed 
\staticmemberfunction{FreeConfigureList} will free the datastuctures used 
in reading it.


static \type{char 
*}\class{environ}::\staticmemberfunction{GetHome}(\type{char 
*}\argument{user});

Looks up the home directory for the named \argument{user}.  If 
\argument{user} is \constant{NULL} the home directory for the user running 
the program is returned. The returned pointer is in internal storage which 
may be invalidated by future calls.


static \type{void} 
\class{environ}::\staticmemberfunction{SetProgramName}(\type{char 
*}\argument{name});

SetProgramName sets the program \argument{name} used in looking up 
preferences.


static \type{char 
*}\class{environ}::\staticmemberfunction{GetFirstProfileFileName}();

Retrieves the path to the first preferences (profile) file which was 
referenced.  (Obsolete, see GetProfileFileName.)  The returned pointer is 
in internal storage which may be invalidated by future calls.


static \type{char 
*}\class{environ}::\staticmemberfunction{GetProfileFileName}();

Retrieves the path to the current preferences (profile) file.  This will be 
the users current preferences file.  The returned pointer is in internal 
storage which may be invalidated by future calls.


static \type{void} 
\class{environ}::\staticmemberfunction{AddStringProfile}(\type{const char 
*}\argument{str});

\argument{str} is used as if it were a line in a preferences file to be 
used in any subsequent calls to the GetProfile functions.  Preferences 
added in this way override any settings in the user's preferences or the 
global preferences, and cannot be removed.  The preference is NOT saved 
permanently, no files are modified.


\section{10.4	im}


\type{void} \class{im}::\virtualmemberfunction{SetView}(\type{\class{view} 
*}\argument{toplevel});

Sets the view (toplevel) to be displayed in the window.


\type{unsigned char *}\class{im}::\virtualmemberfunction{WhichWS}();

Returns a string describing the window-system in use.  The currently known 
values are "X" and "wm".


\type{int} \class{im}::\virtualmemberfunction{GetCharacter}();

Waits for and returns the next character typed by the user.


\type{boolean} \class{im:}:\virtualmemberfunction{WasMeta}();

Returns \constant{TRUE} if an escape character was just returned from 
\class{im}::\virtualmemberfunction{GetCharacter} and was triggered by a 
meta-key press.  Otherwise returns \constant{FALSE}.


\type{\class{im} *}\class{im}::\virtualmemberfunction{DoKey}(\type{long} 
\argument{key});

Simulates the user typing a \argument{key} in the window.  Returns the 
\classobject{im} it was called if it still exists, and \constant{NULL} 
otherwise.


\type{void} \class{im}::\virtualmemberfunction{DoKeySequence}(\type{char 
*}\argument{keys});

Simulates the user typing a sequence of \argument{keys} in the window.


\type{void} \class{im}::\virtualmemberfunction{DoMacro}();

Plays the recorded keyboard macro.


\type{void} \class{im}::\virtualmemberfunction{DoMenu}(\type{char 
*}\argument{itemname});

Simulates the user selecting the \argument{itemname} menu item.  The card 
name may be present, or omitted.


\type{void} \class{im}::\virtualmemberfunction{ClearArg}();

Clears the argument state so that the next proctable function called will 
perform its action only once.


\type{boolean} \class{im}::\virtualmemberfunction{ArgProvided}();

Returns \constant{TRUE} if an argument has been provided, and 
\constant{FALSE} otherwise.


\type{long} \class{im}::\virtualmemberfunction{Argument}();

Returns the number of times a proctable function should perform its 
action.  Unless overriden by a call to \virtualmemberfunction{ProvideArg} 
or \virtualmemberfunction{BumpArg} this will be 1.


\type{void} \class{im}::\virtualmemberfunction{ProvideArg}(\type{long} 
\argument{arg});

Sets the number of times a proctable function should perform its action.


\type{void} \class{im}::\virtualmemberfunction{BumpArg}(\type{long} 
\argument{digit});

Enters a new low order digit to be used as the 
\virtualmemberfunction{Argument} for the next proctable function called. 
 E.g. if the last digit was 9 and the current digit is 4, the 
\virtualmemberfunction{Argument} would be 94.  The first call to 
\virtualmemberfunction{BumpArg} after the argument state has been reset 
will set the \virtualmemberfunction{Argument} to the value of the digit 
passed in.  The argument state is reset after each proctable function call.


\type{void} \class{im}::\virtualmemberfunction{DisplayArg}();

Displays the current \virtualmemberfunction{Argument} value to the user.


\type{long} \class{im}::\virtualmemberfunction{AllocLastCmd}();

Returns a new identifier to be used to identify the type of the last 
proctable function executed.  For example the textview kill line command 
uses this to append the new cut to the last cut only if the previous cut 
was also made by textview kill line.


\type{long} \class{im}::\virtualmemberfunction{GetLastCmd}();

Returns the identifier associated with the last proctable function 
executed.  A value of 0 indicated that no unique identifier was associated 
with that proctable function.


\type{void} \class{im}::\virtualmemberfunction{SetLastCmd}(\type{long} 
\argument{cmd});

Used within a proctable function to indicate the unique identifier 
associated with this proctable function.  The \argument{cmd} must have been 
allocated with \virtualmemberfunction{AllocLastCmd}.


\type{void} 
\class{im}::\virtualmemberfunction{SetWindowCursor}(\type{\class{cursor} 
*}\argument{c});

Sets the \classobject{cursor} to be displayed in this window.  Typically 
this is used by a \class{view}'s \virtualmemberfunction{Hit} method to 
provide feedback during a mouse movement operation.


\type{void} \class{im}::\virtualmemberfunction{SetTitle}(\type{char 
*}\argument{title});

Sets the \argument{title} to be displayed in the window's title bar. 
 (Though the window may not have a title bar at all, that will depend on 
the window-system and on the window manager under X.)

\type{char *}\class{im}::\virtualmemberfunction{GetTitle}();

Returns the last title set with \class{im}::\virtualmemberfunction{SetTitle}.


\type{FILE *}\class{im}::\virtualmemberfunction{FromCutBuffer}();

Returns a \type{FILE} open for reading the contents of the cutbuffer and/or 
the X selection if applicable when running under X.


\type{FILE *}\class{im}::\virtualmemberfunction{ToCutBuffer}();

Returns a FILE open of writing a new value for the cutbuffer, and/or the X 
selection if applicable when running under X.


\type{void} 
\class{im}::\virtualmemberfunction{CloseFromCutBuffer}(\type{FILE 
*}\argument{readFile});

Closes the \type{FILE}}, fclose must \bold{\italic{not}} be used.\indent{


\type{void} \class{im}::\virtualmemberfunction{CloseToCutBuffer}(\type{FILE 
*}\argument{writeFile});

Closes the \type{FILE} and updates the cutbuffer, fclose must 
\bold{\italic{not}} be used.


\type{void} \class{im}::\virtualmemberfunction{RotateCutBuffers}(\type{long} 
\argument{count});

If more that one cutbuffer is available (8 are available under X), rotates 
the cutbuffers so that the first buffer gets the contents of the last, the 
second the contents of the first and so on.  (The is effectively repeated 
\argument{count} times.)


\type{void} 
\class{im}::\virtualmemberfunction{AppendToCutBuffer}(\type{FILE 
*}\argument{writeFile});

Appends the contents of writeFile to the cutbuffer, and or the X selection 
if applicable when running under X.


\type{FILE *}\class{im}::\virtualmemberfunction{OnlyFromCutBuffer}();

Returns a \type{FILE} open for reading the contents of the cutbuffer only 
ignoring the X selection when running under X.


\type{FILE *}\class{im}::\virtualmemberfunction{OnlyFromSelection}();

Returns a \type{FILE} open for reading the contents of the selection when 
running under X.


\type{struct im_InteractionEvent 
*}\class{im}::\virtualmemberfunction{SetInteractionEvent}(\type{im_interacti\
onfptr} \argument{function}, \type{long} \argument{functionData}, 
\type{long} \argument{time});

Sets a \argument{function} to be called when the next user interaction 
occurs, or after the given number of \argument{time} units have elapsed. 
 The \argument{function} is called only with the \argument{functionData}. 
 See event.H, or the event class documention in this file. (If it is 
completed.), for information on the interpretation of the \argument{time} 
argument.


\type{void} 
\class{im}::\virtualmemberfunction{CancelInteractionEvent}(\type{struct 
im_InteractionEvent *}\argument{event});

Removes an \type{im_InteractionEvent} from the list of pending 
\type{im_InteractionEvents}.  This should only be done \bold{\italic{before}} 
the interaction event function has been called for this event.


\type{void} \class{im}::\virtualmemberfunction{RedrawWindow}();

Forces the window to be redrawn from scratch.


\type{void} \class{im}::\virtualmemberfunction{SetWMFocus}();

Ensures that this \classobject{im} has the input focus of the 
window-system.  Under X this is done by raising the window, warping the 
pointer to the window and setting the X server input focus to the window. 
 This should be avoided except in direct response to a user request.


\type{void} \class{im}::\virtualmemberfunction{ExposeWindow}();

Tries to make sure the \classobject{im}'s window is visible.  Under X this 
is done by raising it.


\type{void} \class{im}::\virtualmemberfunction{HideWindow}();

Iconifies the \classobject{im}'s window if the window-system supports that. 
 (X does suppport iconification.)


\type{void} \class{im}::\virtualmemberfunction{VanishWindow}();

Totally removes the \classobject{im}'s window from the screen.


\type{boolean} \class{im}::\virtualmemberfunction{SupportsTransient}();

Returns \constant{TRUE} if the window-system supports transient windows, 
and \constant{FALSE} otherwise.  Transient windows are generally temporary 
windows associated with main application windows.  Window-systems and 
window managers may decorate such windows differently, or provide different 
levels of control over them.  Some window-systems may also support 
transients which are not controlled by the window-manager at all.  (X does 
support this.)

\type{boolean} \class{im}::\virtualmemberfunction{SupportsOverride}();

Returns TRUE if the window-system supports override windows, and FALSE 
otherwise.  Override windows are generally temporary windows contained 
within their parent window and are used for dialog boxes and the like, 
where the parent window should not receive input until the dialog is 
answered.


\type{boolean} \class{im}::\virtualmemberfunction{SupportsOffscreen}();

Returns \constant{TRUE} if the window-system supports windows which don't 
appear offscreen but which can be drawn into and then copied onscreen, and 
\constant{FALSE} otherwise.


\type{\class{colormap} 
*}\class{im}::\virtualmemberfunction{CreateColormap}();

Returns a newly created colormap appropriate for the window-system.  Such a 
colormap can be used with 
\class{view}::\virtualmemberfunction{WantColormap}, to install a private 
colormap so a view can use more colors.  (At the expense of everything else 
on screen becoming corrupted while the private colormap is installed.)

\type{void} \class{im}::\virtualmemberfunction{SetBorderWidth}(\type{int} 
\argument{n});

Sets the width of the border around the window to \argument{n} pixels.  The 
size of the border may be overriden by the window-system.


\type{struct rectangle 
*}\class{im}::\virtualmemberfunction{GetLoc}(\type{\class{view} 
*}\argument{v}, \type{struct rectangle *}\argument{r});

Fills in \argument{r} with the location and size of the view \argument{v} 
on the screen.  (i.e. in pixels relative to the upper left corner of the 
screen.)


\type{im_deletefptr} 
\class{im}::\virtualmemberfunction{GetDeleteWindowCallback}();

Returns the function which will be called when the window-system requests 
that this window be deleted.


\keyword{\type{long}} 
\class{im}::\virtualmemberfunction{GetDeleteWindowCallbackRock}();

Returns the rock which will be passed to the DeleteWindowCallback.


\keyword{\type{void}} 
\class{im}::\virtualmemberfunction{SetDeleteWindowCallback}(\type{im_deletef\
ptr} \argument{cb}, \keyword{\type{long}} \argument{rock});

Sets the function (\argument{cb}) to be called when the window-system 
requests that this window be deleted.  The call will be made like: 
 (*cb)(this, rock).


\type{void} \class{im}::\virtualmemberfunction{ResizeWindow}(\type{int} 
\argument{w}, \type{int} \argument{h});

Requests that the window be made \argument{w} pixels wide and \argument{h} 
pixels tall.  The window-system may not actually make the window the 
desired size.


\type{void} \class{im}::\virtualmemberfunction{MoveWindow}(\type{int} 
\argument{x}, \type{int} \argument{y});

Requests that the window be moved to position \argument{x},\argument{y} 
relative to the upper left of the screen.  (Or in the case of override 
windows or override_redirect windows relative to their parent.)  The 
window-system may not actually place the window in the requested position 
if it is not an override or override_redirect window.


\type{void} \class{im}::\virtualmemberfunction{Beep}(\type{int} 
\argument{volume});

Beeps at 0...100 % of a user specified maximum volume.


\type{\class{view} *}\class{im}::\virtualmemberfunction{GetInputFocus}();

Returns the view within the window which will receive keyboard and menu 
input.  (Its ancestors can receive the input too depending on how they 
have been written.)


\keyword{typedef} \keyword{\type{void}} 
(*\type{im_configurefptr})(\type{\class{im}  *}\argument{self}, 
\keyword{\type{long}}  \argument{rock} , \keyword{\argument{long}} 
 \argument{customrock}, \type{\class{im}  *}\argument{parent}, 
\type{\keyword{int}  *}\argument{x} , \type{\keyword{int}  *}\argument{y}, 
\type{\keyword{unsigned} \keyword{int}  *}\argument{w} , 
\type{\keyword{unsigned} \keyword{int}  *}\argument{h});

This is the signature of a ConfigureFunction.  Its purpose is to fill in 
*\argument{x}, *\argument{y}, *\argument{w}, and *\argument{h} with the 
desired position and size of an override window or transient window.  The 
values to be set are initialized with defaults based on the preferred size 
and position set with SetPreferedDimensions or on the size and position of 
the window if no prefered dimensions have been set.  The *\argument{x} and 
*\argument{y} coordinates are relative to the uper left of the parent 
window. (Excluding the menubar if any.)  The rock argument is the 'or' of:

\constant{im_InMiddle}		half way between the left and right edges of the 
parent.

\constant{im_Centered}		centered within the parent.

\constant{im_AtTop}			in the upper portion of the parent.

\constant{im_AtBottom}		in the lower portion of the parent.

<65536			Any application specific flags.


inline \type{im_configurefptr 
&}\class{im}::\virtualmemberfunction{ConfigureFunction}();

Returns a modifiable reference to the function pointer which will be called 
when a transient or override window is being created to determine the size 
and placement of the window.


\type{long &}\class{im}::\virtualmemberfunction{ConfigureRock}();

Returns a modifiable reference to the long value which will be passed as 
the rock argument to the configure function.


\type{long &}\class{im}::\virtualmemberfunction{ConfigureCustomRock}();

Returns a modifiable reference to the long value which will be passed as 
the custom rock argument to the configure function.


\type{void} \class{im}::\memberfunction{SetAutoMap}(\type{boolean} 
\argument{val});

If \argument{val} is \constant{TRUE} (the default) the window will be 
mapped automatically when the interaction loop resumes, or when 
\virtualmemberfunction{RedrawWindow} is called.  If \argument{val} is 
\destructor{FALSE} the window will not be mapped until 
\virtualmemberfunction{ExposeWindow} is called.


\type{boolean} \class{im}::\memberfunction{GetAutoMap}();

Returns the last value set by \memberfunction{SetAutoMap}.


\type{void} \class{im}::\memberfunction{SetStartIconic}(\type{boolean} 
\argument{val});

If \argument{val} is \constant{TRUE} the window will be mapped in an 
iconified state when it is first mapped.  If \argument{val} is 
\constant{FALSE} (the default) the window will be mapped normally.


\type{boolean} \class{im}::\memberfunction{GetStartIconic}();

Returns the last value set by \memberfunction{SetStartIconic}.


static \type{\class{im} 
*}\class{im}::\staticmemberfunction{Create}(\type{char *}\argument{host});

Creates an \classobject{im} on \argument{host} (or the default host if 
\argument{host}==\constant{NULL}).  Unless 
\memberfunction{SetAutoMap}(\constant{FALSE}) is called before the 
interaction loop resumes the window will be mapped automatically.  The 
interpretation of host is window-system dependent.  X uses strings of the 
form:  hostname:display.screen  Where display and screen are integers.


static \type{\class{im} 
*}\class{im}::\staticmemberfunction{CreateTransient}(\type{\class{im} 
*}\argument{other}, \type{int} 
\argument{flags}=\constant{im_TRANSIENTMENUS}, \type{im_configureptr} 
\argument{cfp}=\constant{NULL}, \type{long} \argument{crock}=0);

Creates a transient window for the \argument{other} im.  The \argument{cfp} 
function will be called with the custom rock \argument{crock} to determine 
the size and location of the window.  flags is the 'or' of the following 
values:


\constant{im_TRANSIENTMENUS}		show a menubar

\constant{im_OVERRIDEREDIRECT}	avoid window-manager interference


If flags&im_OVERRIDEREDIRECT is non-zero the window won't be decorated by 
the window manager and it will be positioned as requested. 
 (\virtualmemberfunction{MoveWindow} and 
\virtualmemberfunction{ResizeWindow} will also function without 
interference from the window manager.)

static \type{\class{im} 
*}\class{im}::\staticmemberfunction{CreateOverride}(\type{\class{im} 
*parent}, \type{im_configurefptr} \argument{cfp}=\constant{NULL}, 
\type{long} \argument{crock});

Creates an override window for the \argument{parent} \class{im}.  The 
\argument{cfp} function will be called with the custom rock \argument{crock} 
to determine the size and location of the window.  Since the window is 
contained entirely within the parent the requested size and location will 
be granted.     (\virtualmemberfunction{MoveWindow} and 
\virtualmemberfunction{ResizeWindow} will also function without 
interference from the window manager.)  The main difference between an 
override window and a transient with \constant{im_OVERRIDEREDIRECT} set is 
that the override window cannot extend beyond the bounds of its parent 
while the override redirect window may.


static \type{boolean} 
\class{im}::\staticmemberfunction{AddFileHandler}(\type{FILE 
*}\argument{file}, \type{im_filefptr} \argument{proc}, \type{char 
*}\argument{procdata}, \type{long} \argument{priority});

Adds a handler to be called when data is available for reading on 
\argument{file}.  If \constant{NUMFILE} (16) handlers are already installed 
the new handler will only be installed if its \argument{priority} is 
greater (numerically) than one of the already installed handlers.  The 
\argument{proc} will be called as (*\argument{proc})(\argument{file}, 
\argument{procdata}).  \constant{TRUE} is returned if the handler has been 
installed, \constant{FALSE} is returned otherwise.


static \type{void} 
\class{im}::\staticmemberfunction{RemoveFileHandler}(\type{FILE 
*}\argument{file});

Removes a read handler installed for \argument{file}.


static \type{boolean} 
\class{im}::\staticmemberfunction{AddCanOutHandler}(\type{FILE 
*}\argument{file}, \argument{im_filefptr} proc, \type{char 
*}\argument{procdata}, \type{long} \argument{priority});

Adds a handler to be called when data may be written to \argument{file}. 
 If \constant{NUMFILE} (16) handlers are already installed the new handler 
will only be installed if its \argument{priority} is greater (numerically) 
than one of the already installed handlers.  The \argument{proc} will be 
called as (*\argument{proc})(\argument{file}, \argument{procdata}).


static \type{void} 
\class{im}::\staticmemberfunction{RemoveCanOutHandler}(\type{FILE 
*}\argument{file});

Removes a write handler for \argument{file}.


static \type{void} 
\class{im}::\staticmemberfunction{AddZombieHandler}(\type{int} 
\argument{pid}, \type{im_zombiefptr} \argument{function}, \type{long} 
\argument{functiondata});

Adds a \argument{function} to be called when the child process 
\argument{pid} changes state.  (Perhaps because it has exited, or possibly 
because it has been stopped.)  The function will be called like 
(*\argument{function})(\argument{pid}, \argument{functionData}, &status), 
where status is of type WAIT_STATUS_TYPE.


static \type{void} 
\class{im}::\staticmemberfunction{RemoveZombieHandler}(\type{int} 
\argument{pid});

Removes any handler installed for the child process \argument{pid}.


static \type{void} 
\class{im}::\staticmemberfunction{SignalHandler}(\type{long} 
\argument{signalNumber}, \type{im_signalfptr} \argument{proc}, \type{char 
*}\argument{procdata});

Adds a handler to be called when signal \argument{signalNumber} is 
received.  The \staticmemberfunction{proc} is called like 
(*\argument{proc})(\argument{signalNumber}, \argument{procdata}).


static \type{long} 
\class{im}::\staticmemberfunction{ChangeDirectory}(\type{char 
*}\argument{dirName});

Changes the working directory of the process to \argument{dirName}.


static \type{char 
*}\class{im}::\staticmemberfunction{GetDirectory}(\type{char 
*}\argument{outputString});

Returns the working directory of the process in \argument{outputString}. 
 Returns \argument{outputString} on success or \constant{NULL} on failure.


static \type{int} \class{im}::\staticmemberfunction{KeyboardExit}();

Exits one level of keyboard interaction.  Normally this will exit the 
application.  If a recursive edit has been invoked however it will return 
to the previous edit level.


static \type{long} \class{im}::\staticmemberfunction{KeyboardLevel}();

Returns the number keyboard levels in effect. When no recursive edit is in 
progress (normally) this is 1.


static \type{void} \class{im}::\staticmemberfunction{KeyboardProcessor}();

Initiates a new round of keyboard interaction.  (If one is already in 
progress this amounts to a recursive edit.)


static \type{\class{event} 
*}\class{im}::\staticmemberfunction{EnqueueEvent}(\type{event_fptr} 
\argument{proc}, \type{char *}\argument{procdata}, \type{long} 
\argument{timeIncrement});

Enqueues an event to take place in \argument{timeIncrement} time units. 
 The \argument{proc} is called like: 
 (*\argument{proc})(\argument{procdata},currentTime).  Where currentTime is 
a long representing the number of time units since the time was started 
last.


static \type{boolean} \class{im}::\staticmemberfunction{IsPlaying}();

Returns \constant{TRUE} if events are being played back from a keyboard 
macro, and \constant{FALSE} otherwise.


static \type{boolean} 
\class{im}::\staticmemberfunction{CheckForInterrupt}();

Checks for a ^G in the input indicating that the current operation should 
be aborted.  If a ^G is found all user input upto and including the ^G is 
discarded and \constant{TRUE} is returned, otherwise no input is discarded 
and \constant{FALSE} is returned.


static \type{long} \class{im}::\staticmemberfunction{GetWriteID}();

Returns a unique identifier for a particular invocation of a 
\class{dataobject}::\virtualmemberfunction{Write} operation.


static \type{void} 
\class{im}::\staticmemberfunction{SetProgramName}(\type{char 
*}\argument{nameString});

Sets the program name used for finding preferences and resets the geometry 
spec if a Geometry preference exists for the new programname. (Or a 
wildcard.)


static \type{char *}\class{im}::\staticmemberfunction{GetProgramName}();

Returns the program name set by \staticmemberfunction{SetProgramName}.


static \type{void} 
\class{im}::\staticmemberfunction{SetGlobalInit}(\type{\class{init} 
*}\argument{init});

Sets the init object to be used for all user controlled menu and 
keybindings.  See init.H.  (XXX need to document init in this document.)


static \type{\class{init} 
*}\class{im}::\staticmemberfunction{GetGlobalInit}();

Returns the init object being used for all user controlled menu and 
keybindings.


static \type{void} 
\class{im}::\staticmemberfunction{SetPreferedDimensions}(\type{long} 
\argument{top}, \type{long} \argument{left}, \type{long} \argument{width}, 
\type{long} \argument{height});

Sets the prefered dimensions for future \classobject{im}s.  Zero values 
indicate no preference.


static \type{void} 
\class{im}::\staticmemberfunction{GetPreferedDimensions}(\type{long 
*}\argument{top}, \type{long *}\argument{left}, \type{long 
*}\argument{width}, \type{long *}\argument{height});

Returns the prefered dimensions for future windows set by 
SetPreferedDimensions.


static \type{\class{im} *}\class{im}::\staticmemberfunction{GetLastUsed}();

Returns the last \classobject{im} the user interacted with, or 
\constant{NULL} if none.


static \type{void} 
\class{im}::\staticmemberfunction{SetDefaultServerHost}(\type{char 
*}\argument{host});

Sets the default \argument{host} for future 
\class{im}::\staticmemberfunction{Create} calls.


static \type{void} 
\class{im}::\staticmemberfunction{SetGeometrySpec}(\type{char 
*}\argument{value});

Sets the default geometry for future \classobject{im}s.


static \type{\class{im} 
*}\class{im}::\staticmemberfunction{CreateOffscreen}(\type{\class{im} 
*}\argument{other}, \type{int} \argument{width}, \type{int} 
\argument{height});

Creates an offscreen im for drawing, it will be created such that its 
contents can be copied to other \classobject{im}s on the same host as 
\argument{other}.


static \type{void} 
\class{im}::\staticmemberfunction{SetDefaultIconic}(\type{boolean} 
\argument{val});

Sets the default value for \memberfunction{StartIconic}.  By default this 
is \constant{FALSE}.


static \type{boolean} \class{im}::\staticmemberfunction{GetDefaultIconic}();

Returns the default value for \memberfunction{StartIconic}.


\section{10.5	frame}


\keyword{\type{void}} 
\class{frame}::\virtualmemberfunction{SetView}(\type{\class{view} 
*}\argument{v});

Sets the view to be displayed in the frame.  This should be done only after 
the \classobject{frame} has been linked into an \classobject{im} by a call 
such as:

	\


	\example{// i is an im *and f is a frame *.

\localvariable{i}->\virtualmemberfunction{LinkTree}(\localvariable{f});}


The input focus will be requested for the \classobject{view} \argument{v}.


\keyword{\type{void}} \class{frame}::SetBuffer(\type{\class{buffer} 
*}\type{buffer}, \type{boolean} \argument{setInputFocus});

Sets the \argument{buffer} to be displayed in the \classobject{frame}. 
 This should be done only after the \classobject{frame} has been linked 
into an \classobject{im}.  (See above for \virtualmemberfunction{SetView}.) 
 If \argument{setInputFocus} is \constant{TRUE} the \classobject{view} on 
the \classobject{buffer}'s data will be given the input focus if possible.


\keyword{\type{void}} 
\class{frame}::\virtualmemberfunction{SetCommandEnable}(\type{boolean} 
\argument{enable});

If \argument{enable} is TRUE the frame will provide a variety of menu items 
and keybindings for manipulating files and buffers, otherwise only the quit 
and ness bindings will be available.   If a \classobject{frame} is created 
with new, by default only the quit and ness bindings will be available.  If 
created with \class{frame}::\staticmemberfunction{Create} however, the full 
range of file and buffer manipulation functions will be available by 
default.


\keyword{\type{void}} \class{frame}::SetTitle(\type{\keyword{char} 
*}\argument{title});

Sets the \argument{title} to be displayed in the window's title bar if 
there is one.


\type{\class{view} *}\class{frame}::\virtualmemberfunction{GetView}();

Returns a pointer to the main \classobject{view} being displayed in the 
\classobject{frame}.  This will be the \classobject{view} previously set 
with \virtualmemberfunction{SetView}, or the \classobject{view} on the 
\classobject{buffer}'s \classobject{dataobject}.  If there is no view being 
displayed \constant{NULL} is returned.


\type{\class{view} *}\class{frame}::\virtualmemberfunction{GetChildView}();

Returns a pointer to the \classobject{view} which is the direct descendent 
of this \classobject{frame}.  This \classobject{view} may be the 
\classobject{view} returned by \virtualmemberfunction{GetView}, or it may 
be an 'application layer' \classobject{view} if the 
\virtualmemberfunction{frame} is displaying a \classobject{buffer}.  If 
there is no \classobject{view} is being displayed \constant{NULL} is 
returned.


\type{\class{buffer} *}\class{frame}::\virtualmemberfunction{GetBuffer}();

Returns the \classobject{buffer} being displayed, if there is no 
\classobject{buffer} being displayed \constant{NULL} is returned.


\type{boolean} \class{frame}::\virtualmemberfunction{GetCommandEnable}();

Returns TRUE if the full range of user operations are available on files 
and buffers, otherwise FALSE.


\type{\keyword{char} *}\class{frame}::\virtualmemberfunction{GetTitle}();

Returns the title being displayed in the windows titlebar.  (Or what would 
be displayed in the windows title bar if it had one.)  The string returned 
will be freed if the title is changed by \virtualmemberfunction{SetTitle} 
or if the \classobject{frame} is destroyed.


\type{boolean} \class{frame}::\virtualmemberfunction{GetQuitWindowFlag}();

Returns \constant{TRUE} if the "Quit" menu and keybinding on this frame 
will only delete the window instead of exiting the application.  If in 
addition the \classobject{buffer} will be destroyed in the absence of any 
other frames on it, this function will return 2. (A non-boolean value. 
sigh.)  Otherwise \constant{FALSE} will be returned.


\keyword{\type{void}} 
\class{frame}::\virtualmemberfunction{SetQuitWindowFlag}(\type{boolean} 
\argument{VAL}); \


Sets the behavior for the "Quit" menu and keybinding on this frame.  The 
values for \argument{VAL} are as described for the return value of 
\virtualmemberfunction{GetQuitWindowFlag} above.


static \type{\class{frame} 
*}\class{frame}::\staticmemberfunction{Enumerate}(\type{frame_effptr} 
\argument{function}, \keyword{\type{long}} \argument{functionData});

    	\keyword{typedef} \type{boolean} 
(*\type{frame_effptr})(\type{\localvariable{frame} *}\argument{f}, 
\keyword{\type{long}} \argument{d});

Calls the given function for each \classobject{frame} passing a pointer to 
the current \classobject{frame} and the \argument{functionData} on each 
call.  If the function returns \constant{TRUE} the current 
\classobject{frame} will be returned.  Otherwise the loop will continue 
until the function has been called on all the \classobject{frames}.  If no 
invocation of the function returns \constant{TRUE} 
\staticmemberfunction{Enumerate} will return \constant{NULL}.


static \type{\class{frame} 
*}\class{frame}::\staticmemberfunction{GetFrameInWindowForBuffer}(\class{buf\
fer} *\argument{b});

If the \classobject{buffer} \argument{b} is already viewed by some 
\classobject{frame} that \classobject{frame} will be returned, otherwise a 
new \classobject{frame} will be returned which is viewing the 
\classobject{buffer} in a new window.  The new \classobject{frame} will 
have all the file and buffer key and menu bindings enabled.


static \type{\class{frame} 
*}\class{frame}::\staticmemberfunction{Create}(\type{\class{buffer} 
*}\argument{b});

Returns a new \classobject{frame} set to view the \classobject{buffer} 
\argument{b}.  The new \classobject{frame} will have all the file and 
buffer key and menu bindings enabled.


\type{\keyword{char} 
*}\class{frame}::\virtualmemberfunction{WantInformation}(\type{\keyword{char\
} *}\argument{key});

\class{Frame}'s \virtualmemberfunction{WantInformation} method supports the 
single key "filename" this will return the file name of the 
\classobject{buffer} being displayed if any, otherwise the request will be 
passed up the view tree.  If no other \classobject{view} responds to the 
key "filename" \constant{NULL} will be returned.  (Currently \class{frame} 
is the only class which responds to the key "filename".)  The string 
returned may be temporary so it should be used immediately.


\type{\class{ATK} 
 *}\class{frame}::\virtualmemberfunction{WantHandler}(\type{\keyword{char} 
*}\argument{handler});

Currently \class{frame}'s \virtualmemberfunction{WantHandler} method 
supports only the \argument{handler} "message", which is used to connect 
the message functions to the message line \class{frame} provides.  If a 
request for another \argument{handler} is made 
\virtualmemberfunction{WantHandler} will pass the request to its parent 
(typically an \classobject{im}), or return \constant{NULL 
}\indent{\constant{ }}if it has no parent.\indent{  }If a 
non-\constant{NULL} pointer is returned it will be a pointer to an object 
of a class derived from the class whose name is specified in 
\argument{handler}.  The caller is responsible for deleting this object 
when it is no longer needed.

\section{
10.6	application}


In ATK new applications don't usually define their own main() function. 
 Instead each application (e.g. ez) has a class derived from 
\class{application}, this class should have a name ending in "app".  runapp 
or another base executable (such as created by genstatl) includes code in 
main to perform a variety of setup operations and then creates an 
\classobject{application} object of the appropriate type.  The appropriate 
type is determined by the command line arguments to runapp if it is invoked 
by that name, or by the name used to invoke runapp with "app" appended. 
 For example ez is actually a symlink to runapp so when you run ez the 
runapp executable is invoked, and creates an ezapp object.  If the 
constructor for the \class{application} class didn't set the name of the 
\class{application} with \virtualmemberfunction{SetName}, the name will be 
taken from the name of the executable.  Then the 
\virtualmemberfunction{ParseArgs} method is invoked to parse the command 
line arguments.  If \virtualmemberfunction{ParseArgs} succeeds (returns 
\constant{TRUE}), the ATK and application version numbers will be printed 
(unless supressed, see \memberfunction{SetPrintVersionFlag}), the 
init-files will be read, the \virtualmemberfunction{Start} method will then 
be invoked to initialize the application, if the Start method indicates 
sucesss (by returning \constant{TRUE}), the \virtualmemberfunction{Run} 
method will be invoked to actually begin the processing, when 
\virtualmemberfunction{Run} exits \virtualmemberfunction{Stop} is invoked 
to perform any cleanup needed, then finally the exit code returned by 
\virtualmemberfunction{Run} is passed to exit.


 \type{boolean} 
\class{application}::\virtualmemberfunction{ParseArgs}(\keyword{\type{int}} 
\argument{argc},\type{\keyword{char} **}\argument{argv});

This method handles the command line arguments to the 
\classobject{application}.  If an \class{application} wishes to add new 
command line arguments, or disable standard arguments it should override 
\virtualmemberfunction{ParseArgs}.  If any of the standard arguments are to 
be supported the first line in \virtualmemberfunction{ParseArgs} should be 
a call to the base class version of \virtualmemberfunction{ParseArgs}. 
 (Typically 
\class{application}::\virtualmemberfunction{ParseArgs}(\argument{argc}, 
\argument{argv}) since \class{application} classes are usually derived 
directly from \argument{application}.)  Note that after calling 
\class{application}::\virtualmemberfunction{ParseArgs} the \argument{argc} 
value may be out of sync with the actual number of arguments left in 
\argument{argv}.  (Since 
\class{application}::\virtualmemberfunction{ParseArgs} deletes the 
arguments it handles.)  The following flags are handled by 
\class{application}::\virtualmemberfunction{ParseArgs}:


\indent{-appname name

Overrides the application/program name.


-bg backgroundcolor

Sets the default background color.


-d

Causes the application to stay in the foreground instead of forking as is 
normal for ATK applications.


-display host:0.0

Sets the default display for the applications windows.  The syntax shown 
here (host:0.0) is for X, other window systems may use other formats.


-fl

Force loading of init files even if some errors occur.


-fg foregroundcolor

Sets the default foreground color.


-geometry widthxheight+left+top

Sets the default geometry for the initial windows.  The syntax shown here 
is for X, other window systems may use other formats.


-host host:0.0

An alias for -display.


-iconic

Specifies that the initial windows should be iconified on startup.


-iconicoff

Specifies that the initial windows should not be iconified on startup. 
 (The default, unless the StartIconic preference is set to yes.)


-ni

Disables all init-files so that only the built in bindings for keys, menus 
and filetypes are available.


-pref preference:value

Sets or overrides a preference value, any value specified in a preference 
file will be ignored if there was a -pref switch for the preference on the 
command line.

}
	\


\keyword{\type{void}} 
\class{application}::\virtualmemberfunction{ReadInitFile}();

\virtualmemberfunction{ReadInitFile} parses the appropriate initfiles, 
unless \class{application}::\virtualmemberfunction{ParseArgs} found the -ni 
switch specified on the command line.


There are many possibilities for what initfiles will be loaded.  First 
\class{environ}::\staticmemberfunction{GetConfiguration}("SiteConfigName") 
will be used to form the names: $ANDREWDIR/lib/<sitename>.atkinit and 
$ANDREWDIR/lib/<sitename>.<appname>init.  If either of these files are 
found they will be loaded.  Then if there is a .<appname>init file in the 
user's home directory that file will be loaded and no others will be 
examined.  Otherwise 
\class{envrion}::\staticmemberfunction{GetConfiguration}("LocalLib") will 
be consulted to find a colon separated list of path names to be checked for 
a global.<appname>init file.  The first such file found in that list of 
paths will be loaded.  If no such file is found 
$ANDREWDIR/lib/global.<appname>init will be loaded if it exists.  Then 
.atkinit or .be2init files (if any) in the user's home directory will be 
loaded.  If no global.<appname>init file has been found at this point and 
the "LocalLib" configuration variable was not a path list, but just a 
single directory that directory will be checked for a global.atkinit. 
 Otherwise $ANDREWDIR/lib/global.atkinit is loaded if it exists.


\type{boolean} \class{application}::\virtualmemberfunction{Start}();

After the arguments have been parsed and any initfiles read, 
\virtualmemberfunction{Start}() will be called to do any initialization 
needed before \virtualmemberfunction{Run}() is invoked.

\keyword{
\type{int}} \class{application}::\virtualmemberfunction{Run}();

\virtualmemberfunction{Run}() will be called to perform the main loop or 
other processing of the application.  The value returned from 
\virtualmemberfunction{Run}() will typically be passed to exit() after the 
\virtualmemberfunction{Stop}() method has been called.

\keyword{
\type{void}} \class{application}::\virtualmemberfunction{Stop}();

Once the \virtualmemberfunction{Run}() has finished 
\virtualmemberfunction{Stop}() will be called to perform any necessary 
cleanup.


\type{boolean} \class{application}::\virtualmemberfunction{Fork}();

Unless \memberfunction{SetFork}(\constant{FALSE}) has been called or 
\virtualmemberfunction{Fork}() has been called once already this function 
will fork, giving the command prompt back to the user.


\keyword{\type{void}} 
\class{application}::\virtualmemberfunction{PrintVersionNumber}();

Prints the version number of the application and the program, unless the 
PrintVersionNumber preference is set to no.  The version number will also 
not be printed if \memberfunction{SetPrintVersionFlag}(\constant{FALSE}) 
was called.


\keyword{\type{void}} 
\class{application}::\memberfunction{SetFork}(\type{boolean} 
\argument{torf});

boolean GetFork();

If \argument{torf} is \constant{TRUE} the application will fork when 
\virtualmemberfunction{Fork}() is called.  (The default implementation of 
\virtualmemberfunction{Run}() calls \virtualmemberfunction{Fork}() just 
before entering the loop that updates windows and accepts input.) 
 Otherwise the application will not fork.

\keyword{
\type{void}} 
\class{application}::\memberfunction{SetName}(\type{\keyword{char} 
*}\argument{name});

Sets the application \argument{name}.  Note that \argument{name} must be 
allocated for the lifetime of the \classobject{application} object.  (Or 
longer of course.)

\keyword{
}\type{\keyword{char} *}\class{application}::\memberfunction{GetName}();

Returns the name previously set by \memberfunction{SetName}, or 
\constant{NULL} if \memberfunction{SetName} has not been called.  The 
pointer returned is the same pointer passed in to \staticdatamember{SetName}.


\keyword{\type{void}} 
\class{application}::\memberfunction{SetForceLoad}(\type{boolean} 
\argument{torf});

By default any classes referenced in initfiles are only loaded as needed. 
 If \memberfunction{SetForceLoad}(\constant{TRUE}) is called on the 
application \virtualmemberfunction{ReadInitFile} will force all the 
referenced classes to be loaded immediately.


\type{boolean} \class{application}::\memberfunction{GetForceLoad}();

Returns the current setting for whether \virtualmemberfunction{ReadInitFile} 
will force all the classes referenced in the initfiles to be loaded.


\keyword{\type{void}} 
\class{application}::\memberfunction{SetErrorProc}(\type{init_fptr} 
\argument{p});

	\keyword{typedef} \keyword{\type{void}} 
(*\type{init_fptr})(\keyword{\type{long}} \argument{rock}, 
\type{\keyword{char} *}\argument{buf});

Sets the function to be executed to report errors encountered while 
\virtualmemberfunction{ReadInitFile} is reading the initfiles.  Use 
\memberfunction{SetErrorRock} to set the \argument{rock} to be passed in, 
\argument{buf} will be a NUL terminated string describing the error. 
 \argument{p} must be non-\constant{NULL}.


\type{init_fptr} \class{application}::GetErrorProc();

Returns the function which will be used to report errors while 
\virtualmemberfunction{ReadInitFile} is reading the initfiles.


\keyword{\type{void}} 
\class{application}::\memberfunction{SetErrorRock}(\keyword{long} r);

Sets the rock (\argument{r}) to be passed to the error function when an 
error is encountered while \virtualmemberfunction{ReadInitFile} is reading 
the initfiles.


\keyword{\type{long}} \class{application}::\memberfunction{GetErrorRock}();

Returns the rock which will be passed to the error function when an error 
is encountered while \virtualmemberfunction{ReadInitFile} is reading the 
initfiles.


\keyword{\type{void}} 
\class{application}::\memberfunction{SetMajorVersion}(\keyword{\type{long}} 
\argument{mv});

Sets the major version number of the application which will be reported 
when \virtualmemberfunction{PrintVersionNumber} is called.  This should be 
called in the constructor for any class derived from \class{application}.


\keyword{\type{long}} 
\class{application}::\memberfunction{GetMajorVersion}();

Returns the major version number of the application.


\keyword{\type{void}} 
\class{application}::\memberfunction{SetMinorVersion}(\keyword{\type{long}} 
\argument{mv});

Sets the minor version number of the application which will be reported 
when \virtualmemberfunction{PrintVersionNumber} is called.  This should be 
called in the constructor for any class derived from \class{application}.


\keyword{\type{long}} 
\class{application}::\memberfunction{GetMinorVersion}();

Returns the minor version number of the application.


\type{v\keyword{oid}} 
\class{application}::\memberfunction{SetPrintVersionFlag}(\type{boolean} 
\argument{TorF});

If \argument{TorF} is \constant{TRUE} the application and ATK version 
numbers will be printed when the application is run.


\type{boolean} \class{application}::\memberfunction{GetPrintVersionFlag}();

Returns \constant{TRUE} if the application and ATK version numbers should 
be printed when the application is run.


\keyword{\type{void}} 
\class{application}::\memberfunction{SetIconic}(\type{boolean} 
\argument{val});

If \argument{val} is \constant{TRUE} any application windows will start out 
iconified.   Otherwise they should appear normally.  (This is only 
supported under X.)


\type{boolean}   \class{application}::\memberfunction{GetIconic}();

Returns \constant{TRUE} if the application's windows should start out 
iconified.  Otherwise they should appear normally.

 \keyword{\


\type{void}} 
\class{application}::\staticmemberfunction{DeleteArgs}(\type{\keyword{char} 
**}\argument{argv}, \keyword{\type{int}} \argument{num});

Deletes \argument{num} arguments at \argument{argv}.  The pointers to the 
deleted arguments are lost.


\type{\keyword{char} 
*}\class{application}::\staticmemberfunction{GetATKVersion}();

Returns a string describing the version of ATK being run.  This string is 
valid for the duration of the process.

  \


\section{10.7	event}

\section{10.8	completion}

\section{10.9	printing}

\section{10.10	label}

\section{10.11	sbutton}


\section{10.12	text}


Text is a dataobject which is designed to store and manipulate styled 8-bit 
text.  The text class is actually derived from simpletext.  Simpletext 
implements plain unstyled 8-bit text.


\subsection{10.12.1	Header Files} \


text.H, simpletext.H


\subsection{10.12.2	Simpletext}

\type{long} \class{simpletext}::\virtualmemberfunction{Read}(\type{FILE 
*}\argument{file}, \type{long} \argument{id});

Reads in data in ATK datastream format into the text.  See dataobject::Read.


\type{long} \class{simpletext}::\virtualmemberfunction{Write}(\type{FILE 
*}\argument{file}, \type{long} \argument{writeid}, \type{int} 
\argument{level});

Writes the text in ATK datastream format.  See dataobject::Write.


\type{void} 
\class{simpletext}::\virtualmemberfunction{SetAttributes}(\type{struct 
attributes *}\argument{attrs});

See dataobject::SetAttributes.  Simpletext recognizes three attributes:


\indent{\typewriter{key:filesize	type:integer	values:any

}The size of the file from which data will be read.\typewriter{

key:readonly	type:integer	values:\constant{TRUE}/\constant{FALSE}

}\constant{TRUE} if the file from which data will be read is read only, 
otherwise \constant{FALSE}.

\typewriter{key:write-for-DOS	type:string	values:1/0

}1 if the data should be written out in DOS format, 0 otherwise.}


\paragraph{10.12.2.1	Control Methods}


\keyword{\type{long}} \class{simpletext}::\memberfunction{GetFence}();

Returns the position of the 'fence'.  The position of the fence is the 
position of the first modifiable character in the document.  All subsequent 
characters after that character are also modifiable.


\type{\class{mark} *}\class{simpletext}::\memberfunction{GetFenceMark}();

Returns the mark representing the fenced area of the document.


\type{\type{boolean}} 
\class{simpletext}::\memberfunction{GetObjectInsertionFlag}();

Returns \constant{TRUE} if the document should allow object insertions, and 
\constant{FALSE} otherwise.


\keyword{\type{void}} 
\class{simpletext}::\memberfunction{SetFence}(\keyword{\type{\type{long}}} 
\argument{pos}); \


Sets the position of the fence.  See 
\class{simpletext}::\memberfunction{GetFence}.


\keyword{\type{void}} \class{simpletext}::\memberfunction{ClearFence}();

Sets the fence to 0.  (The first character in the document.)  See 
\class{simpletext}::\memberfunction{GetFence}.


\keyword{\type{void}} 
\class{simpletext}::\memberfunction{SetObjectInsertionFlag}(\type{boolean} 
\argument{flag}); \


If \argument{flag} is \constant{TRUE} object insertion will be allowed 
otherwise objects will not be inserted.


\type{\class{mark} 
*}\localvariable{simpletext}::\virtualmemberfunction{CreateMark}(\type{long} 
\argument{pos}, \type{long} \argument{len});

Creates a \classobject{mark} for the \argument{len} characters at 
\argument{pos}.  The \classobject{mark} can then be used to find the length 
and position of the region after a series of modifications, as well as 
testing whether any of the modifications changed the text to which it 
refers.  See the section on the \class{mark} class, or atk/support/mark.H 
and mark.C.


\type{void} 
\class{simpletext}::\virtualmemberfunction{RemoveMark}(\type{\class{mark} 
*}\argument{m});

Before a \classobject{mark} is deleted this method must be called to remove 
it from the list maintained by the text.


\type{void} 
\class{simpletext}::\virtualmemberfunction{SetReadOnly}(\type{boolean} 
\argument{readOnly});

If \argument{readOnly} is \constant{TRUE} the fence is set to one past the 
last character in the text, so that none of the non-Always methods will 
modify the text.  If \argument{readOnly} is \constant{FALSE} the fence is 
set to the first character in the text.


\type{boolean} \class{simpletext}::\virtualmemberfunction{GetReadOnly}();

Returns \constant{TRUE} if the text cannot be modified. (Except by the 
Always*methods.)  Otherwise it returns \constant{FALSE}.


\type{void} 
\class{simpletext}::\virtualmemberfunction{RegionModified}(\type{long} 
\argument{pos}, \type{long} \argument{len});

Marks any \classobject{mark} objects referring to text intersecting the 
region from \argument{pos} to \argument{pos}+\argument{len}-1 as modified. 
 This is usually only called by \class{simpletext} or \class{text}.


\type{void} 
\class{simpletext}::\virtualmemberfunction{LengthChanged}(\type{long} 
\argument{pos}, \type{long} \argument{len});

Updates the position and length of all marks which are affected by the 
insertion of \argument{len} characters at \argument{pos}.  \argument{len} 
may be negative denoting that characters were deleted.  This is usually 
only called by \class{simpletext} or \class{text}.


\paragraph{10.12.2.2	Modification Methods}


\type{void} \class{simpletext}::\virtualmemberfunction{Clear}();

Removes all text from the object.


\keyword{\type{void}} 
\class{simpletext}::AlwaysInsertCharacters(\keyword{\type{long}} 
\argument{pos}, \type{\keyword{char} *}\argument{str}, \keyword{\type{long}} 
\argument{len});

Inserts \argument{len} characters from \argument{str} before the character 
at the given \argument{pos}.


boolean \class{simpletext}::InsertCharacters(\keyword{\type{long}} 
\argument{pos}, \type{\keyword{char} *}\argument{str}, \keyword{\type{long}} 
\argument{len});

Checks if the given \argument{pos} is within the readonly portion of the 
object, if so it returns \constant{FALSE}.  Otherwise it calls 
\virtualmemberfunction{AlwaysInsertCharacters} and returns \constant{TRUE}.


\keyword{\type{void}} 
\class{simpletext}::\virtualmemberfunction{AlwaysDeleteCharacters}(\
\keyword{\type{long}} \argument{pos}, \keyword{\type{long}} \argument{len});

Deletes \argument{len} characters at the given \argument{\argument{pos}}.


boolean 
\class{simpletext}::\virtualmemberfunction{DeleteCharacters}(\keyword{\
\type{long}} \argument{pos}, \keyword{\type{long}} \argument{len});

Checks if the given \argument{pos} is within the readonly portion of the 
object, if so it returns \constant{FALSE}.  Otherwise it calls 
\virtualmemberfunction{AlwaysDeleteCharacters} and returns \constant{TRUE}.


\keyword{void} 
\class{simpletext}::\virtualmemberfunction{AlwaysReplaceCharacters}(\
\keyword{\type{long}} \argument{pos}, \keyword{\type{long}} \argument{len}, 
\type{\keyword{char} *}\argument{repStr}, \keyword{\type{long}} 
\argument{repLen});

Replaces the \argument{len} characters at \argument{pos} with 
\argument{repLen} characters from \argument{repStr}.


\type{boolean} 
\class{simpletext}::\virtualmemberfunction{ReplaceCharacters}(\keyword{\
\type{long}} \argument{pos}, \keyword{\type{long}} \argument{len}, 
\type{\keyword{char} *}\argument{repStr}, \keyword{\type{long}} 
repLen);Checks if the given \argument{pos} is within the readonly portion 
of the object, if so it returns \constant{FALSE}.  Otherwise it calls 
\virtualmemberfunction{AlwaysReplaceCharacters} and returns \constant{TRUE}.


\keyword{void} 
\class{simpletext}::\virtualmemberfunction{AlwaysCopyText}(\keyword{\type{lo\
ng}} \argument{pos}, \type{\class{simpletext} *}\argument{srctext}, 
\keyword{\type{long}} \argument{srcpos}, \keyword{\type{long}} 
\argument{len});

Copies \argument{len} characters starting at \argument{srcpos} from 
\argument{srctext} to \argument{pos} in this text.


\type{boolean} 
\class{simpletext}::\virtualmemberfunction{CopyText}(\keyword{\type{long}} 
\argument{pos}, \type{\class{simpletext} *}\argument{srctext}, 
\keyword{\type{long}} \argument{srcpos}, \keyword{\type{long}} 
\argument{len});

Checks if the given \argument{pos} is within the readonly portion of the 
object, if so it returns \constant{FALSE}.  Otherwise it calls 
\virtualmemberfunction{AlwaysCopyText} and returns \constant{TRUE}.


\keyword{void} 
\class{simpletext}::\virtualmemberfunction{AlwaysCopyTextExactly}(\keyword{\
\type{long}} \argument{pos}, \type{\class{simpletext} *}\argument{srctext}, 
\keyword{\type{long}} \argument{srcpos}, \keyword{\type{long}} 
\argument{len});

Copies \argument{len} characters starting at \argument{srcpos} from 
\argument{srctext} to \argument{pos} in this text.  This may be overridden 
in derived classes to preserve more information.  (e.g. all the styles 
surrounding the region being copied, as in text.)


\type{boolean} 
\class{simpletext}::\virtualmemberfunction{CopyTextExactly}(\keyword{\type{l\
ong}} \argument{pos}, \type{\class{simpletext} *}\argument{srctext}, 
\keyword{\type{long}} \argument{srcpos}, \keyword{\type{long}} 
\argument{len});

Checks if the given \argument{pos} is within the readonly portion of the 
object, if so it returns \constant{FALSE}.  Otherwise it calls 
\virtualmemberfunction{AlwaysCopyTextExactly} and returns \constant{TRUE}.


\type{\keyword{char} 
*}\class{simpletext}::\virtualmemberfunction{GetGap}(\keyword{\type{long}} 
\argument{pos}, \keyword{\type{long}} \argument{len});

Inserts \argument{len} contiguous bytes at \argument{pos}, and returns a 
pointer to the first byte.


\paragraph{Access Methods}

\keyword{\type{long}} 
\class{simpletext}::\virtualmemberfunction{GetLength}();

Returns the number of characters in the document.


\keyword{\type{long}} 
\class{simpletext}::\virtualmemberfunction{GetChar}(\keyword{\type{long}} 
\argument{pos});

Returns the character at the given position in the document.  Characters 
over 127 may be negative on some architectures.  If the position is outside 
the range of the doucment \constant{EOF} is returned.


\keyword{\type{long}} 
\class{simpletext}::\virtualmemberfunction{GetUnsignedChar}(\keyword{\type{l\
ong}} \argument{pos});

Returns the character at the given position in the document.  No sign 
extentension will occur.  If the position is outside the range of the 
document \constant{EOF }will be returned.


\type{\keyword{char} 
*}\class{simpletext}::\virtualmemberfunction{GetBuf}(\keyword{\type{long}} 
\argument{pos}, \keyword{\type{long}} \argument{len}, \type{long 
*l}\argument{enp});

Returns a pointer to a buffer of at most \argument{len} characters 
beginning at \argument{pos}.  *\argument{lenp} will be filled in with the 
actual length of the buffer returned.


\type{\keyword{char} 
*}\class{simpletext}::\virtualmemberfunction{GetBufEnd}(\keyword{\type{long}} 
\argument{endpos}, \keyword{\type{long}} \argument{len}, \type{long 
*l}\argument{enp});

Returns a pointer to a buffer of at most \argument{len} characters ending 
at \argument{pos}.  *\argument{lenp} will be filled in with the actual 
length of the buffer returned.


\keyword{\type{long}} 
\class{simpletext}::\virtualmemberfunction{GetPosForLine}(\keyword{\type{lon\
g}} \argument{line});

Returns the position of the first character on the indicated \argument{line}.


\keyword{\type{long}} 
\class{simpletext}::\virtualmemberfunction{GetLineForPos}(\keyword{\type{lon\
g}} \argument{pos});

Returns the line number containing \argument{pos}.


\keyword{\type{long}} 
\class{simpletext}::\virtualmemberfunction{GetBeginningOfLine}(\keyword{\
\type{long}} \argument{pos});

Returns the position of the first character on the line containing 
\argument{pos}.


\keyword{\type{long}} 
\class{simpletext}::\virtualmemberfunction{GetEndOfLine}(\keyword{\type{long\
}} \argument{pos});

Returns the last character on the line containing \argument{pos}.


\keyword{\type{long}} 
\class{simpletext}::\virtualmemberfunction{Index}(\keyword{\type{long}} 
\argument{pos}, \keyword{\type{char}} \argument{c}, \keyword{\type{long}} 
\argument{len});

Returns the first occurrence of the character \argument{c} starting at 
\argument{pos} and searching \argument{len} characters.  If no occurrence 
is found \constant{EOF} is returned.


\type{int} 
\class{simpletext}::\virtualmemberfunction{Strncmp}(\keyword{\type{long}} 
\argument{pos}, \type{\keyword{char} *}\argument{str}, \keyword{\type{long}} 
\argument{len});

Compares the \argument{len} characters at \argument{pos} to the 
\argument{str}.  If they differ the difference between the first mismatched 
character in the document and the corresponding character in the string is 
returned.  Otherwise 0 is returned.


\keyword{\type{int}} 
\class{simpletext}::\virtualmemberfunction{Textncmp}(\keyword{\type{long}} 
\argument{pos}, \type{\class{simpletext} *}\argument{text}, 
\keyword{\type{long}} \argument{pos2}, \keyword{\type{long}} 
\argument{len});

Compares the \argument{len} characters at \argument{pos} to the 
\argument{len} characters at \argument{pos2} in \argument{text}.  If they 
differ the difference between the first mismatched character in the 
document and the corresponding character in the \argument{text} is 
returned.  Otherwise 0 is returned.


\type{boolean} \class{simpletext}::\virtualmemberfunction{CheckHighBit}();

Returns \constant{TRUE} if the document has any characters with codes 
larger than 127, otherwise it returns \constant{FALSE}.\keyword{


void} 
\class{simpletext}::\virtualmemberfunction{CopySubString}(\keyword{\type{lon\
g}} \argument{pos}, \keyword{\type{long}} \argument{len}, 
\type{\keyword{char} *}\argument{buf}, \type{boolean} 
\argument{quoteCharacters});

Copies \argument{len} characters from \argument{pos} into the provided 
buffer \argument{buf}.  The buffer must be at least \argument{len} 
characters long.  If quoteCharacters is \constant{TRUE} any '\\', '\{', 
'\}' characters will be prefixed by a '\\'.


\paragraph{Input/Output Methods}

\keyword{\type{long}} 
\class{simpletext}::\virtualmemberfunction{ReadSubString}(\keyword{\type{lon\
g}} \argument{pos}, \type{FILE *}\argument{file}, \type{boolean} 
\argument{quoteCharacters});

Reads the text object in \argument{file} and inserts its contents at 
\argument{pos}.  If quoteCharacters is \constant{TRUE} ATK datastream 
conventions will be followed.  Otherwise the file will be inserted as plain 
text.


\keyword{void} 
\class{simpletext}::\virtualmemberfunction{WriteSubString}(\keyword{\type{lo\
ng}} \argument{pos}, \keyword{\type{long}} \argument{len}, \type{FILE 
*}\argument{file}, \type{boolean} \argument{quoteCharacters});

Writes the \argument{len} characters at \argument{pos} to \argument{file}. 
 If \argument{quoteCharacters} is \constant{TRUE} ATK datastream 
conventions will be followed.  Otherwise the characters will be written 
without interpretation.


\keyword{\type{long}} 
\class{simpletext}::\virtualmemberfunction{HandleDataObject}(\keyword{\
\type{long}} \argument{pos}, \class{dataobject} *\argument{dop}, \type{FILE 
*}\argument{file});

\keyword{\type{long}} 
\class{simpletext}::\virtualmemberfunction{HandleKeyWord}(\keyword{\type{lon\
g}} \argument{pos}, \type{char *}\argument{keyword}, \type{FILE 
*}\argument{file});

\keyword{\type{long}} 
\class{simpletext}::\virtualmemberfunction{HandleCloseBrace}(\keyword{\
\type{long}} \argument{pos}, \type{FILE *}\argument{file});

\keyword{\type{long}} 
\class{simpletext}::\virtualmemberfunction{HandleBegindata}(\keyword{\type{l\
ong}} \argument{pos}, \type{FILE *}\argument{file});

These methods are used by the Read and ReadSubString methods to handle ATK 
datastream style markup.  Usually these will not be used or overridden.


\subsection{10.12.3	Text}


\type{void} 
\class{text}::\virtualmemberfunction{SetAttributes}(\type{struct attributes 
*}\argument{attrs});

See dataobject::SetAttributes and simpletext::SetAttributes.  Text 
recognizes two attributes:


\indent{\typewriter{key:template	type:string		values:any

}The name or pathname of a template file.\typewriter{

key:datastream	type:string	values:yes/no

"yes" if the file text should be written out in datastream format, "no" 
otherwise.


}}
\type{\class{viewref} 
*}\class{text}::\virtualmemberfunction{\virtualmemberfunction{InsertObject}}(\
\keyword{\type{long}} \argument{pos}, \type{\keyword{char} 
*}\argument{name},\type{\keyword{char} *}\argument{viewname});

Checks to see if pos is modifiable if it is a \classobject{dataobject} of 
type \argument{name} is inserted at \argument{pos}, with a view of type 
\argument{viewname}.  Otherwise \constant{NULL} is returned.  If 
\argument{viewname} is \constant{NULL} the default \class{view} for the 
\classobject{dataobject} will be used.  If the appropriate type of 
\classobject{dataobject} or \classobject{view} could not be created 
\constant{NULL} is returned, otherwise a pointer to the 
\classobject{viewref} representing the \classobject{view} is returned.

  \


\type{\class{environment} 
*}\class{text}::\virtualmemberfunction{\virtualmemberfunction{\
\virtualmemberfunction{AlwaysAddStyle}}}(\keyword{\type{long}} 
\argument{pos}, \keyword{\type{long}} \argument{len}, \type{\class{style} 
*}\argument{style}); \


Adds a \argument{style} encompassing \argument{len} characters at 
\argument{pos}.  XXX Need to discuss the way styles nest, and the 
includebeginning/includending hacks.


\type{\class{environment} 
*}\class{text}::\virtualmemberfunction{\virtualmemberfunction{\
\virtualmemberfunction{AddStyle}}}(\keyword{\type{long}} \argument{pos}, 
\keyword{\type{long}} \argument{len}, \type{\class{style} 
*}\argument{style}); \


Checks if the \argument{pos} is modifiable (See Get/SetReadOnly, and 
simpletext::GetFence) if it is then \virtualmemberfunction{AlwaysAddStyle} 
is called and the result of that call is returned.  Otherwise 
\constant{NULL} is returned.


\type{\class{environment} 
*}\class{text}::\virtualmemberfunction{AlwaysAddView}(\keyword{\type{long}} 
\argument{pos}, \type{\keyword{char} *}\argument{viewtype}, 
\type{\class{dataobject} *}\argument{dataobject});

Adds a \classobject{view} on the \argument{dataobject} at pos. 
 \argument{viewtype} must be the name of a \class{view} class suitable for 
displaying the \classobject{dataobject}.


\type{\class{environment} 
*}\class{text}::\virtualmemberfunction{AddView}(\keyword{\type{long}} 
\argument{pos}, \type{\keyword{char} *}\argument{viewtype}, 
\type{\class{dataobject} *}\argument{dataobject});

Checks if the \argument{pos} is modifiable (See Get/SetReadOnly, and 
simpletext::GetFence) if it is then \virtualmemberfunction{AlwaysAddView} 
is called and the result of that call is returned.  Otherwise 
\constant{NULL} is returned.


\keyword{void} 
\class{text}::\virtualmemberfunction{SetEnvironmentStyle}(\type{\class{envir\
onment} *}\argument{envptr}, \type{\class{style} *}\argument{styleptr});

Sets the \classobject{style} referenced by the \classobject{environment} 
\argument{envptr } to \argument{styleptr}.  All \classobject{marks} in the 
region covered by the \classobject{environment} are marked as modified.


\keyword{void} 
\class{text}::\virtualmemberfunction{SetGlobalStyle}(\type{\class{style} 
*}\argument{styleptr});

Sets the \classobject{style} in the top-level \classobject{environment} to 
\argument{styleptr}.  Alls \classobject{marks} on the text are marked as 
modified.


\type{\class{style} 
*}\class{text}::\virtualmemberfunction{GetGlobalStyle}();

Returns the \classobject{style} in the top-level \classobject{environment}.


\keyword{\type{long}} 
\class{text}::\virtualmemberfunction{ReadTemplate}(\type{\keyword{char} 
*}\argument{templateName}, \type{boolean} \argument{inserttemplatetext});

Reads the template called \argument{templateName} and if 
\argument{inserttemplatetext} is \constant{TRUE} and the text member 
\argument{pendingReadOnly} is \constant{FALSE} then any text in the 
template will be read into the text object.  If the template has not been 
read previously and \argument{templateName} begins with a '/' it will be 
used as a pathname to locate the template file.  Otherwise the environment 
variable TEMPLATEPATH, or the preferences ATKTemplatePath or 
BE2TemplatePath will be used as colon separated paths to locate 
\argument{templateName}.tpl or \argument{templateName}.template.  If none 
of those are set $ANDREWDIR/lib/tpls and $ANDREWDIR/lib/templates will be 
searched.   XXX need to document the format and meaning of template files.


\type{\class{viewref} 
*}\class{text}::\virtualmemberfunction{FindViewreference}(\keyword{\type{lon\
g}} \argument{pos}, \keyword{\type{long}} \argument{len});

Searches the text between \argument{pos} and 
\argument{pos}+\argument{len}-1 inclusive for the first 
\classobject{viewref}. (A \classobject{viewref} represents a 
\classobject{view} on a \classobject{dataobject}.)  If found it returns the 
\classobject{viewref} otherwise \constant{NULL} is returned.


\keyword{\type{long}} 
\class{text}::\virtualmemberfunction{AlwaysInsertFile}(\type{FILE 
*}\argument{file},\type{\keyword{char} *}\argument{filename}, 
\keyword{\type{long}} \argument{pos});

The file represented by either \argument{file} or \argument{filename} is 
inserted in the text at \argument{pos}.  If the file represents a non-text 
\classobject{dataobject} the object is inserted as an inset.  The unsed 
argument of the \argument{file}, \argument{filename} pair must be 
\constant{NULL}.


\keyword{\type{long}} 
\class{text}::\virtualmemberfunction{InsertFile}(\type{FILE 
*}\argument{file},\type{\keyword{char} *}\argument{filename}, 
\keyword{\type{long}} \argument{pos});

Checks if the \argument{pos} is modifiable (See Get/SetReadOnly, and 
simpletext::GetFence) if it is then \virtualmemberfunction{AlwaysInsertFile} 
is called and the result of that call is returned.  Otherwise 0 is returned.


\keyword{void} \class{text}::\virtualmemberfunction{Clear}();

Clears all text from the text object and frees all 
\classobject{dataobjects}, \classobject{views}, \classobject{viewrefs}, 
\classobject{styles}, and \classobject{environments}.  In the future 
\virtualmemberfunction{Clear} might be updated to leave any 
\classobject{styles} defined in the document.  If that change is made 
\virtualmemberfunction{ClearCompletely} will still remove those styles.


\keyword{void} \class{text}::\virtualmemberfunction{ClearCompletely}();

Currently a synonym for \virtualmemberfunction{Clear}.

  \


See \class{text}::\virtualmemberfunction{Clear}();

\type{\class{environment} 
*}\class{text}::\virtualmemberfunction{EnumerateEnvironments}(\keyword{\
\type{long}} \argument{pos},\keyword{\type{long}} 
\argument{len},\type{text_eefptr} \argument{callBack},\keyword{\type{long}} 
\argument{rock});

\keyword{typedef} \type{boolean} (*\type{text_eefptr})(\keyword{\type{long}} 
\argument{rock}, \type{\class{text} *}\argument{self}, \keyword{\type{long}} 
\argument{pos}, \argument{\class{environment} *}\argument{curenv});

Calls the \argument{callBack} function on every \classobject{environment} 
found within \argument{pos} and \argument{pos}+\argument{len}-1 inclusive. 
 If \argument{callBack} returns \constant{TRUE} the \classobject{curenv} 
passed into it will be returned from 
\virtualmemberfunction{EnumerateEnvironments}.  If no call to 
\argument{callBack} returns \constant{TRUE} then \constant{NULL} will be 
returned from \virtualmemberfunction{EnumerateEnvironments}. 
 \argument{callBack} will be called with the \argument{rock}, the 
\classobject{text}, the \argument{pos} where the \classobject{environment} 
begins, and the \classobject{environment} itself in \argument{curenv}.


\keyword{void} 
\class{text}::\virtualmemberfunction{SetBaseTemplateName}(\type{\keyword{cha\
r} *}\argument{name});

Sets the \argument{name} of the template to be read in before the text when 
\class{text}::\virtualmemberfunction{Read} is called.


\type{\class{environment} 
*}\class{text}::\virtualmemberfunction{AlwaysWrapViewChar}(\keyword{\type{lo\
ng}} \argument{pos}, \type{\keyword{char} *}\argument{name}, 
\type{\class{dataobject} *}\argument{dobj});

Assumes the character at pos is a \constant{TEXT_VIEWREFCHAR} ('\\377'), 
and wraps an \classobject{environment} around \argument{pos} indicating 
that a view of type \argument{name} should be presented there for 
\argument{dobj}.


\keyword{void} 
\class{text}::\virtualmemberfunction{AlwaysCopyTextExactly}(\keyword{\type{l\
ong}} \argument{pos}, \type{\class{text} *}\argument{srctext}, 
\keyword{\type{long}} \argument{srcpos}, \keyword{\type{long}} 
\argument{len});

Copies \argument{len} characters starting at \argument{srcpos} from 
\argument{srctext} to \argument{pos} in this text.  This may be overridden 
in derived classes to preserve more information.  All the styles 
surrounding and within the region being copied are placed in the copied 
text as well.


\type{boolean} 
\class{text}::\virtualmemberfunction{CopyTextExactly}(\keyword{\type{long}} 
\argument{pos}, \type{\class{text} *}\argument{srctext}, 
\keyword{\type{long}} \argument{srcpos}, \keyword{\type{long}} 
\argument{len});

Checks if the given \argument{pos} is within the readonly portion of the 
object, if so it returns \constant{FALSE}.  Otherwise it calls 
\virtualmemberfunction{AlwaysCopyTextExactly} and returns \constant{TRUE}.


\keyword{void} 
\class{text}::\memberfunction{SetExportEnvironments}(\type{boolean} 
\argument{val});

If \argument{val} is \constant{TRUE} the text will write out any styles or 
views when \class{text}::\virtualmemberfunction{Write} is called.  (This is 
the default behavior.) Otherwise only plain text will be written by 
\class{text}::\virtualmemberfunction{Write}.


\type{boolean} \class{text}::\memberfunction{GetExportEnvironments}();

Returns \constant{TRUE} if \class{text}::\virtualmemberfunction{Write} will 
preserve \classobject{styles} and \classobject{views}, otherwise 
\constant{FALSE}.


\type{stylesheet *}\class{text}::\memberfunction{GetStyleSheet}();

Returns the \classobject{stylesheet} defining the \class{styles} used.


\keyword{void} \class{text}::\memberfunction{SetWriteAsText}(\type{boolean} 
\argument{TorF});

If \argument{TorF} is \constant{TRUE} 
\class{text}::\virtualmemberfunction{Write} will write the object as text 
even if it is actually of a derived class.  If \argument{TorF} is 
\constant{FALSE} \class{text}::\virtualmemberfunction{Write} will write the 
object as whatever class it actually is.  (This is the default.)


\type{boolean} \class{text}::\memberfunction{GetWriteAsText}();

Returns the last setting made with \memberfunction{SetWriteAsText}.


\keyword{\type{void}} 
\class{text}::\memberfunction{SetCopyAsText}(\type{boolean} 
\argument{TorF});

If \argument{TorF} is \constant{TRUE} some clients of \class{text} who 
write out all or part of the text will know to write it as a \class{text} 
object even if it is actually of a derived class.  If \constant{FALSE} they 
will write it as whatever class it is.


\type{\type{boolean}} \class{text}::\memberfunction{GetCopyAsText}();

Returns the last setting made with \memberfunction{SetCopyAsText}.


\keyword{void} \class{text}::\memberfunction{SetWriteStyle}(\keyword{enum} 
textwritestyle \argument{style});

\argument{style} must be one of \constant{text_DefaultWrite}, 
\constant{text_NoDataStream}, or \constant{text_DataStream}.  If 
\argument{style} is \constant{text_NoDataStream }then 
\class{text}::\virtualmemberfunction{Write} will never put out ATK 
datastream for this object.  If \argument{style} is 
\constant{text_DataStream} then \class{text}::\virtualmemberfunction{Write} 
will always put out ATK datastream for this object.  If style is 
text_DefaultWrite (the default)  ATK datastream will be written if there 
are any \classobject{styles} used or defined, or any \classobject{views}, 
or if the text begins with \\begindata.


textwritestyle \class{text}::\memberfunction{GetWriteStyle}();

Returns the last setting made with \memberfunction{SetWriteStyle}.


\type{\keyword{char} 
 *}\class{text}::\memberfunction{GetBaseTemplateName}();

Returns the name of the template to be read in when 
\class{text}::\virtualmemberfunction{Read} is called.


\subsection{10.12.4	Textview}


(this section is incomplete, but it should cover everything generally needed

by application programmers.)


\type{\class{view} 
*}\class{textview}::\virtualmemberfunction{GetApplicationLayer}();

Returns a \class{scroll} view.  If the preference ScrollBarPosition is 
"right" or the MotifScrollbars preference is "yes" then the scrollbar will 
be on the right.  If the preference TextHorizontalScrollbar is 
\constant{TRUE} there will be a horizontal scrollbar.


\keyword{\type{void}} 
\class{textview}::\virtualmemberfunction{DeleteApplicationLayer}(\type{\
\class{view} *}\type{scrollbar});

Deletes the \argument{scrollbar} and marks the \classobject{textview} to 
indicate that it no longer has an application layer.


\keyword{\type{long}} \class{textview}::WriteSelection(\type{FILE 
*}\type{out});

Writes the currently selected text to \argument{out}.  The text will be in 
datastream format if any styles begin or end within the selected text, or 
if the range contains insets.  If \virtualmemberfunction{GetCopyAsText}() 
on the text is \constant{TRUE} the datastream will be written as a text 
object, otherwise it will be written as whatever type it actually is.


\type{boolean} \class{textview}::RecSearch(\type{\keyword{struct} 
SearchPattern *}\type{pat}, \type{boolean} \type{toplevel});

Searches for \argument{pat} in the text and any embedded objects.   See 
\class{view}::\virtualmemberfunction{RecSearch}.


\type{boolean} \class{textview}::RecSrchResume(\type{\keyword{struct} 
SearchPattern *}\type{pat});

See \class{view}::\virtualmemberfunction{RecSrchResume}.


\type{boolean} \class{textview}::RecSrchReplace(\type{\class{dataobject} 
*}\type{text}, \keyword{\type{long}} \type{pos}, \keyword{\type{long}} 
\type{len});

See \class{view}::\virtualmemberfunction{RecSrchReplace}.


\keyword{\type{void}} \class{textview}::RecSrchExpose(\type{\keyword{const} 
\keyword{struct} rectangle &}\type{logical}, \type{\keyword{struct} 
rectangle &}\type{hit});

See \class{view}::\virtualmemberfunction{RecSrchExpose}.


\keyword{\type{void}} 
\class{textview}::\virtualmemberfunction{SetDotPosition}(\keyword{\type{long\
}} \type{newPosition});

Sets the position of the text caret or the beginning of the selected 
region.  (If GetDotLenth()!=0.)

\keyword{\type{void}} 
\class{textview}::\virtualmemberfunction{SetDotLength}(\keyword{\type{long}} 
\type{newLength});

Sets the length of the selected region.


\keyword{\type{long}} 
\class{textview}::\virtualmemberfunction{GetDotPosition}();

Returns the position of text caret or the beginning of the selected region.


\keyword{\type{long}} 
\class{textview}::\virtualmemberfunction{GetDotLength}();

Returns the length of the selected region.


\keyword{\type{long}} 
\class{textview}::\virtualmemberfunction{GetTopPosition}();

Returns the first position displayed in the view.


\keyword{\type{void}} 
\class{textview}::\virtualmemberfunction{SetTopPosition}(\keyword{\type{long\
}} \type{newTopPosition});

Sets the first position to be displayed in the view.


\keyword{\type{void}} 
\class{textview}::\virtualmemberfunction{SetBorder}(\keyword{\type{long}} 
\type{xBorder}, \keyword{\type{long}} \type{yBorder});

Sets the number of pixels to be reserved along the sides of the view when 
not embedded.


\keyword{\type{void}} 
\class{textview}::\virtualmemberfunction{SetEmbeddedBorder}(\keyword{\type{l\
ong}} \type{xBorder}, \keyword{\type{long}} \type{yBorder});

Sets the number of pixels to be reserved along the sides of the view when 
embedded.


\keyword{\type{long}} 
\class{textview}::\virtualmemberfunction{CollapseDot}();

Sets the length of the dot to 0, and releases the X selection if 
appropriate.


\type{boolean} 
\class{textview}::\virtualmemberfunction{Visible}(\keyword{\type{long}} 
\type{pos});

Returns TRUE if at least part of the text at \argument{pos} is visible in 
the view.


\keyword{\type{long}} 
\class{textview}::\virtualmemberfunction{Locate}(\keyword{\type{long}} 
\type{x}, \keyword{\type{long}} \type{y}, \type{\class{view} **view});

Returns the character at \argument{x},\argument{\argument{y}} in the 
\classobject{textview}.  If the \argument{x},\argument{y} position is 
within an embedded object the \classobject{view} on the object is returned 
in *\argument{view}.


\keyword{\type{void}} 
\class{textview}::\virtualmemberfunction{GetTextSize}(\type{long 
*}\type{width}, \type{\keyword{long} *}\type{height});

Returns the \argument{width} and \argument{height} of the view actually 
used for text.


\keyword{\type{void}} 
\class{textview}::\virtualmemberfunction{SetDefaultStyle}(\type{\class{style\
} *}\type{styelptr});

Sets the default style to use for displaying the text.


\type{\class{style} 
*}\class{textview}::\virtualmemberfunction{GetDefaultStyle}();

Returns the default style used for displaying the text.


\keyword{int} \class{textview}::\virtualmemberfunction{GetEditor}();

Returns 0(emacs), or 1(vi) depending on which editing mode is in effect.


\keyword{int} \class{textview}::\virtualmemberfunction{GetVIMode}();

Returns 0(command), or 1(input) depending on which VI mode is in effect.

\keyword{\type{
void}} \class{textview}::\memberfunction{SetAlwaysDrawDot}(\type{boolean} 
\type{val});

If val is \constant{TRUE} the dot (or selection) will always be displayed 
regardless of whether the \classobject{textview} has the input focus, 
otherwise the \classobject{textview} only shows the dot if it has the input 
focus.  (The default is \constant{FALSE}.)


\type{boolean} \class{textview}::\memberfunction{GetAlwaysDrawDot}();

Returns the last setting made with \memberfunction{SetAlwaysDrawDot}.

 \


\section{10.13	chlist}

\section{10.14	panel}

\section{10.15	syntax}

\section{10.16	image}

\section{10.17	table}

\section{10.18	figure}

\section{10.19	ness}

\section{10.20	hyplink}}\chapter{

\begindata{bp,538934984}
Version 2
n 0
\enddata{bp,538934984}
\view{bpv,538934984,7,0,0}
}\smaller{Copyright 1996 Carnegie Mellon University.  All rights reserved.


$Disclaimer: 
# Permission to use, copy, modify, and distribute this software and its 
# documentation for any purpose and without fee is hereby granted, provided 
# that the above copyright notice appear in all copies and that both that 
# copyright notice and this permission notice appear in supporting 
# documentation, and that the name of IBM not be used in advertising or 
# publicity pertaining to distribution of the software without specific, 
# written prior permission. 
#                         
# THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD 
# TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF 
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL ANY COPYRIGHT 
# HOLDER BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
# DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
# OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION 
# WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
# 
#  $

}
\enddata{text,537746824}
