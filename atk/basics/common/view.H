#ifndef _view_H_
#define _view_H_
/* ********************************************************************** *\
 * 	Copyright IBM Corporation 1988,1991 - All Rights Reserved         *
 * Copyright Carnegie Mellon University 1992, 1996 - All rights reserved  *
 * 	For full copyright information see:'andrew/doc/COPYRITE'          *
\* ********************************************************************** */

/** \addtogroup libbasics
 * @{ */
#include <atom.H>
#include <graphic.H>
#include <observable.H>
#include <color.H>
#include <stdio.h>

// Sigh, ScrollInterface isn't actually defined until supportviews...
class ScrollInterface;

/** Mostly abstract class for displaying a data object's contents.
 *  The class \ref view provides the methods, class procedures and data
 *  structures needed to (1) display information (often associated with a data
 *  object) in a rectangular area on the screen, (2) request display updates
 *  and respond to such requests, and (3) respond to input events generated by
 *  the user.
 *
 *  The class \ref view provides an interface to the underlying window
 *  systems.  As an Andrew Toolkit application programmer, you should
 *  understand why application programs should not interact directly with the
 *  underlying window system:  application programs must often be ported to
 *  other workstations that will eventually be deployed.  The workstations
 *  often have similar, but not identical, display capabilities and the
 *  hardware can be significantly different; the underlying window system may
 *  be different.  To ensure portability of your application, you should never
 *  make direct calls to the underlying window system; you should always use
 *  the \ref view class procedures and methods; doing so will maximize the
 *  device independence and portabilty of your application program.
 *
 *  The class \ref view contains a pointer to an instance of the class
 *  \ref graphic.  \ref view exports a set of methods that allow the
 *  programmer to execute drawing operations using its associated graphic
 *  object.
 *
 *  To manage display update requests and respond to input events, the
 *  \ref view also contains a pointer to an instance of the class \ref im.
 *  It is expected that descendents of the \ref view class add procedures
 *  related to the view on class inititialization, and set up menus and
 *  key bindings when the view is in focus.
 *
 *  It is never proper to create an instance of a \ref view.  You should
 *  only create subclasses of \ref view.
 *
 *  \subsection The associated data object
 *
 *  A \ref view may have an associated \ref dataobject. Typically, an
 *  instance of \ref view displays a \ref dataobject in a rectangular
 *  area on the workstation display.  Usually the data object is displayed
 *  because a user wishes to view or change the data.  The class \pref view
 *  is responsible for managing the display of the data and the interaction
 *  with the user; the class \ref dataobject is responsible for maintaining
 *  the data, including storing and manipulating it.  In general, views
 *  represent the input/output interface to data objects;  data objects
 *  represent memory or permanent storage.
 *
 *  Together with the class \ref dataobject, the class \ref view
 *  provides an architecture that supports multiple views of a single data
 *  object.  For example, a document may contain both a graphical and a tabular
 *  view of the same underlying numerical data.  When the user changes the
 *  numbers in the table, the table and the graph can each adjust accordingly.
 *  Likewise, a text editor may display the same document in more than one
 *  window, with changes reflected appropriately in each.
 *
 * FIXME: all coordinate parameters must document their coordinate system.
 *
 * FIXME: ExposeChild() and WantExposure() should be somehow related, but
 *        aren't.  Why?
 */
class view : public  observable {
  public:
    TRACED_CLASS(view);
    static boolean InitializeClass();
    view();

    static const int VERSION = 1;

    // override
    void ObservedChanged (observable *changed, long value);

    // view methods.  Override-able, but not usually overridden.
    virtual void SetName( atomlist *name );
    /**< Set the object name used by the resource manager.
     *   The default is to use the registered name for the class,
     *   as parsed by atomlist::StringToAtomlist().
     *   The old resource manager is deprecated.
     *   \param name The new name, split into an atom list. */
    virtual atomlist *GetName();
    /**< Get the object name used by the resource manager.
     *   Returns the name of this object, as set by SetName().
     *   The old resource manager is deprecated.
     *   \return The name of this object. */
    virtual atomlist *GetClass();
    /**< Get the class name used by the resource manager.
     *   This is the registered name for the class, as parsed by
     *   atomlist::StringToAtomlist().  Since there are no dots
     *   in any class name, this is just a single-element list with
     *   the class name as the first element.
     *   The old resource manager is deprecated.
     *   \return The name of this class. */

    virtual void InsertViewRegion(view *parent, const region *region);
    /**< Display this view in a rectangle.
     *   This sets up the logical bounds and clipping to the given region.
     *   The parameters are the same as for graphic::InsertGraphicRegion.
     *   [FIXME: this is poorly documented]
     *   \param parent The parent class; this is generally the one who
     *                 calls this method.
     *   \param region Where to place this view. */
    virtual void InsertView(view *parent, const struct rectangle *enclosingRect);
    /**< Display this view in a rectangle.
     *   This sets up the logical bounds and clipping to the given rectangle.
     *   The parameters are the same as for graphic::InsertGraphic.
     *   [FIXME: this is poorly documented]
     *   \param parent The parent class; this is generally the one who
     *                 calls this method.
     *   \param enclosingRect Where to place this view. */
    virtual void InsertViewSize(view *EnclosingView, 
		long xOriginInParent, long yOriginInParent, long w, long h);
    /**< Display this view in a rectangle.
     *   This sets up the logical bounds and clipping to the given rectangle.
     *   The parameters are the same as for graphic::InsertGraphicSize.
     *   [FIXME: this is poorly documented]
     *   \param EnclosingView The view relative to which this will be placed.
     *   \param xOriginInParent The X coordiante relateve to \p EnclosingView.
     *   \param yOriginInParent The Y coordiante relateve to \p EnclosingView.
     *   \param width The width of the rectangle.
     *   \param height The height of the rectangle.
     */
    virtual void SetDataObject(class dataobject *dobj);
    /**< Attach this view to a data object.
     *   This sets the source of data for this view.  It may be overridden
     *   to initialize parameters immediately from the view and to ensure
     *   that the data object is a class this view can handle.  However,
     *   there is no way short of killing the program to signal failure.
     *
     *   If overridden, the parent's implementation should be called as
     *   well.  The default implementation detaches the existing data
     *   object, adds a reference to the new one, and adds itself as an
     *   observer to the new one.  It also adjusts the data object and
     *   view names as needed.
     *   \param dobj The data object.  Do not set this to NULL, as some
     *   views will crash.  The only safe way to remove the data object
     *   is to create a new view instance, and destroy the old.
     */
    inline class dataobject *GetDataObject() { return ((this)->dataobject); }
    /**< Get the object attached to this view.
     *   \return The object, or NULL if no object is attached. */

    // view methods that should be overridden

    enum UpdateType  {
	FullRedraw,
	PartialRedraw,
	LastPartialRedraw,
	MoveNoRedraw,
	Remove
    };

    virtual void FullUpdate(enum UpdateType type, 
			long l, long t, long w, long h);
    virtual void Update();
    virtual void Print(FILE *file, const char *proc, const char *finalForm, boolean top);

    enum MouseAction  {
	NoMouseEvent,
	LeftDown,
	LeftUp,
	LeftMovement,
	RightDown,
	RightUp,
	RightMovement,
	UpMovement,	/* ! 6/96 -wjh */
	/* File drop actions are only available for DRAGDROP_ENV */
	LeftFileDrop,
	MiddleFileDrop,
	RightFileDrop
    };

    virtual view *Hit (enum MouseAction action, long x, long y, 
			long numberOfClicks);

    /** Input to DesiredSize() indicating flexibilty of input values. */
    enum DSpass {
	NoSet, /**< Both dimensions are flexible. */
	WidthSet, /**< The width cannot be changed. */
	HeightSet /**< The height cannot be changed. */
    };

    typedef int DSattributes;

    /** Return value from DesiredSize() indicating flexibilty of return values. */
    enum DSattribute {
	Fixed = 0, /**< Any otherwise unspecified direction is inflexible.  */

	WidthLarger = 1, /**< The reported width can grow. */
	WidthSmaller = 2, /**< The reported width can shrink. */
	WidthFlexible = 3, /**< The reported width can grow or shrink. */

	HeightLarger = 4, /**< The reported height can grow. */
	HeightSmaller = 8, /**< The reported height can shrink.  */
	HeightFlexible = 12 /**< The reported height can grow or shink. */
    };

    virtual DSattributes DesiredSize(long w, long h, 
			enum DSpass pass, long *dWidth, long *dheight);
    /**< Report requested size of this view.
     *   This method is used to conduct size negotiation between the
     *   parent and this view.  The parent passes in \p h and \p w, which
     *   are the current space allocated for the view, and receives the
     *   child's desired values in \p dWidth and \p dheight.  The permitted
     *   modifications to \p w and \p h are given in \p pass.  In addition
     *   to giving the desired size, a set of flags indicating possible
     *   modifications to this size is returned as well.
     *
     *   This is generally called by the parent during a FullUpdate() call.
     *   It is called as many times as needed to fit the children within
     *   their given space.  Once complete, the child's FullUpdate() is called.
     *   It is also generally called in response to a child calling
     *   WantNewSize().
     *   \param w The parent's desired width.
     *   \param h The parent's desired height.
     *   \param pass The flexibility of \p w and \p h.
     *   \param dWidth The returned child's desired width.
     *   \param dheight The returned child's desired height.
     *   \return a combination of \ref DSattribute flags indicating how
     *           flexible \p dWidth and \p dheight are.  Note that some of the
     *           flags are combinations of others; to check, and them
     *           and compare them with the flag being checked.
     */

// view methods that can be overridden
// input focus 
    virtual void ReceiveInputFocus();
    /**< Perform actions when receiving input focus.
     *   This method must be overridden to perform actions on receiving
     *   input focus.  At the minimum, key and menu bindings should be
     *   enabled by this method, using PostKeyState() and PostMenulist().
     *   Appearance may also be changed, although rendering such changes
     *   must be deferred using WantUpdate().
     *   [FIXME: this conflicts with AndrewProgramming.ez: it says that
     *   key/menu updates are done by overriding PostKeyState() and
     *   PostMenulist(), rather than this function, but most code in the
     *   wild seems to do it as described here]
     */
    virtual void LoseInputFocus();
    /**< Perform actions when losing input focus.
     *   This method must be overridden to perform actions on losing
     *   input focus.  Key and menu bindings will be automatically be
     *   removed, so this only needs to update appearance, if desired.
     *   Again, this must be deferred using WantUpdate(). */
    virtual void ChildLosingInputFocus();
    /**< Perform actions when a LinkTree() descendent loses focus.
     *   This method must be overridden to perform actions when child
     *   views lose input focus.  For example, the appearance of the
     *   container may change based on this fact.  These notifications
     *   are issued before the view actually losing focus gets its
     *   LoseInputFocus() notification. */
    virtual void ChildReceivingInputFocus();
    /**< Perform actions when a LinkTree() descendent loses focus.
     *   This method must be overridden to perform actions when child
     *   views gain input focus.  For example, the appearance of the
     *   container may change based on this fact.  These notifications
     *   are issued before the view actually gaining focus gets its
     *   ReceiveInputFocus() notification. */

// application layer (what to do if alone in a window)
    virtual view *GetApplicationLayer();
    virtual void DeleteApplicationLayer(view *applicationLayer);

    virtual void GetOrigin(long w, long h, long *originX, long *originY);
    /**< Determine view offset from insertion point when used as inset.
     *   While the insertion point is defined entirely by the parent,
     *   it is generally the same as a character inserted at that position.
     *   That is, its X coordinate is that of the left edge, and the Y
     *   coordinate is that of the text baseline.  A view containing text
     *   will generally want its baseline to be aligned with the baseline
     *   of surrounding text.  The returned origin is relative to the
     *   view's upper-left corner.
     *   \param w The width of the rectangle into which the view will be rendered.
     *   \param h The hight of the rectangle into which the view will be rendered.
     *   \param originX Return of a horizontal offset from the insertion
     *                  point when rendered at the given dimensions.  Positive
     *                  values move the view left.
     *   \param originY Return of a vertical offset from the insertion
     *                  point when rendered at the given dimensions.
     *                  Positive values move the view up.
     */
    virtual void GetPrintOrigin(long w, long h, long *originX, long *originY);
    /**< Determine view offset from insertion point when used as inset.
     *   Most views look different when being printed.  This method is
     *   called in place of GetOrigin() while printing, to allow for such
     *   differences.
     *   \param w The width of the rectangle into which the view will be rendered.
     *   \param h The hight of the rectangle into which the view will be rendered.
     *   \param originX Return of a horizontal offset from the insertion
     *                  point when rendered at the given dimensions.  Positive
     *                  values move the view left.
     *   \param originY Return of a vertical offset from the insertion
     *                  point when rendered at the given dimensions.
     *                  Positive values move the view up.
     */

// color
    virtual void ReceiveColormap(colormap *cmap);
    virtual void LoseColormap(colormap *cmap);
    virtual void WantColormap(view *requestor, colormap **cmap);

    virtual void WantUpdate(view *requestor);
    /**< An appeal from a child to update itself.
     *   A child calls this on its parent with itself as the parameter when
     *   it wants its Update() routine called at the earliest opportunity.
     *   This object is free to ignore or repsect the request.  If it chooses
     *   to respect the request, Update() will eventually be called on the
     *   child view.  Note that the default action is to pass it up the
     *   LinkTree() hierarchy anyway, so it is safe to call this on
     *   oneself.
     *   \param requestor The child view making the request.
     */
    virtual void WantInputFocus(view *requestor);
    /**< An appeal from a child to receive input focus.
     *   A child calls this on its parent with itself as the parameter when
     *   it wants input focus at the earliest opportunity.  This object is
     *   free to ignore or repsect the request.  If it chooses to respect
     *   the request, RecieveInputFocus() will eventually be called on the
     *   child view.  Note that the default action is to pass it up the
     *   LinkTree() hierarchy anyway, so it is safe to call this on
     *   oneself.
     *   \param requestor The child view making the request.
     */
    virtual void WantNewSize(view *requestor);
    /**< An appeal from a child to resize it.
     *   A child calls this on its parent with itself as the parameter when
     *   its contents change, requiring a renegotiation of its living space
     *   at the earliest opportunity.  This object is free to ignore or
     *   respect the request.  If it chooses to respect the request,
     *   DesiredSize() will eventually be caled on the child view, usually
     *   followed by FullUpdate() after resizing.  The default implementation
     *   passes the request to the parent if it is called on itself, so it
     *   is generally safe to call it on oneself.
     *   \param requestor The child view making the request.
     */
    virtual void PostKeyState(class keystate *keystate);
    virtual void PostMenus(class menulist *menulist);

    virtual void PostCursor(struct rectangle *rec, class cursor *cursor);
    virtual void RetractCursor(class cursor *cursor);
    virtual void RetractViewCursors(view *requestor);

    virtual ATK  *WantHandler(const char *handlerName);
    virtual void PostDefaultHandler(const char *handlerName, ATK  *handler);
    virtual const void *GetInterface(const char *type);
    virtual const char *WantInformation(const char *key);


// View linking/unlinking functions
    virtual void LinkTree(view *parent);
    /**< Link this view into the view tree.
     *   There is a view tree assocaited with each top-level window.  At
     *   the root of this tree is the interaction manager (\ref im) for this
     *   window.  In order to receive events of any kind, a view must be
     *   linked into that tree.  The view will also inherit its graphic
     *   context from its new parent; a view must be linked to perform
     *   any drawing.  When creating a new vew to display, call the new
     *   view's LinkTree() method with the view into which it
     *   will display as the \p parent parameter.  When finished using a
     *   view, it may be unlinked by calling the new view's LinkTree() method
     *   with a NULL parameter.
     *
     *   This method must be overridden by any view which displays other
     *   views as children of itself.  The override must call this method
     *   on all of its children to update linkage when its linkage changes.
     *   Of course the parent's implementation should always be called first
     *   to ensure that its own linkage is correct.
     *   \param parent The parent view; usually the caller.  If NULL,
     *                 only unlink from the current parent.
     */
    view *GetParent() { return parent; }
    /**< Find the parent of this view in the LinkTree() hierarchy.
     *   \return the parent. */
    inline void UnlinkTree() { LinkTree(NULL); }
    /**< Unlink this view from its view tree.
     *   This is equivalent to calling LinkTree(NULL).  Do not override.
     */
    virtual boolean IsAncestor(view *possibleAncestor);
    /**< Determine if this view is another view's descendent.
     *   This checks the link ancestry defined by LinkTree().
     *   \param possibleAncestor The view to check.
     *   \return TRUE if the \p possibleAncestor is this view or an actual
     *   ancestor of this view.
     */
    virtual void UnlinkNotification(view *unlinkedTree);
    /**< Callback when links are removed.
     *   If any view below this in the LinkTree() hierarchy is unlinked,
     *   this method is called first in its parent and all ancestors.
     *   The notification is passed on by the method itself; if you override
     *   this method, either call the parent class' version or pass the
     *   notification up to your own parent yourself.  This method is not
     *   meant to be called directly except by overriders of this method.
     *
     *   Remember that not only the given view, but also all of its
     *   descendents are unlinked.  If some of these descendents
     *   may interest you, use IsAncestor() to determine if they are
     *   being unlinked as well.
     *   \param unlinkedTree The view actually being unlinked.
     */
    virtual void ExposeSelf(boolean recurse);
    /**< Make this view visible within its parent.
     *   This method calls the ExposeChild() method in this view's parent
     *   in the LinkTree() heirarchy to request that it be made visible.
     *   This method is not meant to be overridden.
     *   \param recurse If TRUE, call ExposeSelf(TRUE) in the parent as well.
     */
    virtual void ExposeChild(view *v);
    /**< Make a child of this view visible.
     *   This is a request to make a view \p v, which is a child of this
     *   view, visible.  This is normally done by panning or scrolling
     *   until the child is visible.  It is not necessary that this view
     *   itself be visible, just that the child be visible within its
     *   bounds.
     *   \param v A child of this view in the LinkTree() hierarchy.
     */

    virtual const char *GetWindowManagerType();
    virtual long GetDevice();
    virtual void InitChildren();
    virtual boolean CanView(const char *TypeName);
    /**< Determine if this view can handle data objects of a given %ATK
     *   class name.
     *   This must be overridden by descendents of view which do not
     *   support the same list of data objects as their parents.  In
     *   particular, view itself supports none.  It is checked before
     *   creating a view on a data object.
     *
     *   This method is a good idea that was never implemented properly.
     *   The default returns TRUE, even though it should return FALSE.
     *   It doesn't even check if the parameter is a dataobject.
     *   Only 3 classes override this (of 140 in AMS-less %ATK).
     *   Only 1 class actually looks at this (\ref celview), even though
     *   it should be verified at the least by anything that inserts
     *   "insets" (e.g. \ref textview, \ref spread) or creates views
     *   from names (e.g. \b runapp).  Even though these all use the
     *   dataobject::ViewName() method by default, they also allow
     *   view overrides which are never verified.  Instead, views just
     *   assume they are given data objects of the correct type, and
     *   silently cast their data objects to that type.
     *
     *   \param TypeName The %ATK registry name for the data object.
     *   \return TRUE if the view can display objects of this type.
     */

// Support for selections ala X 
    virtual void LoseSelectionOwnership();
    virtual long WriteSelection(FILE *out);

// support for recursive search
    virtual boolean RecSearch(class search *pat, boolean toplevel);
    /**< Recursively search a view hierarchy.
     *   The search begins at this view, and proceeds, depth first, to
     *   any children.  If this view does not support searching,
     *   this method does nothing.  This method is itself responsible for
     *   identififying children and passing the search on to them in the
     *   correct order.  In addition, on successful match, the location
     *   and extent must be saved internally to allow other recursive
     *   search methods to function.  A common implementation is to
     *   simply set the search resume location and make RecSrchResume()
     *   do all the work.
     *   \param pat The search pattern.
     *   \param toplevel TRUE if this is the top of the hierarchy.  This
     *   means to start at an implementation-defined location rather than
     *   the start of the object's text.
     *   \return TRUE if search succeeded.
     */
    virtual boolean RecSrchResume(class search *pat);
    /**< Continue a search begun by RecSearch().
     *   This is used to find the next occurrence of the search pattern.
     *   \param pat The search pattern.
     *   \return TRUE if search succeeded.  This should return FALSE if
     *   the previous RecSearch() or RecSrchResume() failed, or no such
     *   previous call was made with this pattern.
     */
    virtual boolean RecSrchReplace(class dataobject *text, long pos, long len);
    /**< Continue a search begun by RecSearch().
     *   This is used to replace the found occurrence of the search pattern.
     *   Generally the class of \p text is the same, or an ancestor of the
     *   class on which the search took place.  It is the responsibility
     *   of implementors of this method to ensure that the type of \p text
     *   is understood.
     *   \param text A replacement object this class understands.
     *   \param pos The position in the replacement object's contents of the replacement text.
     *   \param len The extent of the replacement text.
     *   \return TRUE if the replacement succeeded.  This should return FALSE
     *   and do nothing else if the previous RecSearch() or RecSrchResume()
     *   failed, or no such previous call was made, or if \p text is an object
     *   which is not supported.
     */
    virtual void RecSrchExpose(const struct rectangle &logical, 
			struct rectangle &hit);
    /**< Highlight search result.
     *   This is used to display and highlight the last search result.
     *   The actual exposure may be done mostly with WantExposure()
     *   and/or WantUpdate().
     *   \param logical The logical bounds within which the highlighted
     *                  results should appear.
     *   \param hit Filled in with the logical bounds into which the
     *          highlighted results would be rendered at the next update
     *          on successful completion.
     */
    
// Postscript printing
    virtual void *GetPSPrintInterface(const char *printtype);
    virtual void DesiredPrintSize(long w, long h, enum DSpass pass, 
			long *desiredwidth, long *desiredheight);
    virtual void PrintPSDoc(FILE *outfile, long pagew, long pageh);
    virtual void PrintPSRect(FILE *outfile, long logwidth, long logheight, 
			struct rectangle *visrect);

    struct printopt {
	const atom *name, *type;
	const char *label;
    };
    struct printoptlist {
	struct printopt *list; /* array of structures */
	int numoptions; /* size of list */
	struct printoptlist *parent;
    };

    virtual struct printoptlist *PrintOptions();
    virtual long GetPrintOption(const atom *popt);
    virtual void SetPrintOption(struct printopt *vopt, long value);

    virtual boolean Gifify(const char *filename, long *pmaxw, long *pmaxh, 
			struct rectangle *visrect);
	/* put a gifified version of the view into the named file
		The pmax args incoming values are the maximum gif size;
		they are set to the actual gif size by the function.
		Visrect, if non-NULL, specifies the subrectangle to gifify 
		Return FALSE for failure. */

    //enum Traversal {
    //    NextView,
    //    PrevView,
    //    NextGroup,
    //    PrevGroup
    //};


    //    virtual void Traverse(enum Traversal trav);
    virtual void WantExposure(view *requestor, struct rectangle *childrect);
    /**< Make part of a child of this view visible.
     *   This is a request to make part of a view, which is a LinkTree()
     *   child of this view, visible.  This is normally done by
     *   panning or scrolling until the child is visible.  This should
     *   be passed up the LinkTree() hierarchy with \p childrect converted
     *   to this view's coordinate system when complete.
     *   \param requestor A child of this view in the LinkTree() hierarchy.
     *   \param childrect The location within the child to make visible,
     *                    in the child's coordinate system.
     */

    // GetScrollInterface will create an appropriate object of
    // a class derived from ScrollInterface.  The caller is responsible
    // for destroying the interface.  NULL is returned if there
    // is no appropriate interface.
    virtual ScrollInterface *GetScrollInterface();

    // resources and parameters
    virtual short GetParameter(atomlist *name, const atom *type, long *datum );
    virtual short GetResource(atomlist *name, atomlist *class_c,
		const atom *type, long *datum );
    virtual void GetManyParameters(struct resourceList *resources,
    atomlist *name, atomlist *class_c );		      
    virtual void PostResource(atomlist *path, const atom *type, long datum );


	// The following avoid multiple inheritance
	// Each method of graphic is made a method of view

#define DRAW(x) (drawable->x)

    inline void MoveToPt(const struct point *Pt) { DRAW(MoveToPt((Pt))); }
    /**< \copydoc graphic::MoveToPt */
    inline void MoveTo(long NewX,long NewY) { DRAW(MoveTo((NewX),(NewY))); }
    /**< \copydoc graphic::MoveTo */
    inline void Move(long DX, long DY) { DRAW(Move((DX),(DY))); }
    /**< \copydoc graphic::Move */

    inline void GetLogicalBounds(struct rectangle *Rect) 
		{ DRAW(GetLogicalBounds((Rect))); }
    /**< \copydoc graphic::GetLogicalBounds */
    inline long GetLogicalRight() { return DRAW(GetLogicalRight()); }
    /**< \copydoc graphic::GetLogicalRight */
    inline long GetLogicalBottom() { return DRAW(GetLogicalBottom()); }
    /**< \copydoc graphic::GetLogicalBottom */
    inline long GetLogicalLeft() { return DRAW(GetLogicalLeft()); }
    /**< \copydoc graphic::GetLogicalLeft */
    inline long GetLogicalHeight() { return DRAW(GetLogicalHeight()); }
    /**< \copydoc graphic::GetLogicalHeight */
    inline long GetLogicalWidth() { return DRAW(GetLogicalWidth()); }
    /**< \copydoc graphic::GetLogicalWidth */
    inline long GetLogicalTop() { return DRAW(GetLogicalTop()); }
    /**< \copydoc graphic::GetLogicalTop */

    inline void SetVisualRegion(region *region) 
		{ DRAW(SetVisualRegion((region))); }
    /**< \copydoc graphic::SetVisualRegion */
    inline region *GetVisualRegion(region *region) 
		{ return DRAW(GetVisualRegion((region))); }
    /**< \copydoc graphic::GetVisualRegion */
    inline void GetVisualBounds(struct rectangle *Rect) 
		{ DRAW(GetVisualBounds((Rect))); }
    /**< \copydoc graphic::GetVisualBounds */
    inline long GetVisualRight() { return DRAW(GetVisualRight()); }
    /**< \copydoc graphic::GetVisualRight */
    inline long GetVisualBottom() { return DRAW(GetVisualBottom()); }
    /**< \copydoc graphic::GetVisualBottom */
    inline long GetVisualWidth() { return DRAW(GetVisualWidth()); }
    /**< \copydoc graphic::GetVisualWidth */
    inline long GetVisualHeight() { return DRAW(GetVisualHeight()); }
    /**< \copydoc graphic::GetVisualHeight */
    inline long GetVisualLeft() { return DRAW(GetVisualLeft()); }
    /**< \copydoc graphic::GetVisualLeft */
    inline long GetVisualTop() { return DRAW(GetVisualTop()); }
    /**< \copydoc graphic::GetVisualTop */

    inline void GetEnclosedBounds(struct rectangle *Rect)
		{ DRAW(GetEnclosedBounds(Rect)); }
    /**< \copydoc graphic::GetEnclosedBounds */
    inline long GetEnclosedRight() { return DRAW(GetEnclosedRight()); }
    /**< \copydoc graphic::GetEnclosedRight */
    inline long GetEnclosedBottom() { return DRAW(GetEnclosedBottom()); }
    /**< \copydoc graphic::GetEnclosedBottom */
    inline long GetEnclosedLeft() { return DRAW(GetEnclosedLeft()); }
    /**< \copydoc graphic::GetEnclosedLeft */
    inline long GetEnclosedTop() { return DRAW(GetEnclosedTop()); }
    /**< \copydoc graphic::GetEnclosedTop */
    inline long GetEnclosedWidth() { return DRAW(GetEnclosedWidth()); }
    /**< \copydoc graphic::GetEnclosedWidth */
    inline long GetEnclosedHeight() { return DRAW(GetEnclosedHeight()); }
    /**< \copydoc graphic::GetEnclosedHeight */

    inline void GetCurrentPt(struct point *Pt) { DRAW(GetCurrentPt((Pt))); }
    /**< \copydoc graphic::GetCurrentPt */

    inline void DrawLineToPt(const struct point *LineEnd)
		{ DRAW(DrawLineToPt((LineEnd))); }
    /**< \copydoc graphic::DrawLineToPt */
    inline void DrawLineTo(long XEnd, long YEnd)
		{ DRAW(DrawLineTo((XEnd), (YEnd))); }
    /**< \copydoc graphic::DrawLineTo */
    inline void DrawLine(long DeltaX, long DeltaY)
		{ DRAW(DrawLine((DeltaX), (DeltaY))); }
    /**< \copydoc graphic::DrawLine */

    inline void DrawString(const char *Text, short Operation)
		{ DRAW(DrawString((Text), (Operation))); }
    /**< \copydoc graphic::DrawString */
    inline void DrawText(const char *Text, long TextLength, short Operation)
		{ DRAW(DrawText((Text), (TextLength), (Operation))); }
    /**< \copydoc graphic::DrawText */
    inline void SetSpaceShim(short Amount) { DRAW(SetSpaceShim((Amount))); }
    /**< \copydoc graphic::SetSpaceShim */
    inline short GetSpaceShim() { return DRAW(GetSpaceShim()); }
    /**< \copydoc graphic::GetSpaceShim */
    inline void SetFont(fontdesc *ChosenFont)
		{ DRAW(SetFont((ChosenFont))); }
    /**< \copydoc graphic::SetFont */
    inline fontdesc *GetFont() { return DRAW(GetFont()); }
    /**< \copydoc graphic::GetFont */

    inline void DrawRect(const struct rectangle *Rect) { DRAW(DrawRect((Rect))); }
    /**< \copydoc graphic::DrawRect */
    inline void DrawRectSize(long x,long y,long w,long h)
		{ DRAW(DrawRectSize((x),(y),(w),(h))); }
    /**< \copydoc graphic::DrawRectSize */
    inline void DrawTrapezoid(long topX, long topY, long topW, 
			long botX, long botY, long botW)
		{ DRAW(DrawTrapezoid((topX),(topY),(topW),
			(botX),(botY),(botW))); }
    /**< \copydoc graphic::DrawTrapezoid */
    inline void DrawPolygon(const struct point *PointArray, short PointCount)
		{ DRAW(DrawPolygon((PointArray), (PointCount))); }
    /**< \copydoc graphic::DrawPolygon */
    inline void DrawPath(const struct point *PointArray, short PointCount)
		{ DRAW(DrawPath((PointArray), (PointCount))); }
    /**< \copydoc graphic::DrawPath */
    inline void DrawOval(const struct rectangle *Rect) { DRAW(DrawOval((Rect))); }
    /**< \copydoc graphic::DrawOval */
    inline void DrawOvalSize(long x,long y,long w,long h)
		{ DRAW(DrawOvalSize((x), (y), (w), (h))); }
    /**< \copydoc graphic::DrawOvalSize */
    inline void DrawArc(const struct rectangle *EnclRect, 
			short StartAngle, short OffsetAngle)
		{ DRAW(DrawArc((EnclRect),(StartAngle),(OffsetAngle))); }
    /**< \copydoc graphic::DrawArc */
    inline void DrawArcSize(long x,long y,long w,long h, 
			short StartAngle, short OffsetAngle)
		{ DRAW(DrawArcSize((x),(y),(w),(h),
			(StartAngle),(OffsetAngle))); }
    /**< \copydoc graphic::DrawArcSize */
    inline void DrawRRect(const struct rectangle *Outer, const struct rectangle *Inner)
		{ DRAW(DrawRRect((Outer), (Inner))); }
    /**< \copydoc graphic::DrawRRect */
    inline void DrawRRectSize(long x,long y,long w,long h, 
			long cornerWidth,long cornerHeight)
		{ DRAW(DrawRRectSize((x), (y), (w), (h), 
			(cornerWidth), (cornerHeight))); }
    /**< \copydoc graphic::DrawRRectSize */

    inline void FillRect(const struct rectangle *Rect, const graphic *Tile)
		{ DRAW(FillRect((Rect),(Tile))); }
    /**< \copydoc graphic::FillRect */
    inline void FillRectSize(long x,long y,long w,long h, const graphic *Tile)
		{ DRAW(FillRectSize((x), (y), (w), (h), (Tile))); }
    /**< \copydoc graphic::FillRectSize */
    inline void FillTrapezoid(long topX, long topY, long topW, 
			long botX, long botY, long botW, const graphic *Tile)
		{ DRAW(FillTrapezoid((topX), (topY), (topW), 
			(botX), (botY), (botW), (Tile))); }
    /**< \copydoc graphic::FillTrapezoid */
    inline void FillPolygon(const struct point *PtArray, short PtCount, 
			const graphic *Tile)
		{ DRAW(FillPolygon((PtArray), (PtCount), (Tile))); }
    /**< \copydoc graphic::FillPolygon */
    inline void FillOval(const struct rectangle *Rect, const graphic *Tile)
		{ DRAW(FillOval((Rect), (Tile))); }
    /**< \copydoc graphic::FillOval */
    inline void FillOvalSize(long x,long y,long w,long h, const graphic *Tile)
		{ DRAW(FillOvalSize((x), (y), (w), (h), (Tile))); }
    /**< \copydoc graphic::FillOvalSize */
    inline void FillArc(const struct rectangle *EnclRect, 
			short StartAngle, short OffsetAngle, const graphic *Tile)
		{ DRAW(FillArc((EnclRect), (StartAngle), (OffsetAngle),(Tile))); }
    /**< \copydoc graphic::FillArc */
    inline void FillArcSize(long x,long y,long w,long h, 
			short StartAngle, short OffsetAngle, const graphic *Tile)
		{ DRAW(FillArcSize((x), (y), (w), (h), 
			(StartAngle), (OffsetAngle), (Tile))); }
    /**< \copydoc graphic::FillArcSize */
    inline void FillRRect(const struct rectangle *Outer, const struct rectangle *Inner, 
			const graphic *Tile)
		{ DRAW(FillRRect((Outer), (Inner), (Tile))); }
    /**< \copydoc graphic::FillRRect */
    inline void FillRRectSize(long x, long y, long w, long h, 
			long cornerW, long cornerHeight, const graphic *Tile)
		{ DRAW(FillRRectSize((x), (y), (w), (h), 
			(cornerW), (cornerHeight), (Tile))); }
    /**< \copydoc graphic::FillRRectSize */
    inline void FillRgn(region *Rgn, const graphic *Tile)
		{ DRAW(FillRgn((Rgn), (Tile))); }
    /**< \copydoc graphic::FillRgn */

    inline void EraseRect(const struct rectangle *Rect) { DRAW(EraseRect((Rect))); }
    /**< \copydoc graphic::EraseRect */
    inline void EraseRectSize(long x,long y,long w,long h)
		{ DRAW(EraseRectSize((x), (y), (w), (h))); }
    /**< \copydoc graphic::EraseRectSize */
    inline void EraseVisualRect() { DRAW(EraseVisualRect()); }
    /**< \copydoc graphic::EraseVisualRect */

    inline void BitBlt(const struct rectangle *SrcRect, view *DestView, 
		const struct point *DstOrigin, const struct rectangle *ClipRectList)
		{ DRAW(BitBlt((SrcRect), (((DestView))->drawable), 
			(DstOrigin), (ClipRectList))); }
    /**< \copydoc graphic::BitBlt */
    inline void BitBltSize(long srcX, long srcY, long dstX, long dstY, 
			long W, long H, view *DstView, 
			long clipX, long clipY, long clipW, long clipH)
		{ DRAW(BitBltSize((srcX), (srcY), (dstX), (dstY), (W),(H), 
			((DstView)->drawable), 
			(clipX),(clipY), (clipW), (clipH))); }
    /**< \copydoc graphic::BitBltSize */
    inline void SetBitAtLoc(long XPos, long YPos, boolean NewValue)
		{ DRAW(SetBitAtLoc((XPos), (YPos), (NewValue))); }
    /**< \copydoc graphic::SetBitAtLoc */

    inline void WritePixImage(long DestX, long DestY, pixelimage *SrcPixels, 
				long SrcX, long SrcY, long w, long h) 
		{ DRAW(WritePixImage(DestX,DestY, SrcPixels, SrcX,SrcY, w,h));}
    /**< \copydoc graphic::WritePixImage */
    inline void ReadPixImage(long SrcX, long SrcY, pixelimage *DestPixels, 
				long DestX, long DestY, long w, long h)
		{ DRAW(ReadPixImage(SrcX,SrcY, DestPixels, DestX,DestY, w,h));}
    /**< \copydoc graphic::ReadPixImage */
    inline void ReadImage(long SrcX, long SrcY, image *DestImage, 
				long DestX, long DestY, long w, long h)
		{ DRAW(ReadImage(SrcX, SrcY, DestImage, DestX, DestY, w, h)); }
    /**< \copydoc graphic::ReadImage */
    inline void WriteImage(long DestX, long DestY, ddimage &SrcImage, 
				long SrcX, long SrcY, long w, long h) 
		{ DRAW(WriteImage(DestX, DestY, SrcImage, SrcX, SrcY, w, h)); }
    /**< \copydoc graphic::WriteImage */

    inline void SetClippingRegion(region *region)
		{ DRAW(SetClippingRegion((region))); }
    /**< \copydoc graphic::SetClippingRegion */
    inline region *GetClippingRegion(/*MAYBE MISSING */ region *region)
		{ return DRAW(GetClippingRegion((region))); }
    /**< \copydoc graphic::GetClippingRegion */
    inline void SetClippingRect(/*MAYBE MISSING */ struct rectangle *ClipRect)
		{ DRAW(SetClippingRect((ClipRect))); }
    /**< \copydoc graphic::SetClippingRect */
    inline void SetClippingRectSize(long x, long y, long w, long h)
		{ DRAW(SetClippingRectSize((x),(y),(w),(h))); }
    /**< \copydoc graphic::SetClippingRectSize */
    inline void ClearClippingRect() { DRAW(ClearClippingRect()); }
    /**< \copydoc graphic::ClearClippingRect */
    inline void GetClippingRect(struct rectangle *Rect)
		{ DRAW(GetClippingRect((Rect))); }
    /**< \copydoc graphic::GetClippingRect */

    inline void SetLineWidth(short NewLineW) { DRAW(SetLineWidth((NewLineW)));}
    /**< \copydoc graphic::SetLineWidth */
    inline short GetLineWidth() { return DRAW(GetLineWidth()); }
    /**< \copydoc graphic::GetLineWidth */

    inline void SetLineDash(const unsigned char *dashPattern, int dashOffset, graphic::LineDash dashType)
		{ DRAW(SetLineDash((dashPattern), (dashOffset), (dashType))); }
    /**< \copydoc graphic::SetLineDash */
    inline void GetLineDash(unsigned char **dashPat, int *dashOffset, graphic::LineDash *dashType)
		{ DRAW(GetLineDash((dashPat), (dashOffset), (dashType))); }
    /**< \copydoc graphic::GetLineDash */

    inline void SetLineCap(graphic::LineCap NewLineCap) { DRAW(SetLineCap((NewLineCap)));}
    /**< \copydoc graphic::SetLineCap */
    inline graphic::LineCap GetLineCap() { return DRAW(GetLineCap()); }
    /**< \copydoc graphic::GetLineCap */

    inline void SetLineJoin(graphic::LineJoin NewLineJoin)
		{ DRAW(SetLineJoin((NewLineJoin))); }
    /**< \copydoc graphic::SetLineJoin */
    inline graphic::LineJoin GetLineJoin() { return DRAW(GetLineJoin()); }
    /**< \copydoc graphic::GetLineJoin */

    inline void SetTransferMode(short mode){ DRAW(SetTransferMode(mode)); }
    /**< \copydoc graphic::SetTransferMode */
    inline short GetTransferMode() { return DRAW(GetTransferMode()); }
    /**< \copydoc graphic::GetTransferMode */

    inline void FlushGraphics() { DRAW(FlushGraphics()); }
    /**< \copydoc graphic::FlushGraphics */

    inline graphic *WhitePattern() { return DRAW(WhitePattern()); }
    /**< \copydoc graphic::WhitePattern */
    inline graphic *BlackPattern() { return DRAW(BlackPattern()); }
    /**< \copydoc graphic::BlackPattern */
    inline graphic *GrayPattern(short IntensityNum, short IntensityDenom)
		{ return DRAW(GrayPattern((IntensityNum), (IntensityDenom))); }
    /**< \copydoc graphic::GrayPattern */
    inline void SetPatternOrigin(long xpos, long ypos) 
		{ DRAW(SetPatternOrigin((xpos), (ypos))); }
    /**< \copydoc graphic::SetPatternOrigin */
    inline void GetPatternOrigin(long *xpos, long *ypos)
		{ DRAW(GetPatternOrigin((xpos), (ypos))); }
    /**< \copydoc graphic::GetPatternOrigin */
    inline void SetForegroundColor(color *c) { DRAW(SetForegroundColor(c)); }
    /**< \copydoc graphic::SetForegroundColor */
    inline void SetBackgroundColor(color *c) { DRAW(SetBackgroundColor(c)); }
    /**< \copydoc graphic::SetBackgroundColor */
    inline void SetForegroundColor(const char *colorName, long r, long g, long b)
		{ DRAW(SetForegroundColor((colorName), (r), (g), (b))); }
    /**< \copydoc graphic::SetForegroundColor */
    inline void GetForegroundColor(const char **name, long*retr,long*retg,long*retb)
		{ DRAW(GetForegroundColor((name), (retr), (retg), (retb))); }
    /**< \copydoc graphic::GetForegroundColor */
    inline void SetBackgroundColor(const char *colorName, long r, long g, long b)
		{ DRAW(SetBackgroundColor((colorName), (r),(g),(b))); }
    /**< \copydoc graphic::SetBackgroundColor */
    inline void GetBackgroundColor(const char **name, long*retr,long*retg,long*retb)
		{ DRAW(GetBackgroundColor((name), (retr), (retg), (retb))); }
    /**< \copydoc graphic::GetBackgroundColor */

    inline void SetFGColorCell(color *color)
		{  DRAW(SetFGColorCell(color)); }
    /**< \copydoc graphic::SetFGColorCell */
    inline void SetBGColorCell(color *color)
		{  DRAW(SetBGColorCell(color)); }
    /**< \copydoc graphic::SetBGColorCell */

    inline void SetFGColor(double red, double green, double blue)
		{ DRAW(SetFGColor((red),(green),(blue))); }
    /**< \copydoc graphic::SetFGColor */
    inline void GetFGColor(double *red, double *green, double *blue)
		{ DRAW(GetFGColor((red),(green),(blue))); }
    /**< \copydoc graphic::GetFGColor */
    inline void SetBGColor(double red, double green, double blue)
		{ DRAW(SetBGColor((red),(green),(blue))); }
    /**< \copydoc graphic::SetBGColor */
    inline void GetBGColor(double *red, double *green, double *blue)
		{ DRAW(GetBGColor((red),(green),(blue))); }
    /**< \copydoc graphic::GetBGColor */

    inline long GetHorizontalResolution()
		{ return DRAW(GetHorizontalResolution()); }
    /**< \copydoc graphic::GetHorizontalResolution */
    inline long GetVerticalResolution()
		{ return DRAW(GetVerticalResolution()); }
    /**< \copydoc graphic::GetVerticalResolution */

    inline class im *GetIM() { return imPtr; }
    /**< \copydoc graphic::GetIM */
    inline class graphic *GetDrawable() { return drawable; }
    /**< \copydoc graphic::GetDrawable */

    inline colormap **GetColormap() { return DRAW(GetColormap()); }
    /**< \copydoc graphic::GetColormap */
    inline void SetColormap(colormap **cmap) {DRAW(SetColormap(cmap));}
    /**< \copydoc graphic::SetColormap */
    inline colormap **GetInheritedColormap()
		{ return DRAW(GetInheritedColormap()); }
    /**< \copydoc graphic::GetInheritedColormap */
    inline void SetInheritedColormap(colormap **cmap) 
		{ DRAW(SetInheritedColormap(cmap)); }
    /**< \copydoc graphic::SetInheritedColormap */
    inline void ClearInheritedColormap()
		{  DRAW(ClearInheritedColormap()); }
    /**< \copydoc graphic::ClearInheritedColormap */
    inline colormap **CurrentColormap()
		{ return DRAW(CurrentColormap()); }
    /**< \copydoc graphic::CurrentColormap */

    inline long  EnclosedXToLocalX(long xvalue)  
		{return (xvalue)-DRAW(GetEnclosedLeft())+DRAW(GetLogicalLeft());}
    /**< \copydoc graphic::EnclosedXToLocalX */
    inline long  EnclosedYToLocalY(long yvalue)   
		{return (yvalue)-DRAW(GetEnclosedTop())+DRAW(GetLogicalTop());}
    /**< \copydoc graphic::EnclosedYToLocalY */

    inline long DisplayClass() { return DRAW(DisplayClass()); }
    /**< \copydoc graphic::DisplayClass */

#undef DRAW

    //virtual char *DescriptionObject(char *format, long rock);

    ///* Error codes for the description procedure */
    //enum DescriberErrs {
    //    NoDescribeError,
    //    NoDescriptionAvailable,
    //    NoDescribeString,
    //    NoDescribeObject,
    //    WrongSubclassDescription
    //};

    //virtual enum DescriberErrs Describe(char*format,FILE*file,long rock);

  private:
    /* following are managed by SetName/GetName */
    atomlist *name;
    atomlist *className;
    short  name_explicitly_set;
    void EnsureName();
    /* following are managed by InsertView/LinkTree */
    im *imPtr;
    friend class im; /* so it can set imPtr to itself */
    graphic *drawable;
    view *parent;
    /* following is managed by view::SetDataObject() and GetDataObject() */
    class dataobject *dataobject;
  protected:
    /* This should not be used by anyone.  It's used twice to set it to NULL
     * when the data object declares itself destroyed, but that shouldn't
     * happen unless it was destroyed by the view.  I'll leave it here for
     * now, though.  - tjm */
    /** Set the data object associated with this view directly.
     *  You should call view::SetDataObject instead.
     *  \param obj The new value for dataobject.
     */
    inline void SetThisDataObject(class dataobject *obj) { dataobject = obj; }
};

 /** @} */
#endif /* _view_H_ */
