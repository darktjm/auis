#ifndef _view_H_
#define _view_H_
/* ********************************************************************** *\
 * 	Copyright IBM Corporation 1988,1991 - All Rights Reserved         *
 * Copyright Carnegie Mellon University 1992, 1996 - All rights reserved  *
 * 	For full copyright information see:'andrew/doc/COPYRITE'          *
\* ********************************************************************** */

/** \addtogroup libbasics
 * @{ */
#include <atom.H>
#include <graphic.H>
#include <observable.H>
#include <color.H>
#include <stdio.h>

// Sigh, ScrollInterface isn't actually defined until supportviews...
class ScrollInterface;

/** Mostly abstract class for displaying a data object's contents.
 *  The class \ref view provides the methods, class procedures and data
 *  structures needed to (1) display information (often associated with a data
 *  object) in a rectangular area on the screen, (2) request display updates
 *  and respond to such requests, and (3) respond to input events generated by
 *  the user.
 *
 *  The class \ref view provides an interface to the underlying window
 *  systems.  As an Andrew Toolkit application programmer, you should
 *  understand why application programs should not interact directly with the
 *  underlying window system:  application programs must often be ported to
 *  other workstations that will eventually be deployed.  The workstations
 *  often have similar, but not identical, display capabilities and the
 *  hardware can be significantly different; the underlying window system may
 *  be different.  To ensure portability of your application, you should never
 *  make direct calls to the underlying window system; you should always use
 *  the \ref view class procedures and methods; doing so will maximize the
 *  device independence and portabilty of your application program.
 *
 *  The class \ref view contains a pointer to an instance of the class
 *  \ref graphic.  \ref view exports a set of methods that allow the
 *  programmer to execute drawing operations using its associated graphic
 *  object.
 *
 *  It is never proper to create an instance of a \ref view.  You should
 *  only create subclasses of \ref view.
 *
 *  \subsection The associated data object
 *
 *  A \ref view may have an associated \ref dataobject. Typically, an
 *  instance of \ref view displays a \ref dataobject in a rectangular
 *  area on the workstation display.  Usually the data object is displayed
 *  because a user wishes to view or change the data.  The class \pref view
 *  is responsible for managing the display of the data and the interaction
 *  with the user; the class \ref dataobject is responsible for maintaining
 *  the data, including storing and manipulating it.  In general, views
 *  represent the input/output interface to data objects;  data objects
 *  represent memory or permanent storage.
 *
 *  Together with the class \ref dataobject, the class \ref view
 *  provides an architecture that supports multiple views of a single data
 *  object.  For example, a document may contain both a graphical and a tabular
 *  view of the same underlying numerical data.  When the user changes the
 *  numbers in the table, the table and the graph can each adjust accordingly.
 *  Likewise, a text editor may display the same document in more than one
 *  window, with changes reflected appropriately in each. 
 */
class view : public  observable {
  public:
    virtual ATKregistryEntry *ATKregistry();
    static boolean InitializeClass();
    virtual ~view();
    view();

    static const int VERSION = 1;

    // override
    void ObservedChanged (observable *changed, long value);

    // view methods.  Override-able, but not usually overridden.
    virtual void SetName( atomlist *name );
    virtual atomlist *GetName();
    virtual atomlist *GetClass();

    virtual void InsertViewRegion(view *parent, region *region);
    virtual void InsertView(view *parent, struct rectangle *enclosingRect);
    virtual void InsertViewSize(view *EnclosingView, 
		long xOriginInParent, long yOriginInParent, long w, long h);
    virtual void SetDataObject(class dataobject *dobj);
    inline class dataobject *GetDataObject() { return ((this)->dataobject); }

    // view methods that should be overridden

    enum UpdateType  {
	FullRedraw,
	PartialRedraw,
	LastPartialRedraw,
	MoveNoRedraw,
	Remove
    };

    virtual void FullUpdate(enum UpdateType type, 
			long l, long t, long w, long h);
    virtual void Update();
    virtual void Print(FILE *file, const char *proc, const char *finalForm, boolean top);

    enum MouseAction  {
	NoMouseEvent,
	LeftDown,
	LeftUp,
	LeftMovement,
	RightDown,
	RightUp,
	RightMovement,
	UpMovement,	/* ! 6/96 -wjh */
	/* File drop actions are only available for DRAGDROP_ENV */
	LeftFileDrop,
	MiddleFileDrop,
	RightFileDrop
    };

    virtual view *Hit (enum MouseAction action, long x, long y, 
			long numberOfClicks);

    enum DSpass {
	NoSet,
	WidthSet,
	HeightSet
    };

    typedef int DSattributes;

    enum DSattribute {
	Fixed = 0,

	WidthLarger = 1,
	WidthSmaller = 2,
	WidthFlexible = 3,

	HeightLarger = 4,
	HeightSmaller = 8,
	HeightFlexible = 12
    };

    virtual DSattributes DesiredSize(long w, long h, 
			enum DSpass pass, long *dWidth, long *dheight);

// view methods that can be overridden
// input focus 
    virtual void ReceiveInputFocus();
    virtual void LoseInputFocus();
    virtual boolean AcceptingFocus();
    virtual void ChildLosingInputFocus();
    virtual void ChildReceivingInputFocus();

// application layer (what to do if alone in a window)
    virtual view *GetApplicationLayer();
    virtual void DeleteApplicationLayer(view *applicationLayer);

    virtual void GetOrigin(long w, long h, long *originX, long *originY);
    virtual void GetPrintOrigin(long w, long h, long *originX, long *originY);

// color
    virtual void ReceiveColormap(colormap *cmap);
    virtual void LoseColormap(colormap *cmap);
    virtual void WantColormap(view *requestor, colormap **cmap);

    virtual void WantUpdate(view *requestor);
    virtual void WantInputFocus(view *requestor);
    virtual void WantNewSize(view *requestor);
    virtual void PostKeyState(class keystate *keystate);
    virtual void PostMenus(class menulist *menulist);

    virtual void PostCursor(struct rectangle *rec, class cursor *cursor);
    virtual void RetractCursor(class cursor *cursor);
    virtual void RetractViewCursors(view *requestor);

    virtual ATK  *WantHandler(const char *handlerName);
    virtual void PostDefaultHandler(const char *handlerName, ATK  *handler);
    virtual const void *GetInterface(const char *type);
    virtual const char *WantInformation(const char *key);


// View linking/unlinking functions
    virtual void LinkTree(view *parent);
    virtual void UnlinkTree();
    virtual boolean IsAncestor(view *possibleAncestor);
    virtual void UnlinkNotification(view *unlinkedTree);
    virtual void ExposeSelf(boolean recurse);
    virtual void ExposeChild(view *v);

    virtual const char *GetWindowManagerType();
    virtual long GetDevice();
    virtual void InitChildren();
    virtual boolean CanView(const char *TypeName);

// Support for selections ala X 
    virtual void LoseSelectionOwnership();
    virtual long WriteSelection(FILE *out);

// support for recursive search
    virtual boolean RecSearch(struct SearchPattern *pat, boolean toplevel);
    virtual boolean RecSrchResume(struct SearchPattern *pat);
    virtual boolean RecSrchReplace(class dataobject *text, long pos, long len);
    virtual void RecSrchExpose(const struct rectangle &logical, 
			struct rectangle &hit);
    
// Postscript printing
    virtual void *GetPSPrintInterface(const char *printtype);
    virtual void DesiredPrintSize(long w, long h, enum DSpass pass, 
			long *desiredwidth, long *desiredheight);
    virtual void PrintPSDoc(FILE *outfile, long pagew, long pageh);
    virtual void PrintPSRect(FILE *outfile, long logwidth, long logheight, 
			struct rectangle *visrect);

    struct printopt {
	const atom *name, *type;
	const char *label;
    };
    struct printoptlist {
	struct printopt *list; /* array of structures */
	int numoptions; /* size of list */
	struct printoptlist *parent;
    };

    virtual struct printoptlist *PrintOptions();
    virtual long GetPrintOption(const atom *popt);
    virtual void SetPrintOption(struct printopt *vopt, long value);

    virtual boolean Gifify(const char *filename, long *pmaxw, long *pmaxh, 
			struct rectangle *visrect);
	/* put a gifified version of the view into the named file
		The pmax args incoming values are the maximum gif size;
		they are set to the actual gif size by the function.
		Visrect, if non-NULL, specifies the subrectangle to gifify 
		Return FALSE for failure. */

    //enum Traversal {
    //    NextView,
    //    PrevView,
    //    NextGroup,
    //    PrevGroup
    //};


    //    virtual void Traverse(enum Traversal trav);
    virtual void WantExposure(view *requestor, struct rectangle *childrect);

    // GetScrollInterface will create an appropriate object of
    // a class derived from ScrollInterface.  The caller is responsible
    // for destroying the interface.  NULL is returned if there
    // is no appropriate interface.
    virtual ScrollInterface *GetScrollInterface();

    // resources and parameters
    virtual short GetParameter(atomlist *name, const atom *type, long *datum );
    virtual short GetResource(atomlist *name, atomlist *class_c,
		const atom *type, long *datum );
    virtual void GetManyParameters(struct resourceList *resources,
    atomlist *name, atomlist *class_c );		      
    virtual void PostResource(atomlist *path, const atom *type, long datum );


	// The following avoid multiple inheritance
	// Each method of graphic is made a method of view

#define DRAW(x) (drawable->x)

    inline void MoveToPt(struct point *Pt) { DRAW(MoveToPt((Pt))); }
    inline void MoveTo(long NewX,long NewY) { DRAW(MoveTo((NewX),(NewY))); }
    inline void Move(long DX, long DY) { DRAW(Move((DX),(DY))); }

    inline void GetLogicalBounds(struct rectangle *Rect) 
		{ DRAW(GetLogicalBounds((Rect))); }
    inline long GetLogicalRight() { return DRAW(GetLogicalRight()); }
    inline long GetLogicalBottom() { return DRAW(GetLogicalBottom()); }
    inline long GetLogicalLeft() { return DRAW(GetLogicalLeft()); }
    inline long GetLogicalHeight() { return DRAW(GetLogicalHeight()); }
    inline long GetLogicalWidth() { return DRAW(GetLogicalWidth()); }
    inline long GetLogicalTop() { return DRAW(GetLogicalTop()); }

    inline void SetVisualRegion(region *region) 
		{ DRAW(SetVisualRegion((region))); }
    inline region *GetVisualRegion(region *region) 
		{ return DRAW(GetVisualRegion((region))); }
    inline void GetVisualBounds(struct rectangle *Rect) 
		{ DRAW(GetVisualBounds((Rect))); }
    inline long GetVisualRight() { return DRAW(GetVisualRight()); }
    inline long GetVisualBottom() { return DRAW(GetVisualBottom()); }
    inline long GetVisualWidth() { return DRAW(GetVisualWidth()); }
    inline long GetVisualHeight() { return DRAW(GetVisualHeight()); }
    inline long GetVisualLeft() { return DRAW(GetVisualLeft()); }
    inline long GetVisualTop() { return DRAW(GetVisualTop()); }

    inline void GetEnclosedBounds(struct rectangle *Rect)
		{ DRAW(GetEnclosedBounds(Rect)); }
    inline long GetEnclosedRight() { return DRAW(GetEnclosedRight()); }
    inline long GetEnclosedBottom() { return DRAW(GetEnclosedBottom()); }
    inline long GetEnclosedLeft() { return DRAW(GetEnclosedLeft()); }
    inline long GetEnclosedTop() { return DRAW(GetEnclosedTop()); }
    inline long GetEnclosedWidth() { return DRAW(GetEnclosedWidth()); }
    inline long GetEnclosedHeight() { return DRAW(GetEnclosedHeight()); }

    inline void GetCurrentPt(struct point *Pt) { DRAW(GetCurrentPt((Pt))); }

    inline void DrawLineToPt(struct point *LineEnd)
		{ DRAW(DrawLineToPt((LineEnd))); }
    inline void DrawLineTo(long XEnd, long YEnd)
		{ DRAW(DrawLineTo((XEnd), (YEnd))); }
    inline void DrawLine(long DeltaX, long DeltaY)
		{ DRAW(DrawLine((DeltaX), (DeltaY))); }

    inline void DrawString(const char *Text, short Operation)
		{ DRAW(DrawString((Text), (Operation))); }
    inline void DrawText(const char *Text, long TextLength, short Operation)
		{ DRAW(DrawText((Text), (TextLength), (Operation))); }
    inline void SetSpaceShim(short Amount) { DRAW(SetSpaceShim((Amount))); }
    inline short GetSpaceShim() { return DRAW(GetSpaceShim()); }
    inline void SetFont(fontdesc *ChosenFont)
		{ DRAW(SetFont((ChosenFont))); }
    inline fontdesc *GetFont() { return DRAW(GetFont()); }

    inline void DrawRect(struct rectangle *Rect) { DRAW(DrawRect((Rect))); }
    inline void DrawRectSize(long x,long y,long w,long h)
		{ DRAW(DrawRectSize((x),(y),(w),(h))); }
    inline void DrawTrapezoid(long topX, long topY, long topW, 
			long botX, long botY, long botW)
		{ DRAW(DrawTrapezoid((topX),(topY),(topW),
			(botX),(botY),(botW))); }
    inline void DrawPolygon(struct point *PointArray, short PointCount)
		{ DRAW(DrawPolygon((PointArray), (PointCount))); }
    inline void DrawPath(struct point *PointArray, short PointCount)
		{ DRAW(DrawPath((PointArray), (PointCount))); }
    inline void DrawOval(struct rectangle *Rect) { DRAW(DrawOval((Rect))); }
    inline void DrawOvalSize(long x,long y,long w,long h)
		{ DRAW(DrawOvalSize((x), (y), (w), (h))); }
    inline void DrawArc(struct rectangle *EnclRect, 
			short StartAngle, short OffsetAngle)
		{ DRAW(DrawArc((EnclRect),(StartAngle),(OffsetAngle))); }
    inline void DrawArcSize(long x,long y,long w,long h, 
			short StartAngle, short OffsetAngle)
		{ DRAW(DrawArcSize((x),(y),(w),(h),
			(StartAngle),(OffsetAngle))); }
    inline void DrawRRect(struct rectangle *Outer, struct rectangle *Inner)
		{ DRAW(DrawRRect((Outer), (Inner))); }
    inline void DrawRRectSize(long x,long y,long w,long h, 
			long cornerWidth,long cornerHeight)
		{ DRAW(DrawRRectSize((x), (y), (w), (h), 
			(cornerWidth), (cornerHeight))); }
    inline void DrawRgn(region *Rgn)
		{ DRAW(DrawRgn((Rgn))); }

    inline void FillRect(struct rectangle *Rect, graphic *Tile)
		{ DRAW(FillRect((Rect),(Tile))); }
    inline void FillRectSize(long x,long y,long w,long h, graphic *Tile)
		{ DRAW(FillRectSize((x), (y), (w), (h), (Tile))); }
    inline void FillTrapezoid(long topX, long topY, long topW, 
			long botX, long botY, long botW, graphic *Tile)
		{ DRAW(FillTrapezoid((topX), (topY), (topW), 
			(botX), (botY), (botW), (Tile))); }
    inline void FillPolygon(struct point *PtArray, short PtCount, 
			graphic *Tile)
		{ DRAW(FillPolygon((PtArray), (PtCount), (Tile))); }
    inline void FillOval(struct rectangle *Rect, graphic *Tile)
		{ DRAW(FillOval((Rect), (Tile))); }
    inline void FillOvalSize(long x,long y,long w,long h, graphic *Tile)
		{ DRAW(FillOvalSize((x), (y), (w), (h), (Tile))); }
    inline void FillArc(struct rectangle *EnclRect, 
			short StartAngle, short OffsetAngle, graphic *Tile)
		{ DRAW(FillArc((EnclRect), (StartAngle), (OffsetAngle),(Tile))); }
    inline void FillArcSize(long x,long y,long w,long h, 
			short StartAngle, short OffsetAngle, graphic *Tile)
		{ DRAW(FillArcSize((x), (y), (w), (h), 
			(StartAngle), (OffsetAngle), (Tile))); }
    inline void FillRRect(struct rectangle *Outer, struct rectangle *Inner, 
			graphic *Tile)
		{ DRAW(FillRRect((Outer), (Inner), (Tile))); }
    inline void FillRRectSize(long x, long y, long w, long h, 
			long cornerW, long cornerHeight, graphic *Tile)
		{ DRAW(FillRRectSize((x), (y), (w), (h), 
			(cornerW), (cornerHeight), (Tile))); }
    inline void FillRgn(region *Rgn, graphic *Tile)
		{ DRAW(FillRgn((Rgn), (Tile))); }

    inline void EraseRect(struct rectangle *Rect) { DRAW(EraseRect((Rect))); }
    inline void EraseRectSize(long x,long y,long w,long h)
		{ DRAW(EraseRectSize((x), (y), (w), (h))); }
    inline void EraseVisualRect() { DRAW(EraseVisualRect()); }

    inline void BitBlt(struct rectangle *SrcRect, view *DestView, 
		struct point *DstOrigin, struct rectangle *ClipRectList)
		{ DRAW(BitBlt((SrcRect), (((DestView))->drawable), 
			(DstOrigin), (ClipRectList))); }
    inline void BitBltSize(long srcX, long srcY, long dstX, long dstY, 
			long W, long H, view *DstView, 
			long clipX, long clipY, long clipW, long clipH)
		{ DRAW(BitBltSize((srcX), (srcY), (dstX), (dstY), (W),(H), 
			((DstView)->drawable), 
			(clipX),(clipY), (clipW), (clipH))); }
    inline void SetBitAtLoc(long XPos, long YPos, boolean NewValue)
		{ DRAW(SetBitAtLoc((XPos), (YPos), (NewValue))); }

    inline void WritePixImage(long DestX, long DestY, pixelimage *SrcPixels, 
				long SrcX, long SrcY, long w, long h) 
		{ DRAW(WritePixImage(DestX,DestY, SrcPixels, SrcX,SrcY, w,h));}
    inline void ReadPixImage(long SrcX, long SrcY, pixelimage *DestPixels, 
				long DestX, long DestY, long w, long h)
		{ DRAW(ReadPixImage(SrcX,SrcY, DestPixels, DestX,DestY, w,h));}
    inline void ReadImage(long SrcX, long SrcY, image *DestImage, 
				long DestX, long DestY, long w, long h)
		{ DRAW(ReadImage(SrcX, SrcY, DestImage, DestX, DestY, w, h)); }
    inline void WriteImage(long DestX, long DestY, ddimage &SrcImage, 
				long SrcX, long SrcY, long w, long h) 
		{ DRAW(WriteImage(DestX, DestY, SrcImage, SrcX, SrcY, w, h)); }

    inline void MoveLogicalOrigin(long DeltaX, long DeltaY)
		{ DRAW(MoveLogicalOrigin((DeltaX), (DeltaY))); }
    inline void SetLogicalOrigin(long NewX, long NewY)
		{ DRAW(SetLogicalOrigin((NewX), (NewY))); }
    inline void SetLogicalOriginPt(struct point *Pt)
		{ DRAW(SetLogicalOriginPt((Pt))); }


    inline void SetClippingRegion(region *region)
		{ DRAW(SetClippingRegion((region))); }
    inline region *GetClippingRegion(/*MAYBE MISSING */ region *region)
		{ return DRAW(GetClippingRegion((region))); }
    inline void SetClippingRect(/*MAYBE MISSING */ struct rectangle *ClipRect)
		{ DRAW(SetClippingRect((ClipRect))); }
    inline void SetClippingRectSize(long x, long y, long w, long h)
		{ DRAW(SetClippingRectSize((x),(y),(w),(h))); }
    inline void ClearClippingRect() { DRAW(ClearClippingRect()); }
    inline void GetClippingRect(struct rectangle *Rect)
		{ DRAW(GetClippingRect((Rect))); }

    inline void SetLineWidth(short NewLineW) { DRAW(SetLineWidth((NewLineW)));}
    inline short GetLineWidth() { return DRAW(GetLineWidth()); }

    inline void SetLineDash(const char *dashPattern, int dashOffset, short dashType)
		{ DRAW(SetLineDash((dashPattern), (dashOffset), (dashType))); }
    inline void GetLineDash(char **dashPat, int *dashOffset, short *dashType)
		{ DRAW(GetLineDash((dashPat), (dashOffset), (dashType))); }

    inline void SetLineCap(short NewLineCap) { DRAW(SetLineCap((NewLineCap)));}
    inline short GetLineCap() { return DRAW(GetLineCap()); }

    inline void SetLineJoin(short NewLineJoin)
		{ DRAW(SetLineJoin((NewLineJoin))); }
    inline short GetLineJoin() { return DRAW(GetLineJoin()); }

    inline void SetTransferMode(short mode){ DRAW(SetTransferMode(mode)); }
    inline short GetTransferMode() { return DRAW(GetTransferMode()); }

    inline void FlushGraphics() { DRAW(FlushGraphics()); }

    inline graphic *WhitePattern() { return DRAW(WhitePattern()); }
    inline graphic *BlackPattern() { return DRAW(BlackPattern()); }
    inline graphic *GrayPattern(short IntensityNum, short IntensityDenom)
		{ return DRAW(GrayPattern((IntensityNum), (IntensityDenom))); }
    inline void SetPatternOrigin(long xpos, long ypos) 
		{ DRAW(SetPatternOrigin((xpos), (ypos))); }
    inline void GetPatternOrigin(long *xpos, long *ypos)
		{ DRAW(GetPatternOrigin((xpos), (ypos))); }
    inline void SetForegroundColor(color *c) { DRAW(SetForegroundColor(c)); }
    inline void SetBackgroundColor(color *c) { DRAW(SetBackgroundColor(c)); }
    inline void SetForegroundColor(const char *colorName, long r, long g, long b)
		{ DRAW(SetForegroundColor((colorName), (r), (g), (b))); }
    inline void GetForegroundColor(const char **name, long*retr,long*retg,long*retb)
		{ DRAW(GetForegroundColor((name), (retr), (retg), (retb))); }
    inline void SetBackgroundColor(const char *colorName, long r, long g, long b)
		{ DRAW(SetBackgroundColor((colorName), (r),(g),(b))); }
    inline void GetBackgroundColor(const char **name, long*retr,long*retg,long*retb)
		{ DRAW(GetBackgroundColor((name), (retr), (retg), (retb))); }

    inline void SetFGColorCell(color *color)
		{  DRAW(SetFGColorCell(color)); }
    inline void SetBGColorCell(color *color)
		{  DRAW(SetBGColorCell(color)); }

    inline void SetFGColor(double red, double green, double blue)
		{ DRAW(SetFGColor((red),(green),(blue))); }
    inline void GetFGColor(double *red, double *green, double *blue)
		{ DRAW(GetFGColor((red),(green),(blue))); }
    inline void SetBGColor(double red, double green, double blue)
		{ DRAW(SetBGColor((red),(green),(blue))); }
    inline void GetBGColor(double *red, double *green, double *blue)
		{ DRAW(GetBGColor((red),(green),(blue))); }

    inline long GetHorizontalResolution()
		{ return DRAW(GetHorizontalResolution()); }
    inline long GetVerticalResolution()
		{ return DRAW(GetVerticalResolution()); }

    inline class im *GetIM() { return imPtr; }
    inline class graphic *GetDrawable() { return drawable; }

    inline colormap **GetColormap() { return DRAW(GetColormap()); }
    inline void SetColormap(colormap **cmap) {DRAW(SetColormap(cmap));}
    inline colormap **GetInheritedColormap()
		{ return DRAW(GetInheritedColormap()); }
    inline void SetInheritedColormap(colormap **cmap) 
		{ DRAW(SetInheritedColormap(cmap)); }
    inline void ClearInheritedColormap()
		{  DRAW(ClearInheritedColormap()); }
    inline colormap **CurrentColormap()
		{ return DRAW(CurrentColormap()); }

    inline long  EnclosedXToLocalX(long xvalue)  
		{return (xvalue)-DRAW(GetEnclosedLeft())+DRAW(GetLogicalLeft());}
    inline long  EnclosedYToLocalY(long yvalue)   
		{return (yvalue)-DRAW(GetEnclosedTop())+DRAW(GetLogicalTop());}

    inline long DisplayClass() { return DRAW(DisplayClass()); }

#undef DRAW

    //virtual char *DescriptionObject(char *format, long rock);

    ///* Error codes for the description procedure */
    //enum DescriberErrs {
    //    NoDescribeError,
    //    NoDescriptionAvailable,
    //    NoDescribeString,
    //    NoDescribeObject,
    //    WrongSubclassDescription
    //};

    //virtual enum DescriberErrs Describe(char*format,FILE*file,long rock);


    atomlist *name;
    atomlist *className;
    short  name_explicitly_set;
    im *imPtr;
    view *parent;
    class dataobject *dataobject;
    graphic *drawable;
};

 /** @} */
#endif /* _view_H_ */
