\begindata{text,537795720}
\textdsversion{12}
\template{be2guide}
\define{global
}
\define{underline
menu:[Font~1,Underline~41]
attr:[Flags Underline Int Set]}
\define{index
menu:[Title,Index~91]
attr:[FontFace Italic Int Set]}
\define{indexi
menu:[Title,InvisibleIndex~92]
attr:[Script PreviousScriptMovement Point -2]
attr:[Flags Hidden Int Set]
attr:[FontFace Italic Int Set]}
\define{itemize
}
\define{fixedtext
menu:[Region~4,Fixedtext]
attr:[Justification LeftJustified Point 0]
attr:[FontFace FixedFace Int Set]
attr:[FontFamily AndyType Int 0]
attr:[FontSize ConstantFontSize Point 10]}
\define{fixedindent
menu:[Region~4,Fixedindent]
attr:[LeftMargin LeftMargin Cm 83230]
attr:[Justification LeftJustified Point 0]
attr:[FontFace FixedFace Int Set]
attr:[FontFamily AndyType Int 0]
attr:[FontSize ConstantFontSize Point 10]}
\define{paramname
menu:[Font~1,Paramname]
attr:[FontFace Italic Int Set]}
 \formatnote{\chapter{Graphic}}\indexi{Graphic}


You should use instances of the class \italic{graphic} to do output to 
workstation displays.  For example, to draw text and put box around it, you 
would make calls to the methods and class procedures provided by the class 
\italic{graphic}.  The class graphic provides methods for drawing lines, 
shapes, and text.  It also provides methods for transferring entire blocks 
of bits. \



The class \italic{graphic} provides an output interface to 
hardware-dependent window management systems.  As an application 
programmer, you should understand why application programs should not 
display their pictures directly to an underlying window management system: 
 application programs must often be ported to other workstations that will 
eventually be deployed.  The workstations often have similar, but not 
identical display capabilities and the hardware can be significantly 
different; the underlying window manager may be different.  To ensure 
portability of your application, you should never make direct calls to an 
underlying window management system; you should always use the 
\italic{graphic} class procedures and methods;  doing so will maximize the 
device independence and portabilty of your application program. \



Other Andrew Toolkit classes use the class \italic{graphic} to do output, 
and if you use them, you will be using \italic{graphic} indirectly to do 
your output.  For example, if your application uses the 
\italic{textview/text} classes, then your application will also be using 
graphic to do text output--only indirectly. \




\section{Quick reference list for Graphic}



\fixedtext{void \bold{graphic::}BitBltSize }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{srcX}, long \paramname{srcY}, long 
\paramname{dstX}, long \paramname{dstY}, long \paramname{Width}, long 
\paramname{Height}, struct graphic *\paramname{DstGraphic}, long 
\paramname{clipX}, long \paramname{clipY}, long \paramname{clipWidth}, long 
\paramname{clipHeight});} \


\fixedtext{void \bold{graphic::}BitBlt }\fixedindent{(struct graphic 
*\paramname{graphic}, struct rectangle *\paramname{SrcRect}, struct graphic 
*\paramname{DestGraphic}, struct point *\paramname{DstOrigin}, struct 
rectangle *\paramname{ClipRectList});} \


\fixedtext{struct graphic *\bold{graphic::}BlackPattern 
}\fixedindent{(struct graphic *\paramname{graphic});} \


\fixedtext{void \bold{graphic::}ClearClippingRect }\fixedindent{(struct 
graphic *\paramname{graphic});} \


\fixedtext{struct graphic *\bold{graphic::}CreateGraphic }\fixedindent{();} \


\fixedtext{void \bold{graphic::}DrawArcSize }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{x}, long \paramname{y}, long 
\paramname{width}, long \paramname{height}, short \paramname{StartAngle}, 
short \paramname{OffsetAngle});} \


\fixedtext{void \bold{graphic::}DrawArc }\fixedindent{(struct graphic 
*\paramname{graphic}, struct rectangle *\paramname{EnclRect}, short 
\paramname{StartAngle}, short \paramname{OffsetAngle});} \


\fixedtext{void \bold{graphic::}DrawLineToPt }\fixedindent{(struct graphic 
*\paramname{graphic}, struct point *\paramname{LineEnd});} \


\fixedtext{void \bold{graphic::}DrawLineTo }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{XEnd}, long \paramname{YEnd});} \


\fixedtext{void \bold{graphic::}DrawLine }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{DeltaX}, long \paramname{DeltaY});} \


\fixedtext{void \bold{graphic::}DrawOvalSize }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{x}, long \paramname{y}, long 
\paramname{width}, long \paramname{height});} \


\fixedtext{void \bold{graphic::}DrawOval }\fixedindent{(struct graphic 
*\paramname{graphic}, struct rectangle *\paramname{Rect});} \


\fixedtext{void \bold{graphic::}DrawPath }\fixedindent{(struct graphic 
*\paramname{graphic}, struct point *\paramname{PointArray}, short 
\paramname{PointCount});} \


\fixedtext{void \bold{graphic::}DrawPolygon }\fixedindent{(struct graphic 
*\paramname{graphic}, struct point *\paramname{PointArray}, short 
\paramname{PointCount});} \


\fixedtext{void \bold{graphic::}DrawRectSize }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{x}, long \paramname{y}, long 
\paramname{width}, long \paramname{height});} \


\fixedtext{void \bold{graphic::}DrawRect }\fixedindent{(struct graphic 
*\paramname{graphic}, struct rectangle *\paramname{Rect});} \


\fixedtext{void \bold{graphic::}DrawRRectSize }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{x}, long \paramname{y}, long 
\paramname{width}, long \paramname{height}, long \paramname{cornerWidth}, 
long \paramname{cornerHeight});} \


\fixedtext{void \bold{graphic::}DrawRRect }\fixedindent{(struct graphic 
*\paramname{graphic}, struct rectangle *\paramname{OuterBox}, struct 
rectangle *\paramname{InnerBox});} \


\fixedtext{void \bold{graphic::}DrawString }\fixedindent{(struct graphic 
*\paramname{graphic}, char *\paramname{Text}, short \paramname{Operation});} 

\fixedtext{void \bold{graphic::}DrawText }\fixedindent{(struct graphic 
*\paramname{graphic}, char *\paramname{Text}, long \paramname{TextLength}, 
short \paramname{Operation});} \


\fixedtext{void \bold{graphic::}DrawTrapezoid }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{topX}, long \paramname{topY}, long 
\paramname{topWidth}, long \paramname{bottomX}, long \paramname{bottomY}, 
long \paramname{bottomWidth});} \


\fixedtext{void \bold{graphic::}EraseRectSize }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{x}, long \paramname{y}, long 
\paramname{width}, long \paramname{height});} \


\fixedtext{void \bold{graphic::}EraseRect }\fixedindent{(struct graphic 
*\paramname{graphic}, struct rectangle *\paramname{Rect});} \


\fixedtext{void \bold{graphic::}EraseVisualRect }\fixedindent{(struct 
graphic *\paramname{graphic});} \


\fixedtext{void \bold{graphic::}FillArcSize }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{x}, long \paramname{y}, long 
\paramname{width}, long \paramname{height}, short \paramname{StartAngle}, 
short \paramname{OffsetAngle}, struct graphic *\paramname{Tile});} \


\fixedtext{void \bold{graphic::}FillArc }\fixedindent{(struct graphic 
*\paramname{graphic}, struct rectangle *\paramname{EnclRect}, short 
\paramname{StartAngle}, short \paramname{OffsetAngle}, struct graphic 
*\paramname{Tile});} \


\fixedtext{void \bold{graphic::}FillOvalSize }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{x}, long \paramname{y}, long 
\paramname{width}, long \paramname{height}, struct graphic 
*\paramname{Tile});} \



\fixedtext{void \bold{graphic::}FillOval }\fixedindent{(struct graphic 
*\paramname{graphic}, struct rectangle *\paramname{Rect}, struct graphic 
*\paramname{Tile});} \


\fixedtext{void \bold{graphic::}FillPolygon }\fixedindent{(struct graphic 
*\paramname{graphic}, struct point *\paramname{PointArray}, short 
\paramname{PointCount}, struct graphic *\paramname{Tile});} \


\fixedtext{void \bold{graphic::}FillRectSize }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{x}, long \paramname{y}, long 
\paramname{width}, long \paramname{height}, struct graphic 
*\paramname{Tile});} \



\fixedtext{void \bold{graphic::}FillRect }\fixedindent{(struct graphic 
*\paramname{graphic}, struct rectangle *\paramname{Rect}, struct graphic 
*\paramname{Tile});} \


\fixedtext{void \bold{graphic::}FillRgn }\fixedindent{(struct graphic 
*\paramname{graphic}, struct region *\paramname{Rgn}, struct graphic 
*\paramname{Tile});} \


\fixedtext{void \bold{graphic::}FillRRectSize }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{x}, long \paramname{y}, long 
\paramname{width}, long \paramname{height}, long \paramname{cornerWidth}, 
long \paramname{cornerHeight}, struct graphic *\paramname{Tile});} \


\fixedtext{void \bold{graphic::}FillRRect }\fixedindent{(struct graphic 
*\paramname{graphic}, struct rectangle *\paramname{OuterBox}, struct 
rectangle *\paramname{InnerBox}, struct graphic *\paramname{Tile});} \


\fixedtext{void \bold{graphic::}FillTrapezoid }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{topX}, long \paramname{topY}, long 
\paramname{topWidth}, long \paramname{bottomX}, long \paramname{bottomY}, 
long \paramname{bottomWidth}, struct graphic *\paramname{Tile});} \


\fixedtext{void \bold{graphic::}FinalizeObject }\fixedindent{(struct graphic 
*\paramname{self});} \


\fixedtext{void \bold{graphic::}FlushGraphics }\fixedindent{(struct graphic 
*\paramname{graphic});} \


\fixedtext{void \bold{graphic::}GetBackgroundColor }\fixedindent{(struct 
graphic *\paramname{graphic}, char **\paramname{colorName}, long 
*\paramname{red}, long *\paramname{green}, long *\paramname{blue});} \


\fixedtext{void \bold{graphic::}GetClippingRect }\fixedindent{(struct 
graphic *\paramname{graphic}, struct rectangle *\paramname{Rect});} \


\fixedtext{void \bold{graphic::}GetCurrentPt }\fixedindent{(struct graphic 
*\paramname{graphic}, struct point *\paramname{Pt});} \


\fixedtext{void \bold{graphic::}GetDefaultColors }\fixedindent{(char 
**\paramname{foreground}, char **\paramname{background});} \


\fixedtext{long \bold{graphic::}GetDevice }\fixedindent{(struct graphic 
*\paramname{graphic});} \


\fixedtext{long \bold{graphic::}GetEnclosedBottom }\fixedindent{(struct 
graphic *\paramname{graphic});} \


\fixedtext{void \bold{graphic::}GetEnclosedBounds }\fixedindent{(struct 
graphic *\paramname{graphic}, struct rectangle *\paramname{Rect});} \


\fixedtext{\bold{graphic::}GetEnclosedHeight }\fixedindent{(struct graphic 
*\paramname{graphic});} \


\fixedtext{\bold{graphic::}GetEnclosedLeft }\fixedindent{(struct graphic 
*\paramname{graphic});} \


\fixedtext{long \bold{graphic::}GetEnclosedRight }\fixedindent{(struct 
graphic *\paramname{graphic});} \


\fixedtext{\bold{graphic::}GetEnclosedTop }\fixedindent{(struct graphic 
*\paramname{graphic});} \


\fixedtext{\bold{graphic::}GetEnclosedWidth }\fixedindent{(struct graphic 
*\paramname{graphic});} \


\fixedtext{struct fontdesc *\bold{graphic::}GetFont }\fixedindent{(struct 
graphic *\paramname{graphic});} \


\fixedtext{void \bold{graphic::}GetForegroundColor }\fixedindent{(struct 
graphic *\paramname{graphic}, char **\paramname{colorName}, long 
*\paramname{red}, long *\paramname{green}, long *\paramname{blue});} \


\fixedtext{long \bold{graphic::}GetHorizontalResolution 
}\fixedindent{(struct graphic *\paramname{graphic});} \fixedtext{short 
\bold{graphic::}GetLineWidth }\fixedindent{(struct graphic 
*\paramname{graphic});} \


\fixedtext{long \bold{graphic::}GetLogicalBottom }\fixedindent{(struct 
graphic *\paramname{graphic});} \


\fixedtext{void \bold{graphic::}GetLogicalBounds }\fixedindent{(struct 
graphic *\paramname{graphic}, struct rectangle *\paramname{Rect});} \


\fixedtext{\bold{graphic::}GetLogicalHeight }\fixedindent{(struct graphic 
*\paramname{graphic});} \


\fixedtext{\bold{graphic::}GetLogicalLeft }\fixedindent{(struct graphic 
*\paramname{graphic});} \


\fixedtext{long \bold{graphic::}GetLogicalRight }\fixedindent{(struct 
graphic *\paramname{graphic});} \


\fixedtext{\bold{graphic::}GetLogicalTop }\fixedindent{(struct graphic 
*\paramname{graphic});} \


\fixedtext{\bold{graphic::}GetLogicalWidth }\fixedindent{(struct graphic 
*\paramname{graphic});} \


\fixedtext{short \bold{graphic::}GetSpaceShim }\fixedindent{(struct graphic 
*\paramname{graphic});} \


\fixedtext{short \bold{graphic::}GetTransferMode }\fixedindent{(struct 
graphic *\paramname{graphic});} \


\fixedtext{long \bold{graphic::}GetVerticalResolution }\fixedindent{(struct 
graphic *\paramname{graphic});} \


\fixedtext{long \bold{graphic::}GetVisualBottom }\fixedindent{(struct 
graphic *\paramname{graphic});} \


\fixedtext{void \bold{graphic::}GetVisualBounds }\fixedindent{(struct 
graphic *\paramname{graphic}, struct rectangle *\paramname{Rect});} \


\fixedtext{\bold{graphic::}GetVisualHeight }\fixedindent{(struct graphic 
*\paramname{graphic});} \


\fixedtext{\bold{graphic::}GetVisualLeft }\fixedindent{(struct graphic 
*\paramname{graphic});} \


\fixedtext{long \bold{graphic::}GetVisualRight }\fixedindent{(struct graphic 
*\paramname{graphic});} \


\fixedtext{\bold{graphic::}GetVisualTop }\fixedindent{(struct graphic 
*\paramname{graphic});} \


\fixedtext{\bold{graphic::}GetVisualWidth }\fixedindent{(struct graphic 
*\paramname{graphic});} \


\fixedtext{char *\bold{graphic::}GetWindowManagerType }\fixedindent{(struct 
graphic *\paramname{graphic});} \


\fixedtext{struct graphic *\bold{graphic::}GrayPattern }\fixedindent{(struct 
graphic *\paramname{graphic}, short \paramname{IntensityNum}, 
\paramname{IntensityDenom});} \


\fixedtext{boolean \bold{graphic::}InitializeObject }\fixedindent{(struct 
graphic *\paramname{self});} \


\fixedtext{void \bold{graphic::}InsertGraphicSize }\fixedindent{(struct 
graphic *\paramname{graphic}, struct graphic *\paramname{EnclosingGraphic}, 
long \paramname{xOriginInParent}, long \paramname{yOriginInParent}, long 
\paramname{width}, long \paramname{height});} \


\fixedtext{void \bold{graphic::}InsertGraphic }\fixedindent{(struct graphic 
*\paramname{graphic}, struct graphic *\paramname{EnclosingGraphic}, struct 
rectangle *\paramname{EnclosedRectangle});} \


\fixedtext{void \bold{graphic::}MoveLogicalOrigin }\fixedindent{(struct 
graphic *\paramname{graphic}, long \paramname{DeltaX}, long 
\paramname{DeltaY});} \


\fixedtext{void \bold{graphic::}MoveToPt }\fixedindent{(struct graphic 
*\paramname{graphic}, struct point *\paramname{Pt});} \


\fixedtext{void \bold{graphic::}MoveTo }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{NewX}, long \paramname{NewY});} \


\fixedtext{void \bold{graphic::}Move }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{DeltaX}, long \paramname{DeltaY});} \


\fixedtext{void \bold{graphic::}ReadPixImage }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{SrcX}, long \paramname{SrcY}, struct 
pixelimage *\paramname{DestPixels}, long \paramname{DestX}, long 
\paramname{DestY}, long \paramname{width}, long \paramname{height});} \


\fixedtext{void \bold{graphic::}RestoreGraphicsState }\fixedindent{(struct 
graphic *\paramname{graphic});} \


\fixedtext{void \bold{graphic::}SetBackgroundColor }\fixedindent{(struct 
graphic *\paramname{graphic}, char *\paramname{colorName}, long 
\paramname{red}, long \paramname{green}, long \paramname{blue});} \


\fixedtext{void \bold{graphic::}SetBitAtLoc }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{XPos}, long \paramname{YPos}, boolean 
\paramname{NewValue});} \


\fixedtext{void \bold{graphic::}SetClippingRectSize }\fixedindent{(struct 
graphic *\paramname{graphic}, long \paramname{x}, \paramname{y}, 
\paramname{w}, \paramname{h});} \


\fixedtext{void \bold{graphic::}SetClippingRect }\fixedindent{(struct 
graphic *\paramname{graphic}, struct rectangle 
*\paramname{AdditionalRect});} \


\fixedtext{void \bold{graphic::}SetDefaultColors }\fixedindent{(char 
*\paramname{foreground}, char *\paramname{background});} \


\fixedtext{void \bold{graphic::}SetFont }\fixedindent{(struct graphic 
*\paramname{graphic}, struct fontdesc *\paramname{ChosenFont});} \


\fixedtext{void \bold{graphic::}SetForegroundColor }\fixedindent{(struct 
graphic *\paramname{graphic}, char *\paramname{colorName}, long 
\paramname{red}, long \paramname{green}, long \paramname{blue});} \


\fixedtext{void \bold{graphic::}SetLineWidth }\fixedindent{(struct graphic 
*\paramname{graphic}, short \paramname{NewLineWidth});} \


\fixedtext{void \bold{graphic::}SetLogicalOriginPt }\fixedindent{(struct 
graphic *\paramname{graphic}, struct point *\paramname{Pt});} \


\fixedtext{void \bold{graphic::}SetLogicalOrigin }\fixedindent{(struct 
graphic *\paramname{graphic}, long \paramname{NewX}, long 
\paramname{NewY});} \


\fixedtext{void \bold{graphic::}SetSpaceShim }\fixedindent{(struct graphic 
*\paramname{graphic}, short \paramname{Amount});} \


\fixedtext{void \bold{graphic::}SetTransferMode }\fixedindent{(struct 
graphic *\paramname{graphic}, short \paramname{NewTransferMode});} \


\fixedtext{struct graphic *\bold{graphic::}WhitePattern 
}\fixedindent{(struct graphic *\paramname{graphic});} \fixedtext{void 
\bold{graphic::}WritePixImage }\fixedindent{(struct graphic 
*\paramname{graphic}, long \paramname{DestX}, long \paramname{DestY}, 
struct pixelimage *\paramname{SrcPixels}, long \paramname{SrcX}, long 
\paramname{SrcY}, long \paramname{width}, long \paramname{height});} \


\fixedtext{void \bold{graphic::}SetFGColor( struct graphic 
*\paramname{graphic, }double \paramname{red}, double \paramname{green}, 
double \paramname{blue} );

void \bold{graphic::}GetFGColor( struct graphic *\paramname{graphic, }double 
*\paramname{red}, double *\paramname{green}, double *\paramname{blue} );

void \bold{graphic::}SetBGColor( struct graphic *\paramname{graphic, }double 
\paramname{red}, double \paramname{green}, double \paramname{blue} );

void \bold{graphic::}GetBGColor( struct graphic *\paramname{graphic, }double 
*\paramname{red}, double *\paramname{green}, double *\paramname{blue} );

void \bold{graphic::}SetLineDash( struct graphic *\paramname{graphic, }char 
*\paramname{dashPattern}, int \paramname{dashOffset}, short 
\paramname{dashType} );

void \bold{graphic::}GetLineDash( struct graphic *\paramname{graphic, }char 
**\paramname{dashPattern}, int *\paramname{dashOffset}, short 
*\paramname{dashType} );

void \bold{graphic::}SetLineCap( struct graphic *\paramname{graphic, }short 
\paramname{NewLineCap} );

short \bold{graphic::}GetLineCap( struct graphic *\paramname{graphic });

void \bold{graphic::}SetLineJoin( struct graphic *\paramname{graphic, }short 
\paramname{NewLineJoin} );

short \bold{graphic::}GetLineJoin( struct graphic *\paramname{graphic }); \


long \bold{graphic::}DisplayClass( struct graphic *\paramname{graphic });

boolean \bold{graphic}_IsImageInverted( struct graphic *\paramname{graphic 
});}


\section{Overview of Graphic}


\subsection{A pixel map} \indexi{Pixel map} \indexi{Graphic++Pixel map}


The class \italic{graphic} provides a \italic{pixmap}, that is, a pixel 
map.  A pixel map is a \italic{rectangle} of bits together with a mapping 
function that maps the bits to picture elements, or pixels, on the 
workstation display.  The rectangle of bits provides graphic storage.  When 
an image is displayed, each bit in the rectangle is mapped to a 
corresponding pixel on the workstation display.  The value of each bit 
together with a transfer mode (explained below), determines how the bit's 
corresponding picture element is illuminated. \



The pixel map is associated with a \italic{graphic} object in one of two 
ways.  First,  the \italic{Interaction Manager} explicitly links its 
\italic{graphic} object, a \italic{window,} to a \italic{pixmap} when you 
set the \italic{Interaction Manager}'s view.   Second, the \italic{pixmap} 
is linked implicitly and relative to the parent when you insert a graphic 
object into its parent by calling \italic{graphic::InsertGraphic} before 
beginning to draw when setting up view hierarchies. You must use one of 
these methods to associate a newly created \italic{graphic} object with its 
pixel map. \



The class \italic{pixmap} manages any mapping that may be necessary from 
the graphic's coordinate system to the underlying window manager's 
coordinate system. The applications programmer should not need to use any 
of the methods or class procedures in pixmap. \



\begindata{bp,537975800}
Version 2
n 0
\enddata{bp,537975800}
\view{bpv,537975800,0,0,0}
\subsection{The logical rectangle}  \indexi{Logical rectangle} 
\indexi{Rectangle++Logical}

\indexi{Graphic++Logical rectangle}


The class \italic{graphic} supplies a logical rectangle which defines a 
coordinate system.   The units are pixels.  The coordinates of the logical 
rectangle are initially given by (0,0) at the origin on the rectangle's top 
left to  2\superscript{32} - 1, 2\superscript{32}-1) at its bottom right. 
 You can draw anywhere in this logical unsigned 32-bit coordinate space. \



You can also move the logical origin from (0,0) to another point.  There 
are methods for getting the dimensions of the logical rectangle. \



\subsection{The visual rectangle} \indexi{Visual rectangle}

\indexi{Rectangle++Visual} \


\indexi{Graphic++Visual rectangle}The logical rectangle, \italic{lr}, gives 
the coordinates that you can scale your drawing to.  The class 
\italic{graphic} also provides a visual rectangle, \italic{vr},  that gives 
the coordinates for what is potentially visible in the window.  To 
understand \italic{lr} and \italic{vr}, suppose that a multi-media editor 
were displaying some text and a drawing,  and that the drawing happens to 
be at the very bottom of the window.  If the graphic's rectangle, 
\italic{lr}, falls outside the window boundary, and the drawing is relative 
to \italic{lr}, then the drawing will be clipped to the graphic's visual 
rectangle. \



The part of the drawing that falls within the coordinates given by the 
visual rectangle normally corresponds to what the user sees on the screen, 
except if another drawing were laid over the first (e.g., a message box 
could be temporarily laid on top of all or part of the drawing). \



You must attend to the visual rectangle if you wish to: \



\itemize{Scale the size of your drawing to the size of its visual region. 
 In this case, you would do your drawing relative to the visual rectangle 
rather than the rectangle. \



Produce a clipped drawing with maximum efficiency.  In this case, you would 
scale your drawing relative to \italic{lr}, but you would not actually draw 
except when the coordinates fell within \italic{vr}. \


}

Otherwise you can ignore \italic{vr} and simply draw within the dimensions 
given by \italic{lr}.  If you do, your drawing will automatically be 
clipped to \italic{vr}. \



\subsection{The enclosed rectangle}

\indexi{Rectangle++Enclosed} \indexi{Enclosed rectangle}

\indexi{Graphic++Enclosed rectangle}Finally, graphic supplies an enclosed 
rectangle.  The enclosed rectangle is the same as the logical rectangle, 
except that the coordinates are expressed in terms of the parent graphic's 
logical coordinate system.  The enclosed coordinate system is undefined if 
the graphic has not been inserted in a parent graphic or the Interaction 
Manager's view. \



When you draw your image, you do not have to pay attention to your object's 
enclosed rectangle coordinate system.  Its values are updated automatically 
when you insert the graphic inside its parent.  The values do not change 
unless the object changes position on the screen or the parent's logical 
origin changes, but to change the position of an object on the screen, you 
must reinsert the object inside its parent. \



If your object has children, then you may be interested in their enclosed 
rectangle coordinates.  The class graphic provides a method for getting 
their values. \



\subsection{The local graphic state} \indexi{Graphic++Local state}


Each instance of a graphic has the following elements in its graphic state: 


\description{Current point\formatnote{  --  }The point from which all line 
and text drawing will be done.  It is initialized to (0,0). \



Line width\formatnote{  --  }The line width determines the width, in 
pixels, of drawn lines. It is initialized to one pixel. \



Current font\formatnote{  --  }The current font determines the font drawing 
text. The initial value of the font is Andysans 12. \



Space shim \formatnote{  --  }The space shim controls the amount of space 
that will be added to the right of space characters.  It is initialized to 
0 pixels. \



Transfer mode \formatnote{  --  }The transfer mode determines how bits will 
be turned on and off on the screen when drawing lines, writing text, 
transferring blocks of bits or filling figures.  It is initialized to 
\smaller{graphic::COPY}. \



Clipping rectangle \formatnote{  --  }The clipping rectangle allows you to 
use drawing methods more efficiently.  It is initially \smaller{NULL}, that 
is, the drawing methods do no clipping. \


}

The class graphic provides methods for setting these state variables and 
accessing their values.  The values are local to the graphic object. \



\subsection{The global graphic state} \indexi{Graphic++Global state}


The underlying window management system maintains a global graphics state. 
 The values of the global state determine actual output.  The values of 
your object's graphic state remain local to the object until the object 
requests that its graphics state be restored to the global state.  The 
request sets the global graphic state to your object's local graphic state. 


\subsection{Protocols} \indexi{Graphic++Protocols}


\paragraph{Initialization}  \indexi{Graphic++Initializing}


If you are creating a subclass of the class \italic{graphic} and want to 
override the default initial values for the \italic{graphic} state, then 
you should initialize the graphic state in the \italic{InitializeObject} 
procedure. \


\begindata{bp,537984584}
Version 2
n 0
\enddata{bp,537984584}
\view{bpv,537984584,1,0,0}
\paragraph{Before drawing}  \indexi{Graphic++Drawing}


If you create an object that is an instance of any subclass of 
\italic{graphic,} then it will inherit the graphic data structures and 
methods and you will be able to draw on the screen.  Before doing any 
drawing, however, you must do one of the following: \



\leftindent{a) Call \italic{im_SetView} \indexi{ \italic{im_SetView}}

 to insert the object into the the \italic{Interaction Manager}'s window 
(see \bold{Interaction Manager}), or


(b) call \italic{graphic::InsertGraphic}

\indexi{ \italic{graphic::InsertGraphic}} \


to insert the object into its parent's graphic (see \bold{View}). \


}

If you fail to insert the object, the mapping from the logical coordinate 
system to the underlying window management system will be undefined. \



The graphic object does not store any drawing that you may do, so it is not 
useful to draw in a graphic that is not inserted. \



\paragraph{Setting the global graphic state} \indexi{Graphic++Global state}


Since other objects will also potentially be setting the global graphic 
state, you must restore your objects's graphic state any time another 
object may have had an opportunity to set the global graphic state since 
the last time you did.  The restore will set the global graphic state to 
your local graphic state. \



\paragraph{Redraw requests} \indexi{Graphic++Redraw requests}


Normally, you will not use graphics directly but will work with view, a 
subclass of graphics that provides methods for input, including redrawing 
requests (see section \bold{View}). \



\begindata{bp,537987304}
Version 2
n 0
\enddata{bp,537987304}
\view{bpv,537987304,2,0,0}
\subsection{Creating and initializing graphics} \paragraph{Creating an 
instance of a graphic} \indexi{Graphic++Creating}

\indexi{ \italic{graphic::CreateGraphic}}

\example{struct graphic *graphic::CreateGraphic() \


}
\leftindent{\bold{Class procedure description.}  Creates an instance of the 
class \italic{graphic} and initializes it. \


}

\paragraph{Inserting a graphic} \indexi{Graphic++Inserting}


\example{void graphic::InsertGraphic(EnclosedGraphic, EnclosingGraphic, 
EnclosedRectangle) \


struct graphic *EnclosedGraphic;  \


struct graphic *EnclosingGraphic;  \


struct rectangle *EnclosedRectangle;} \



\leftindent{\bold{Method description.  }\italic{graphic::InsertGraphic} 
inserts the graphic \italic{EnclosedGraphic} into 
\italic{EnclosingGraphic}. \



\bold{Side effects.}  \italic{EnclosedGraphic'}s logical, visual, and 
enclosed rectangles are set to the values provided by 
\italic{EnclosedRectangle}.  The enclosed graphic clipping rectangle is set 
to \smaller{NULL}. \



\bold{Usage.}  When you create a new graphic object, you should insert it 
into its parent's graphic.  To move a graphic object, you must reinsert it. 

}

\paragraph{Restoring the graphic state} \indexi{Graphic++Restoring state}

\indexi{ \italic{graphic::RestoreGraphicsState}}

\example{void graphic::RestoreGraphicsState(grphc) \


struct graphic *grphc;} \



\leftindent{\bold{Method description. 
} \italic{graphic::RestoreGraphicsState} sets the global graphic state 
variables to the values of  \italic{grphc}'s global state variables.  The 
state variables include the line width for drawing lines, the font for 
drawing text, the clipping rectangle, the current point for drawing lines 
and text, the  space shims, and for drawing. \



\bold{Usage.}  Before drawing, you should call 
\italic{graphic::RestoreGraphicsState} in order to set the global graphic 
state variables.  Since other objects will also potentially be setting the 
global graphic state, you must restore your objects's graphic state any 
time another object may have had an opportunity to set the global graphic 
state since the last time you did.  The restore will set the global graphic 
state to your local graphic state. \


}
\begindata{bp,537992088}
Version 2
n 0
\enddata{bp,537992088}
\view{bpv,537992088,3,0,0}
\subsection{The current point} \indexi{Graphic++Current point}


Many drawing methods use a \italic{current point} as a reference point. For 
example, lines are drawn from the \italic{current point} to one of the 
following: \


\itemize{
a point relative to (0,0) in the logical rectangle \indexi{Logical rectangle

}
an (x,y) coordinate relative to (0,0) in the logical rectangle


a coordinate relative to the current point}


The \italic{current point} is defined after line-drawing methods, but is 
undefined after all other drawing methods and after a window changes size. \



For efficiency reasons, a \italic{point} is not an object. \indexi{Point} 
To use points, you must \italic{#include point.h} from the Andrew Toolkit 
library.  A point can be thought of as an (x,y) coordinate. 
\indexi{Coordinates}



\paragraph{Moving the current point to a new point} \indexi{Graphic++Moving}

\indexi{ \italic{graphic::MoveToPt}}

\example{void graphic::MoveToPt(grphc,NewPosition) \


struct graphic *grphc;  \


struct point *NewPosition;} \



\leftindent{\bold{Method description.  }\italic{graphic::MoveToPt}  sets the 
\italic{current point} to the point, \italic{NewPosition}. \



\bold{Example.} \



\example{#include "point.h"


struct point *pt;  struct graphic *go;   /* a graphic object */


go = graphic::New ():  \bold{...}  \description{pt = 
point_CreatePoint(graphic::GetVisualLeft (go), graphic::GetVisualTop(go);} 
 graphic::MoveToPt (grphc, pt); \


}

The call to \italic{point_CreatePoint} assigns \italic{pt} to the graphic 
object's visual origin.  Then the call to \italic{graphic::MoveToPt} sets 
the current point to \italic{pt}. \


}\
\begindata{bp,537996488}
Version 2
n 0
\enddata{bp,537996488}
\view{bpv,537996488,4,0,0}
\paragraph{Moving the current point to a new (x,y) coordinate} 
\indexi{Graphic++Moving}

\indexi{ \italic{graphic::MoveTo}}

\example{void graphic::MoveTo(grphc, NewX, NewY) \


struct graphic *grphc;  \


long NewY;  \


long NewX;} \



\leftindent{\bold{Method description.  }\italic{graphic::MoveTo} moves the 
\italic{current point} to \italic{(NewX, Newy) }where the 32-bit integer 
\italic{NewX} is the horizontal coordinate and \italic{NewY} the vertical. \



}
\paragraph{Moving the current point relative to the current point} 
\indexi{Graphic++Moving}

\indexi{ \italic{graphic::Move}}

\example{void graphic::Move(grphc, DeltaX, DeltaY) \


struct graphic *grphc;  \


long DeltaX;  long DeltaY;} \



\leftindent{\bold{Method description.}   \italic{graphic::Move} moves the 
\italic{current point} to \italic{(current x + DeltaX, current y + DeltaY)} 
where the 32-bit integer \italic{DeltaX} is the horizontal distance from 
the current point to the desired point, \italic{DeltaY} the vertical 
distance. \



\bold{Example.} \


\example{
struct graphic *go;   /* a graphic object */


go = graphic::New (); \



\bold{...} \



graphic::MoveTo (grphc, 20,30);  \


graphic::Move (grphc, 5, 10);} \



\italic{graphic::MoveTo (grphc, 20, 30)} moves the current point to the 
logical coordinate (20,30).  Then \italic{graphic::Move (grphc, 5, 10)} 
moves the current point to (20+5, 30+10), that is, (25,40). \


}



\paragraph{Getting the current point location} \indexi{Graphic++Getting 
location}

\indexi{ \italic{graphic::GetCurrent}}

\example{void graphic::GetCurrentPt(grphc, Pt) \


struct graphic *grphc;  \


struct point *Pt;} \



\leftindent{\bold{Method description.  }\italic{graphic::GetCurrentPt}  gets 
the current point location. \



\bold{Example.} \



\example{#include "point.h"


struct point *pt;  \


struct graphic *go;   /* a graphic object */


go = graphic::New ();  \



\bold{...}  \



graphic::MoveToPt (grphc, 20,30);  graphic::GetCurrentPt (grphc, &pt); \


}

The call to \italic{point_CreatePoint} assigns \italic{pt} to the graphic 
object's visual origin.  Then the call to \italic{graphic::MoveToPt} sets 
the current point to \italic{pt}. \


}

\begindata{bp,538002824}
Version 2
n 0
\enddata{bp,538002824}
\view{bpv,538002824,5,0,0}
\subsection{Drawing Lines}


Lines are drawn with black (foreground color) "points" using the current 
transfer mode and line width. \



\paragraph{Drawing a line from the current point to another point} 
\indexi{Graphic++Drawing lines} \indexi{ \italic{graphic::DrawLineToPt}}

\example{void graphic::DrawLineToPt(grphc,LineEnd) \


struct graphic *grphc;  \


struct point *LineEnd;} \



\leftindent{\bold{Method description.  }\italic{graphic::DrawLineToPt} draws 
a line from the current point to the point \italic{LineEnd}.   The width of 
the line is determined by the graphic state \italic{LineWidth}; the default 
width is one pixel. \



\bold{Side effect.}  The current point is moved to \italic{LineEnd}. \



}
\paragraph{Drawing a line from the current point to a  (x,y) coordinate} 
\indexi{Graphic++Drawing lines}

\indexi{ \italic{graphic::DrawLineTo}}

\example{void graphic::DrawLineTo(grphc, XEnd, YEnd) \


struct graphic *grphc;  \


long YEnd;  \


long XEnd;} \



\leftindent{\bold{Method description.  }\italic{graphic::DrawLineTo} draws a 
line from the current point to the coordinate (XEnd, YEnd).  The width of 
the line is determined by the graphic state \italic{LineWidth}; the default 
width is one pixel. \



\bold{Side effect.}  Moves the current point to (\italic{XEnd, YEnd}). \


}


\paragraph{Drawing a line from the current point to a coordinate relative 
to the current point}

\indexi{Graphic++Drawing lines} \


\indexi{ \italic{graphic::DrawLine}}

\example{void graphic::DrawLine(grphc, DeltaX, DeltaY) \


struct graphic *grphc;  \


long DeltaY;  \


long DeltaX;} \



\leftindent{\bold{Method description.  }\italic{ graphic::DrawLine} draws a 
line from the current point (CurrentX, CurrentY) to the coordinate 
(CurrentX+\italic{DeltaX}, CurrentY+\italic{DeltaY}).  The width of the 
line is determined by the graphic state \italic{LineWidth};  the default 
width is one pixel. \



\bold{Side effect.}  Moves the current point to (CurrentX+\italic{DeltaX}, 
CurrentY+\italic{DeltaY}). \


}
\begindata{bp,538008440}
Version 2
n 0
\enddata{bp,538008440}
\view{bpv,538008440,6,0,0}
\subsection{The current line width}


The graphic state variable, \italic{Line Width}, controls the width of 
drawn lines.  Its default value is one pixel wide.  There is method for 
setting the \italic{Line Width} and for getting its current value. \



\paragraph{Setting the line width}\italic{\index{graphic::SetLineWidth}}


\example{void graphic::SetLineWidth(grphc,NewLineWidth) 
 \indexi{Graphic++Set line width}

struct graphic *grphc;  \


short NewLineWidth;}  \indexi{ }\



\leftindent{\bold{Method description.}   \italic{graphic::SetLineWidth} sets 
the line width to NewLineWidth.  The unit is pixels and the value can range 
from 0 pixels to 2\formatnote{@+}[8}-1.  Other values are undefined. \



\paragraph{Getting the line width} \indexi{Graphic++Get line width}

\indexi{ \italic{graphic::GetLineWidth}}

\example{short graphic::GetLineWidth(grphc) \


struct graphic *grphc;} \



\leftindent{\bold{Method description.}  \italic{graphic::GetLineWidth} 
returns the current line width, which can range from 0 to 28-1 pixels.  The 
default value for the line width is one pixel. \



\bold{Example.} \



\example{short CLineWidth;  \


struct graphic *grphc; \



grphc = graphic::New ();


... \



CLineWidth = graphic::GetLineWidth(grphc);

graphic::SetLineWidth (CLineWidth+CLineWidth); \


}
\italic{CLineWidth = graphic::GetLineWidth} stores the current line width in 
the short variable \italic{CLineWidth}; then \italic{graphic::SetLineWidth 
(CLineWidth+CLineWidth)} doubles the current line width. \


}
\bold{\bigger{Line Styles


}}\bold{Setting the line dash

}
\example{void graphic\bold{_}SetLineDash( graphic, dashPattern, dashOffset, 
dashType );

struct graphic *\paramname{graphic;

}char *\paramname{dashPattern;

}int \paramname{dashOffset;

}short \paramname{dashType;

}}
\indent{\bold{Method description. } \italic{graphic::SetLineDash }sets the 
current line dash style for line drawing (under X11). The 
\italic{dashPattern} argument is an array of characters whose integer 
values specify the pattern of on-off dashes desired. This array must be 
terminated with a 0 (zero) value. The offset argument defines the phase of 
the pattern, specifying how many pixels into the dashPattern the pattern 
should actually begin on any single line drawing operation. The 
\italic{dashType} argument can be any of the following symbolics:


\typewriter{graphic::LineSolid} -- solid, non-dashed lines.

\typewriter{graphic::LineDoubleDash} -- even and odd elements of the 
dashPattern are drawn in the foreground and background colors, respectively.

\typewriter{graphic::LineOnOffDash }-- only the even elements of the 
dashPattern are drawn.


A NULL \paramname{dashPattern} argument will set the graphic state to draw 
solid lines. Solid lines are drawn be default until a dash pattern and dash 
type are set.}


\bold{Getting the line dash}

\bold{
}\example{void graphic::GetLineDash( graphic, dashPattern,  dashOffset, 
 dashType );

struct graphic *graphic;

char **dashPattern;

int *dashOffset;

short *dashType;}


\indent{\bold{Method description}. \italic{graphic::GetLineDash} returns the 
current values of the line dash style attributes of the given graphic via 
the pointer arguments passed in.}


\bold{Setting the line cap

}
\example{void graphic\bold{_}SetLineCap( graphic, NewLineCap );

struct graphic *\paramname{graphic;

}short \paramname{NewLineCap;}}


\indent{\bold{Method description}. \italic{graphic::SetLineCap} sets the 
line cap style for the given graphic, which defines how the endpoints of a 
path are drawn (under X11). The \paramname{NewLineCap} argument can be any 
of the following symbolics:


\typewriter{\typewriter{graphic::CapBut}t} -- the line is square at the 
endpoint (perpenedicular to the slope of the line) with no projection 
beyond.

\typewriter{graphic::CapNotLast} -- same as graphic::CapButt, except for a 
line width of zero, the final endpoint is not drawn.

\typewriter{graphic::CapRound} -- The line has a circular arc with the 
diameter equal to the line width, centered on the endpoint.

\typewriter{graphic::CapProjecting} -- The line is square at the end, but 
the path continues beyond the endpoint for a distance equal to half the 
line width.


The default line cap is \typewriter{graphic::CapButt}. }\



\bold{Getting the line cap

}
\example{short graphic\bold{_}GetLineCap( graphic\paramname{ });

struct graphic *\paramname{graphic;}}


\indent{\bold{Method Description}. \italic{graphic::GetLineCap} returns the 
currently set line cap style.}


\bold{Setting the line join

}
\example{void graphic\bold{_}SetLineJoin(graphic, NewLineJoin);

struct graphic *\paramname{graphic;

}short \paramname{NewLineJoin;}}\paramname{

}
\indent{\bold{Method description}. \italic{graphic::SetLineJoin} sets the 
line join style for the given graphic, which defines how corners are drawn 
for wide lines (under X11). The NewLineJoin argument can be any of the 
following symbolics:


\typewriter{graphic::JoinMiter} -- the outer edges of two lines extend to 
meet at an angle. If the angle is less than 11 degrees, then a 
graphic::JoinBevel style join is used instead.

\typewriter{graphic::JoinRound} -- The corner is a circular arc with the 
diameter equal to the line width, centered on the joinpoint.

\typewriter{graphic::JoinBevel} -- The corner has 
\typewriter{graphic::CapButt} style endpoints, with the triangular notch 
filled.


The default line join is \typewriter{graphic::JoinMiter}. }\



\bold{Getting the line join

}
\example{short \bold{graphic::}GetLineJoin( graphic );

struct graphic *\paramname{graphic; }}\



\indent{\bold{Method description}: \italic{graphic::GetLineJoin }returns the 
currently set line join style.}

 \
\begindata{bp,538021256}
Version 2
n 0
\enddata{bp,538021256}
\view{bpv,538021256,7,0,0}

\subsection{The current font} \indexi{Graphic++Fonts}


Text output appears in the currently selected font.  Fonts are named by 
strings,  for example "Andy12i" (Andy,12-point, italic) or "Andysans14b" 
(Andysans, 14-point,  bold).  You can find out what fonts are available by 
using \italic{ls} to examine the contents of the directory 
$ANDREWDIR/X11/fonts.  If you want your program to be portable to other 
Andrew environments, you should use the \italic{andy}, \italic{andysans}, 
\italic{andytype} font families.  To see what a specific font looks like, 
use the X program \bold{xfd} (see the online help). \




When you request a font, the Andrew Toolkit returns a handle representing 
its best effort at supplying the font you specify.  The values of a font 
may change at redraw time  because a user with multiple displays might move 
an existing window to a display with different hardware characteristics. 
 So if your program examines font structures, you must reassign values when 
a redraw is requested. \




\paragraph{Setting the current font} \indexi{Graphic++Set font}

\indexi{ \italic{graphic::SetFont}}

\example{void graphic::SetFont(grphc, ChosenFont) \


struct graphic *grphc;  \


struct fontdesc *ChosenFont;} \



\leftindent{
\bold{Method description.  }\italic{graphic::SetFont} sets the current font 
for the graphic object \italic{grphc} to the font descriptor 
\italic{ChosenFont.}   The default current font is \italic{AndySans12}


\bold{Usage.}  You must call \italic{fontdesc_Create} to get a pointer to a 
font descriptor (see the chapter, Font Descriptors), then call 
\italic{graphic::SetFont} to set the graphic object's current font to the 
font descriptor. \



\bold{Example.} \



\example{struct graphic *grphc; \



grphc = graphic::New(); \



\bold{...} \



graphic::SetFont (grphc, fontdesc_Create ("andysans", fontdesc_PLAIN, 12));} 


sets the graphic object \italic{grphc}'s current font to 
\italic{Andysans12}. \


}



\paragraph{Getting the current font} \indexi{Graphic++Get font}

\indexi{ \italic{graphic::GetFont}}

\example{struct fontdesc *graphic::GetFont(grphc) \


struct graphic *grphc;} \



\leftindent{\bold{Method description.}   \italic{graphic::GetFont} returns 
\italic{grphc}'s current font. \


}


\begindata{bp,538026488}
Version 2
n 0
\enddata{bp,538026488}
\view{bpv,538026488,8,0,0}
\subsection{Drawing Text} \indexi{Graphic++Text}


\paragraph{Drawing a string} \indexi{Graphic++Draw text string}

\indexi{ \italic{graphic::DrawString}}

\example{void graphic::DrawString(grphc, String, Operation) \


struct graphic *grphc;  \


char *String;  \


long Operation;} \



\leftindent{
\bold{Method description.}  Text is drawn by "spraying" black through a 
character stencil and combining it with the pixels on the screen using the 
current transfer function. \italic{graphic::DrawString} draws the string 
\italic{String} in the \italic{grphc}'s current font at \italic{grphc}'s 
current point \italic{(cx, cy)}.  The relationship between the string and 
the current position is specified by the parameter \italic{Operation}. 
 Values for \italic{Operation} are constructed by or-ing together a 
horizontal and a vertical alignment option. \



The horizontal alignment options are: \



\formatnote{\italic{graphic::\smaller{NOMOVEMENT}}\formatnote{  --  }the 
origin of the string will be at \italic{cx}.


\italic{graphic::\smaller{ATRIGHT}}\formatnote{  --  }the rightmost part of 
the string will be at \italic{cx}.


\italic{graphic::\smaller{ATLEFT}}\formatnote{  --  }the leftmost part of 
the string will be at \italic{cx}.


\italic{graphic::\smaller{BETWEENLEFTANDRIGHT}}\formatnote{  --  }the center 
of the string will be at \italic{cx}.



}The vertical alignment options are: \



\formatnote{\italic{graphic::\smaller{NOMOVEMENT}}\formatnote{  --  }the 
origin of the string will be at \italic{cy}.


\italic{graphic::\smaller{ATTOP}}\formatnote{  --  }the topmost part of the 
string will be at \italic{cy}.


\italic{graphic::\smaller{ATBOTTOM}}\formatnote{  --  }the bottommost part 
of the string, including any descenders, will be at \italic{cy}.


\italic{graphic::\smaller{ATBASELINE}}\formatnote{  --  }the baseline of the 
string will be at \italic{cy}.


\italic{graphic::\smaller{BETWEENTOPANDBASELINE}}\formatnote{  --  }the 
center point of the string will be at \italic{cy}.  The center is 
calculated from the topmost part of the string to the bottomost part, which 
will include descenders.


\italic{graphic::\smaller{BETWEENTOPANDBOTTOM}}\formatnote{  --  }the center 
of the string will be at \italic{cy}.  The center is calculated from the 
topmost part of the string to the baseline of the string.  No account is 
taken of descenders. This is likely to look better than 
\italic{graphic::\smaller{BETWEENTOPANDBASELINE}} in most cases.



}Either option (horizontal or vertical alignment) may be omitted. 
 \italic{graphic::\smaller{ATBASELINE}} and \italic{graphic::\smaller{ATLEFT}} 
will be used as defaults. \


}
\begindata{bp,538035656}
Version 2
n 0
\enddata{bp,538035656}
\view{bpv,538035656,9,0,0}
\paragraph{Drawing text} \indexi{Graphic++Draw text}

\indexi{ \italic{graphic::DrawText}}

\example{void graphic::DrawText(grphc, Text, TextLength, Operation) struct 
graphic *grphc;  \


char *Text;  \


long TextLength;  \


long Operation;} \



\leftindent{\bold{Method description.  }\italic{graphic::DrawText}  draws 
\italic{TextLength} number of characters from the string \italic{Text}.  In 
contrast, \italic{graphic::DrawString} draws all the characters in the 
string (i.e., it draws until it encounters a \smaller{NULL} character). 
 Except for this difference, the two methods are alike. \


}


\paragraph{Setting a shim value for spaces} \indexi{Graphic++Set space shim}

\indexi{ \italic{graphic::SetSpaceShim}}

\example{void graphic::SetSpaceShim(grphc,n) \


struct graphic *grphc;  \


short n;} \



\leftindent{\bold{Method description.  }\italic{graphic::SetSpaceShim} sets 
the amount of space that will be added to the right of space characters 
(after the character shim) to \italic{n} pixels.  The default value is 0 
pixels. \



\bold{Usage.}  This method has its primary use in the Andrew Toolkit system 
applications like the object \italic{text}. \



}
\paragraph{Getting the shim value for spaces} \indexi{Graphic++Get space 
shim}

\indexi{ \italic{graphic::GetSpaceShim}}

\example{short graphic::GetSpaceShim(grphc) \


struct graphic *grphc; }\



\leftindent{\bold{Method description.}  \italic{graphic::GetSpaceShim} gets 
the space shim value. \


}\
\begindata{bp,538040168}
Version 2
n 0
\enddata{bp,538040168}
\view{bpv,538040168,10,0,0}
\subsection{Drawing regions} \paragraph{Drawing a rectangle} 
\indexi{Graphic++Draw rectangle}

\indexi{ \italic{graphic::DrawRect}}

\example{void graphic::DrawRect(grphc, Rect) \


struct graphic *grphc;  \


struct rectangle *Rect;} \



\leftindent{\bold{Method description.  }\italic{graphic::DrawRect} draws a 
rectangle in \italic{grphc} at the coordinates specified by the rectangle 
\italic{Rect}. \



\bold{Usage.}  For efficiency reasons, a \italic{rectangle} is not an 
object.  To use rectangles, you must #include \italic{rectangle.h} from the 
Andrew Toolkit library.  A rectangle can be specified by an (x,y) 
coordinate, a \italic{width} and a \italic{height} (see Rectangles), or by 
an upper left and a lower right corner.   The rectangle specifications 
conform to the X standard.



}\paragraph{Drawing a polygon} \indexi{Graphic++Draw polygon}

\indexi{ \italic{graphic::DrawPolygon}}

\example{void graphic::DrawPolygon(grphc, PointArray, PointCount) struct 
graphic *grphc;  \


struct point *PointArray;  \


short PointCount;} \



\leftindent{\bold{Method description.}   \italic{graphic::DrawPolygon} 
provides a placeholder for functions drawing sided, enclosed figures that 
are not rectangles.  It is assumed that the last point is connected to the 
first point. \



}
\paragraph{Drawing an oval} \indexi{Graphic++Draw oval}

\indexi{ \italic{graphic::DrawOval}}

\example{void graphic::DrawOval(grphc, Rect) \


struct graphic *grphc;  \


struct rectangle *Rect;} \



\leftindent{\bold{Method description.}   \italic{graphic::DrawOval} is the 
same as \italic{graphic::DrawPolygon }except it is used for drawing oval 
figures.} \


\begindata{bp,538045112}
Version 2
n 0
\enddata{bp,538045112}
\view{bpv,538045112,11,0,0}
\paragraph{Drawing arcs} \indexi{Graphic++Draw arc}

\indexi{ \italic{graphic::DrawArc}}

\example{void graphic::DrawArc(grphc, EnclRect, StartAngle, OffsetAngle) \


struct graphic *grphc;  \


struct rectangle *EnclRect;  \


short StartAngle;  \


short OffsetAngle;} \



\leftindent{\bold{Method description.}   \italic{graphic::DrawArc} is the 
same as \italic{graphic::DrawPolygon }except it is used for drawing arcs. \



\bold{Usage.}  Angles are degrees from 12 o'clock, with clockwise the 
positive direction. \




}\paragraph{Drawing a rounded rectangle} \indexi{Graphic++Draw rounded 
rectangle}

\indexi{ \italic{graphic::DrawRRect}}

\example{void graphic::DrawRRect(grphc,OuterBox, InnerBox) \


struct graphic *grphc;  \


struct rectangle *OuterBox;  \


struct rectangle *InnerBox;} \



\leftindent{\bold{Method description.}   \italic{graphic::DrawRRect} is the 
same as \italic{graphic::DrawPolygon }except it is used for drawing a 
rounded rectangle, that is, a rectangle with rounded corners. \



}
\subsection{Filling regions} \


The fill methods take a Tile argument, which is used to stipple (mask with 
a pattern) the fill operations. Under X11, if the Tile argument is NULL, 
the result is a solid fill of the current foreground color. On monochrome 
displays, attempts to use color will set an approximation stipple tile that 
will be used on fills when the Tile argument is NULL (if it is not NULL, 
the Tile argument overrides this approximation tile). \



\paragraph{Filling a rectangle} \indexi{Graphic++Fill rectangle}

\indexi{ \italic{graphic::FillRect}}

\example{void graphic::FillRect(grphc, Rect, Tile) \


struct graphic *grphc;  \


struct rectangle *Rect;  \


struct graphic *Tile;} \



\leftindent{\bold{Method description.}   \italic{graphic::FillRect} fills a 
rectangle in grphc with the specified graphic, \italic{Tile}. \



\bold{Usage.}  If Tile is 1, then black; if 0, then white.} \





\paragraph{Filling a polygon} \indexi{Graphic++Fill polygon}

\indexi{ \italic{graphic::FillPolygon}}

\example{void graphic::FillPolygon(grphc,PointArray, PointCount, Tile) \


struct graphic *grphc;  \


struct point *PointArray;  \


short PointCount;  \


struct graphic *Tile;} \



\leftindent{\bold{Method description.}   \italic{graphic::FillPolygon} is 
used to fill polygon regions. \



}
\paragraph{Filling an oval} \indexi{Graphic++Fill oval}

\indexi{ \italic{graphic::FillOval}}

\example{void graphic::FillOval(grphc, Rect, Tile) \


struct graphic *grphc;  \


struct rectangle *Rect;  \


struct graphic *Tile;} \



\leftindent{\bold{Method description.}   \italic{graphic::FillOval} is used 
to fill oval regions.} \




\paragraph{Filling in an arc} \indexi{Graphic++Fill arc}

\indexi{ \italic{graphic::FillArc}}

\example{void graphic::FillArc(grphc, EnclRect,StartAngle, OffsetAngle,Tile) 

struct graphic *grphc;  \


struct rectangle *EnclRect;  \


short StartAngle;  short OffsetAngle;  \


struct graphic *Tile;} \



\leftindent{\bold{Method description.}   \italic{graphic::FillArc} fills arc 
regions. \



\bold{Usage.}  This method is used to fill in pie chart regions. \




}\paragraph{Filling rounded rectangles} \indexi{Graphic++Fill rounded 
rectangle}

\indexi{ \italic{graphic::FillRRect}}

\example{void graphic::FillRRect(grphc,OuterBox,InnerBox,Tile) struct 
graphic *grphc;  \


struct rectangle *OuterBox;  \


struct rectangle *InnerBox;  \


struct graphic *Tile;} \



\leftindent{\bold{Method description.}   \italic{graphic::FillRRect} fills 
rectangles regions created by \italic{DrawRRect}. }\


\begindata{bp,538055336}
Version 2
n 0
\enddata{bp,538055336}
\view{bpv,538055336,12,0,0}
\subsection{Bit block transfers}


\paragraph{Doing a block transfer of bits} \indexi{Graphic++Bit block 
transfer}

\indexi{ \italic{graphic::BitBlt}}

\example{void graphic::BitBlt(grphc, SrcRect, DstPixMap, DstOrigin, 
ClipRect) \


struct graphic *grphc;  \


struct rectangle *SrcRect;  \


struct graphic *DstPixMap;  \


struct point *DstOrigin;  \


struct rectangle *ClipRect; \


}
\leftindent{\bold{Method description.  }\italic{graphic::BitBlt} performs 
the transfer of bits from a source pixel map to a destination pixel map. 
 The source pixel map is formed from \italic{grphc}'s \italic{SrcRect}. 
 The destination pixel map is specified by \italic{DstPixMap} and the 
destination rectangle has origin \italic{DstOrigin} and is the same size as 
the \italic{SrcRect}.  The dimensions of the source rectangle and 
destination rectangles must be the same.  The Clipping rectangle, 
\italic{ClipRect}, limits the region of the destination that can be 
affected by the block transfer; if any parts of the destination fall 
outside the bounds specified by the clipping rectangle, they will be 
clipped.  (Clip Rect not yet implemented.) \



}
\paragraph{Setting the location of a bit} \indexi{Graphic++Set bit location}

\indexi{ \italic{graphic::SetBitAtBitLoc}}

\example{void graphic::SetBitAtLoc(grphc,XPos,YPos, Value) \


struct graphic *grphc;  \


long YPos;  \


long XPos;  \


boolean Value;} \



\leftindent{\bold{Method description.}   \italic{graphic::SetBitAtLoc }sets 
the bit at \italic{grphc}'s (\italic{Xpos, Ypos}) coordinate to the value 
\italic{Value}.  Value should be 1 (black) or 0 (white). \


}
\begindata{bp,538059320}
Version 2
n 0
\enddata{bp,538059320}
\view{bpv,538059320,13,0,0}
\subsection{The logical rectangle}


\paragraph{Getting the logical bounds} \indexi{Graphic++Get logical bounds}

\indexi{ \italic{graphic::GetLogicalBounds}}

\example{void graphic::GetLogicalBounds(grphc,rect) \


struct graphic *grphc;  \


struct rectangle *rect; }\



\leftindent{\bold{Method description.  }\italic{graphic::GetLogicalBounds 
}sets the rectangle \italic{rect}'s left, top, width and height state 
variables to the values of \italic{grphc}'s logical rectangle. \



\bold{Example.} \



\example{struct rectangle *rect;  \


struct graphic *go; \



go = graphic::New(); \



graphic::GetLogicalBounds (go, &rect);} \



sets \italic{rect'}s state variables to \italic{go}'s logical rectangle. \


}


\paragraph{Getting the logical right} \indexi{Graphic++Get logical right}

\indexi{ \italic{graphic::GetLogicalRight}}

\example{long graphic::GetLogicalRight(grphc) \


struct graphic *grphc; }\



\leftindent{\bold{Method description.}   \italic{graphic::GetLogicalRight} 
returns the \italic{x} coordinate for the right side of the 
\italic{grphc}'s logical rectangle. \



}
\paragraph{Getting the logical bottom} \indexi{Graphic++Get logical bottom}

\indexi{ \italic{graphic::GetLogicalBottom}}

\example{long graphic::GetLogicalBottom(grphc) \


struct graphic *grphc;} \



\leftindent{\bold{Method description.}   \italic{graphic::GetLogicalBottom 
}returns the \italic{y} coordinate for the bottom side of the 
\italic{grphc}'s logical rectangle.} \



\begindata{bp,538064456}
Version 2
n 0
\enddata{bp,538064456}
\view{bpv,538064456,14,0,0}
\paragraph{Getting the enclosed bounds} \indexi{Graphic++Get enclosed bounds

}\indexi{ \italic{graphic::GetEnclosedBounds}}

\example{void graphic::GetEnclosedBounds(grphc,rect) \


struct graphic *grphc;  \


struct rectangle *rect;} \



\leftindent{\bold{Method description.}   \italic{graphic::GetEnclosedBounds} 
sets the rectangle \italic{rect}'s left, top, width and height state 
variables to the values of \italic{grphc}'s enclosed rectangle. \




}\paragraph{Getting the enclosed right} \indexi{Graphic++Get enclosed right}

\indexi{ \italic{graphic::GetEnclosedRight}}

\example{long graphic::GetEnclosedRight(grphc) \


struct graphic *grphc; }\



\leftindent{\bold{Method description.}   \italic{graphic::GetEnclosedRight} 
returns the \italic{grphc}'s \italic{x} coordinate for the right side of 
the \italic{grphc}'s enclosed rectangle. \


}


\paragraph{Getting the enclosed bottom} \indexi{Graphic++Get enclosed bottom

}\indexi{ \italic{graphic::GetEnclosedBottom}}

\example{long graphic::GetEnclosedBottom(grphc) \


struct graphic *grphc;} \



\leftindent{\bold{Method description.}   \italic{graphic::GetEnclosedBottom} 
returns the \italic{grphc}'s \italic{y} coordinate for the right side of 
the \italic{grphc}'s enclosed rectangle.} \



\subsection{The visual rectangle} \paragraph{Getting the visual rectangle 
bounds} \indexi{Graphic++Get visual bounds}

\indexi{ \italic{graphic::GetVisualBounds}}

\example{void graphic::GetVisualBounds(grphc,rect) s

truct graphic *grphc;  \


struct rectangle *rect;} \



\leftindent{\bold{Method description.}   \italic{graphic::GetVisualBounds} 
gets the boundaries of the visual rectangle. \


}



\paragraph{Getting the visual right}

 \indexi{Graphic++Get visual right}\indexi{ \italic{graphic::GetVisualRight}}

\example{long graphic::GetVisualRight(grphc)

struct graphic *grphc;} \



\leftindent{\bold{Method description.}   \italic{graphic::GetVisualRight} 
gets the right of the visual rectangle.} \



\paragraph{Getting the visual bottom} \indexi{Graphic++Get visual bottom}

\indexi{ \italic{graphic::GetVisualBottom}}


\example{long graphic::GetVisualBottom(grphc) \


struct graphic *grphc;} \



\leftindent{\bold{Method description.}   \italic{graphic::GetVisualBottom} 
gets the bottom of the visual rectangle.} \





\begindata{bp,538072760}
Version 2
n 0
\enddata{bp,538072760}
\view{bpv,538072760,15,0,0}
\subsection{The clipping rectangle} \paragraph{Setting the clipping 
rectangle} \indexi{Graphic++Set clipping rectangle}

\indexi{ \italic{graphic::SetClippingRect}}

\example{void graphic::SetClippingRect(grphc, rect) \


struct graphic *grphc;  \


struct rectangle *rect;} \



\leftindent{\bold{Method description.}   \italic{graphic::SetClippingRect} 
sets \italic{grphc}'s clipping rectangle to \italic{rect}.} \



\paragraph{Clearing a clipping rectangle} \indexi{Graphic++Clear clipping 
rectangle}

\indexi{ \italic{graphic::ClearClippingRect}}

\example{void graphic::ClearClippingRect(grphc) \


struct graphic *grphc;} \



\leftindent{\bold{Method description.}   \italic{graphic::ClearClippingRect} 
clears \italic{grphc}'s clipping rectangle. \




}\paragraph{Getting the current clipping rectangle} \indexi{Graphic++Get 
clipping rectangle}

\indexi{ \italic{graphic::GetClippingRect}}

\example{void graphic::GetClippingRect(grphc,rect) \


struct graphic *grphc;  \


struct rectangle *rect;} \



\leftindent{\bold{Method description.}   \italic{graphic::GetClippingRect} 
sets \italic{rect} to \italic{grphc}'s clipping rectangle.  If 
\italic{grphc} has not set a clipping rectangle, \italic{rect} is set to 
\italic{grphc}'s visual rectangle.} \




\begindata{bp,538077608}
Version 2
n 0
\enddata{bp,538077608}
\view{bpv,538077608,16,0,0}
\subsection{The transfer mode}


\paragraph{Setting the transfer mode} \indexi{Graphic++Set transfer mode}

\indexi{Graphic++Drawing}

\indexi{ \italic{graphic::SetTransferMode}}

\example{void graphic::SetTransferMode(grphc,NewTransferMode) struct graphic 
*grphc;  \


short NewTransferMode;} \



\leftindent{\bold{Method description.  }\italic{graphic::SetTransferMode} 
sets the transfer mode for drawing.  The default is 
\italic{graphic::}\smaller{COPY}.  There is rarely any need to use any other 
transfer mode except \italic{graphic::}\smaller{INVERT} and 
\italic{graphic}_\smaller{XOR}.  The transfer mode specifies how each 
source element S and each destination element D should combine to produce 
the result.  The source and destination each have four elements, so there 
are sixteen possible ways to combine them. \



It is useful to think of the source and destination as forming a table of 
bits: \




\typewriter{graphic::SOURCE       --  1  --  1  --  0  --  0

graphic::DESTINATION  --  1  --  0  --  1  --  0

__________________________________________________________

Transfer mode result --  ?  --  ?  --  ?  --  ?

}

The transfer mode specifies the Result when S and D are both 1, when S is 1 
and D is 0, when S is 0 and D is 1 and when both S and D are 0.  When a bit 
is 1, it is interpreted as black; when 0, as white.  For example, if you 
want the result to be 1 (that is black) only when both the source and 
destination are 1 (black), you would AND together the source and 
destination (\italic{graphic::}\smaller{SOURCE} & 
\italic{graphic::}\smaller{\smaller{DEST}}) to form the transfer mode.  If 
you want the source to be copied directly without regard to the current 
value of the destination, you would use \italic{graphic::}\smaller{SOURCE} 
alone to form the transfer mode. \



You can construct the transfer mode by forming boolean combinations from 
the graphic constants graphic::SOURCE and graphic::DESTINATION directly.  For 
convenience, the following common combinations have been defined as well: \



\description{
\italic{graphic::}\smaller{COPY}  --  the bit values are from the source


\italic{graphic::}\smaller{OR}  --  the bit values result from 
\smaller{OR}-ing the source and the destination


\italic{graphic::}\smaller{XOR}  --  the bit values result from an exclusive 
or of the source and the destination


\italic{graphic::}\smaller{AND}  --  the bit values result from an 
\smaller{AND}-ing the source and destination


\italic{graphic::}\smaller{WHITE}  --  the bit values are white (background)


\italic{graphic::}\smaller{BLACK}  --  the bit values are black (foreground)


\italic{graphic::}\smaller{INVERT}  --  the bit values are the opposite of 
the destination (if foreground, background; if background, foreground)

}
}
\begindata{bp,538083704}
Version 2
n 0
\enddata{bp,538083704}
\view{bpv,538083704,17,0,0}
\paragraph{Getting the transfer mode} \indexi{Graphic++Get transfer mode}

\indexi{ \italic{graphic::GetTransferMode}}

\example{short graphic::GetTransferMode(grphc) \


struct graphic *grphc;} \



\leftindent{\bold{Method description.}   \italic{graphic::GetTransferMode} 
gets the transfer mode. \


}

\subsection{Buffered output} \paragraph{Flushing graphic output} 
 \indexi{Graphic++Flushing}

\indexi{ \italic{graphic::FlushGraphics}}

\example{void graphic::FlushGraphics(grphc) \


struct graphic *grphc;} \



\leftindent{\bold{Method description.}   \italic{graphic::FlushGraphics} 
ensures that drawing commands are actually done (not buffered). \


}

\subsection{Patterns} \paragraph{Making white patterns} 
\indexi{Graphic++White patterns}

\indexi{ \italic{graphic::WhitePattern}}

\example{struct graphic *graphic::WhitePattern(grphc) \


struct graphic *grphc;} \



\leftindent{\bold{Method description.}   \italic{graphic::WhitePattern 
}returns a graphic that can be used to supply a white pixmap for fill 
operations. }\




\paragraph{Making black patterns} \indexi{Graphic++Black patterns}

\indexi{ \italic{graphic::BlackPattern}}

\example{struct graphic *graphic::BlackPattern(grphc) \


struct graphic *grphc;} \



\leftindent{\bold{Method description.}   \italic{graphic::BlackPattern} 
returns a graphic that can be used to supply a black pixmap for fill 
operations.


}
\paragraph{Making gray patterns} \indexi{Graphic++Gray patterns}

\indexi{ \italic{graphic::GrayPattern}}

\example{struct graphic *graphic::GrayPattern(grphc,IntensityNum, 
IntensityDenom) \


struct graphic *grphc;  \


long IntensityNum, IntensityDenom;} \



\leftindent{\bold{Method description.}   \italic{graphic::GrayPattern} 
returns a graphic that can be used to supply a grey pixmap for fill 
operations.} \


\begindata{bp,538089896}
Version 2
n 0
\enddata{bp,538089896}
\view{bpv,538089896,18,0,0}

\bold{\bigger{Color}}


Under X11, the foreground and background colors can be set to achieve color 
output. Colors can be specified either by an ASCII string name, to be 
looked up in the X11 color database, or by specifying RGB values. These RGB 
values can be expressed as integers between 0 and 65535, where 0 is off and 
65535 is full intensity, or as real numbers between 0.0 and 1.0, where 0.0 
is off and 1.0 is full intensity. Integers and reals can be used 
interchangably to set and get the foreground and background colors.


On monochrome displays, attempts to use color will set an approximation 
stipple tile that will be used on fills when the Tile argument to the 
graphic fill methods is NULL (if it is not NULL, the Tile argument 
overrides this approximation tile). If they choose to, programmers can use 
the \typewriter{DisplayClass} method to determine the nature of the 
display, and can special case monochrome and color as they see fit, 
effectively bypassing the built-in approximation on monochrome.


\bold{Determining the display class

}
\example{long graphic::DisplayClass( graphic );

struct graphic *graphic}


\indent{\bold{Method description}. \italic{graphic::DisplayClass} returns a 
bit mask long integer that describes the display of the server that the 
application is using. The return value consists of the appropriate 
symbolics bitwise-or'ed together. The set of possible values includes 
symbolics for the six display classes defined by X11, plus additional 
symbolics defined by the graphic class:


\typewriter{graphic::Monochrome

graphic::Color

graphic::PseudoColor

graphic::GrayScale

graphic::DirectColor

graphic::TrueColor

graphic::StaticColor

graphic::StaticGray}


All color displays will have \typewriter{graphic::Color}  or'ed in with the 
appropriate display class symbolic. StaticGray displays with a colormap of 
size 2 will have \typewriter{graphic::Monochrome} or'ed in.


\bold{Example}

}
\example{if ( graphic::DisplayClass( graphic ) & graphic::Color )

    ...color handling code...

else if ( graphic::DisplayClass( graphic ) & graphic::Monochrome )

    ... monochrome handling code}


\bold{Setting the foreground color

}
\example{void graphic\bold{_}SetForegroundColor (graphic, colorName, red, 
 green,  blue); \


}\example{struct graphic *graphic;

char *colorName;

long red;

long green;

long blue;}


\indent{\bold{Method description}. \italic{graphic::SetForegroundColor} 
optionally takes a colorName argument or RGB values (expressed as integers 
between 0 and 65535) to set the foregound color. If the colorName argument 
is supplied, it is used to look up RGB values and set the foreground color 
accordingly. If colorName is NULL, the red, green, and blue values are used.

}
\example{void graphic::SetFGColor(graphic, red,  green, blue );

struct graphic *graphic;

double red;

double green;

double blue;}


\indent{\bold{Method description}.\italic{\italic{ graphic::SetFGColo}r} 
accepts red, green, and blue real number values between 0.0 and 1.0 to 
specify the foreground color. }\



\bold{G}\bold{etting the foreground color

}
\example{void graphic\bold{_}GetForegroundColor (graphic, colorName, red, 
 green,  blue); \


}\example{struct graphic *graphic;

char **colorName;

long *red;

long *green;

long *blue;

}
\indent{\bold{Method description}. \italic{graphic::GetForegroundColor} 
returns the currently set foreground color. If a colorName was originally 
used to specify the color, both it and the resultant RGB values are 
returned. Otherwise only the RGB values are returned.}


\example{void graphic::GetFGColor(graphic, red,  green, blue );

struct graphic *graphic;

double *red;

double *green;

double *blue;}


\indent{\bold{Method description}.\italic{\italic{ graphic::GetFGColo}r} 
returns the red, green, and blue real number values between 0.0 and 1.0 
that describe the currently set foreground color. \



}\bold{Setting the background color

}
\example{void graphic\bold{_}SetBackgroundColor (graphic, colorName, red, 
 green,  blue); \


}\example{struct graphic *graphic;

char *colorName;

long red;

long green;

long blue;}


\indent{\bold{Method description}. \italic{graphic::SetBackgroundColor} 
optionally takes a colorName argument or RGB values (expressed as integers 
between 0 and 65535) to set the backgound color. If the colorName argument 
is supplied, it is used to look up RGB values and set the background color 
accordingly. If colorName is NULL, the red, green, and blue values are used.

}
\example{void graphic::SetFGColor(graphic, red,  green, blue );

struct graphic *graphic;

double red;

double green;

double blue;}


\indent{\bold{Method description}.\italic{\italic{ graphic::SetFGColo}r} 
accepts red, green, and blue real number values between 0.0 and 1.0 to 
specify the background color. }\



\bold{G}\bold{etting the background color

}
\example{void graphic\bold{_}GetBackgroundColor (graphic, colorName, red, 
 green,  blue); \


}\example{struct graphic *graphic;

char **colorName;

long *red;

long *green;

long *blue;

}
\indent{\bold{Method description}. \italic{graphic::GetBackgroundColor} 
returns the currently set background color. If a colorName was originally 
used to specify the color, both it and the resultant RGB values are 
returned. Otherwise only the RGB values are returned.}


\example{void graphic::GetBGColor(graphic, red,  green, blue );

struct graphic *graphic;

double *red;

double *green;

double *blue;}


\indent{\bold{Method description}.\italic{\italic{ graphic::GetBGColo}r} 
returns the red, green, and blue real number values between 0.0 and 1.0 
that describe the currently set background color. \


}
\begindata{bp,538098728}
Version 2
n 0
\enddata{bp,538098728}
\view{bpv,538098728,19,0,0}
\subsection{Redirecting graphic output} \paragraph{Redirecting a graphic} 
\indexi{Graphic++Redirect}

\indexi{ \italic{graphic::RedirectGraphic}}

\example{void graphic::RedirectGraphic(grphc,SecondaryGraphic) struct 
graphic *grphc;  \


struct graphic *SecondaryGraphic;} \



\leftindent{\bold{Method description.  }\italic{graphic::RedirectGraphic} is 
a private method intended for future expansion.   The intention is to 
provide a way to switch between graphics systems on the fly, such as 
generating PostScript by capturing graphics calls rather than via a print 
command. This method would redirect a graphic so that it went to a PS 
version instead. \



\bold{Usage.}  Should not be used by application programmers at this time. \


}


\begindata{bp,538100456}
Version 2
n 0
\enddata{bp,538100456}
\view{bpv,538100456,20,0,0}
Copyright 1992 Carnegie Mellon University and IBM.  All rights reserved.
\enddata{text,537795720}
