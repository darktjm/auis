\begindata{text,17171476}
\textdsversion{12}
\template{help}
\define{keyword
}
\chapter{C++Conv: Convert Class C files to C++

}
\section{What C++Conv is

}\leftindent{
\italic{C++Conv} takes a list of Class C files (.c files) and attempts to 
convert them to C++. It also automatically converts the associated class 
headers (.ch files) into C++ header files (.H files). 


The resulting files can then be compiled in the C++ ATK environment. (Some 
hand-tuning will probably be necessary for each file. See the sections 
"Hand-Tuning" and "Conversion Trouble Spots".)

}
\section{Starting C++Conv

}\leftindent{
\typewriter{C++Conv \italic{cfiles...} --- \italic{classindexes...} 
}}\typewriter{\italic{


}}
\leftindent{\italic{cfiles...} should be a list of all the .c defining one or 
more ATK classes.

\italic{classindexes...} is a list of class index files (generated by 
\italic{C++Index}). 


The class index files must include information on every class used by any of 
the .c files being converted (including their own classes.) There is a 
standard class index file which contains all the classes in the standard ATK 
distribution; this file is automatically included, and need not be listed in 
\italic{classindexes...} You need only create and list class index files for 
classes that you wrote. See the help file on \italic{C++Index}.


\italic{C++Conv} will convert each .c file to a .C file containing C++ source 
code for that class. \italic{C++Conv} will also automatically read the .ch 
(class header) files associated with the .c files, and convert them to .H 
files containing the definitions of the equivalent C++ classes. 


\italic{C++Conv} can understand ATK classes that are implemented in several .c 
files, as long as they use the standard #define AUXMODULE convention.


If your class uses .h files, do not include them in the list of files. The 
script \italic{C++Proto} can be used to add C++ prototypes to function 
declarations in .h files. See the help file on \italic{C++Proto}.

}
\section{Warnings

}\leftindent{
\italic{C++Conv} is a shell script that calls a Ness script. You must be able 
to run the ATK application \italic{nessrun} in order to use it.


Be sure that when you convert a class, you include all the .c files for that 
class in a single call to \italic{C++Conv}.


Before you run \italic{C++Conv}, you must run \italic{C++Index} on every 
directory that contains classes that your .c files refer to (including their 
own classes.) \italic{C++Index} reads the .ch files and creates a class index 
file; you must save the class index file and use it as an argument to 
\italic{C++Conv}, in the \italic{classindexes... }list.


If you want to use \italic{C++Proto} to prototype .h files for your class, you 
will need to have access to the original (unconverted) .c files. If you run 
\italic{C++Proto} after \italic{C++Conv}, you must be sure to run it before 
you delete the .c files that you have converted. 

}
\section{Effects of Conversion}


\leftindent{\subsection{All files:

}
Identifiers that conflict with C++ reserved words are changed; "_c" is added 
to the end. For example, a variable called "virtual" would be renamed 
"virtual_c" everywhere it occurred.

This is the list of C++ reserved words that are checked for:

\leftindent{asm, catch, class, const, delete, friend, inline, new, operator, 
private, protected, public, template, this, throw, try, virtual

}
References to "struct classinfo" are changed to "\keyword{struct} 
ATKregistryEntry"; "struct basicobject" are changed to "class ATK"; "struct 
\italic{classname}" (where classname is an ATK class) are changed to "class 
\italic{classname}".


Calls to classprocedures and methods are updated to the C++ syntax.


References to data members of parent classes are changed to the simpler C++ 
syntax. (For example, "aclass->header.classname.somedata" would be changed to 
read "aclass->somedata".)


\subsection{.c files:

}
Method and classprocedure definitions are updated for the C++ syntax. (For 
example, "aclass__somemethod" is changed to "aclass::somemethod")


Functions are prototyped. The "classheader" argument (in classprocedures) and 
the "self" argument (in methods) are removed. The function bodies of methods 
are corrected to use "this". 


References to global variables are changed to "::varname", wherever it is 
necessary to prevent them from being shadowed by a class or instance variable. 
(Warning: if your class has multiple .c files, this is only done in the file 
that does not contain AUXMODULE. In the AUXMODULE files, you may have to do 
this by hand.)


The name "InitializeObject" is replaced with the class name, to make a proper 
C++ initializer function. The return type is removed, and any return 
statements are replaced with the macro "THROWONFAILURE(\italic{returnvalue})".


The name "FinalizeObject" is replaced with "~" followed by the class name. The 
return type is removed.


The macro "ATKdefineRegistry(\italic{classname}, \italic{parentclassname})" is 
inserted before the first function definition. If the class has multiple .c 
files, this is only done in the file that does not contain AUXMODULE. 


Prototypes for all non-classprocedure and non-method functions are inserted 
just before the first function definition. (Warning: if the first function is 
defined inside an #if / #endif directive block, the prototypes will 
erroneously be inserted inside the block also.)


\subsection{.ch files:

}
The class header is converted to a C++ class definition. (Both "package" and 
"class" .ch files become C++ classes.) If there is no superclass, the 
superclass ATK is substituted.

\leftindent{The declarations of InitializeObject and FinalizeObject are 
changed to "\italic{classname}" and "~\italic{classname}".

Other classprocedures become public static member functions.

Methods become public virtual member functions.

Macromethods become public inline member functions. 

Macros become public static inline member functions. 

Data become public data members.

}
Name keys (the shortened class names in square brackets) are eliminated.


The virtual function declaration "ATKregistryEntry *ATKregistry()" is inserted 
as the first declaration in the class.


A check for duplication is made, and a warning reported if two members of the 
class have the same name. (This should only happen if a macro, method, or 
classprocedures winds up with the same name as a data member.)


}\section{Hand-Tuning

}
\leftindent{\italic{C++Conv} does the best it can to create working C++ code. 
Life being what it is, however, it does not always succeed. (Guessing the 
return type of macromethods is particularly difficult.) The .C and .H files 
that are generated may contain the following strings, which you must find and 
replace with correct information.


MISSING_DEFINITION: No definition could be found for the next function 
declaration.  

MISSING_ARGUMENT_TYPE: No type could be found for the following function 
argument.

MISSING_RETURN_TYPE: No type could be found for the return value of the 
following function.

MISSING_RETURN_TYPE_SELF_\italic{member}: The following function seems to be 
returning the data member \italic{member}, but that member could not be found.


}\section{Limitations

}
\leftindent{#if directives may confuse the parser, though in most cases it can 
cope.  One case where it cannot cope is when the first function definition in 
a file is under a #if; in this case it will add the forward declaration 
prototypes within the #if, just before the function.


Macros used in the construction of function definitions may confuse the 
converter.  Unfortunately, this includes macros designed to allow code to 
compile both with and without prototypes (ie, macros designed to make code 
acceptable to both ANSI and non-ANSI C compilers.)


A number of special names are recognized as synonyms for storage classes. 
 (CONST, STATIC, GLOBAL, GVAR, GLOCAL, METHODDEF, etc...)


If a method has a local variable "\italic{varname}" with the same name as a 
member of the class, any references to "\italic{varname}" will be replaced 
with "::\italic{varname}". This will produce a compile-time error.

}
\section{Diagnostics 

}
\leftindent{\italic{write failed!

}The output file couldn't be written.


\italic{Unknown class: <classname>

This class cannot be properly converted!

}A reference to an unknown class was included. Method definitions and calls 
for the unknown classes will not be converted (they will remain in Class C 
syntax: classname_methodname(obj) instead of obj->methodname().) You should 
run \italic{C++Index} on the .ch files for the unknown classes, and then try 
\italic{C++Conv} again, including the new class index file on the command 
line.


\italic{Type index information does not match in class <classname>

}The information present in the predefined class index doesn't match the 
current definition of the class.


\italic{Couldn't find end of class name key

}A syntax error in a .ch file: the name key wasn't terminated with a ']'.


\italic{Class header malformed.

}A syntax error in a .ch file: the first non-whitespace character after the 
class header was not a '\{'.


\italic{Unrecognized section <text>

}A syntax error in a .ch file: a section other than classprocedures, 
overrides, data, macromethods, macros was encountered.


\italic{Too many ')'s at line N.  } 

\italic{Not enough ')'s last known good position: N.}

(or similar errors about '\}'s or ']'s.)

A syntax error in a .c file: the parentheses, braces, or brackets seem to be 
unbalanced.


\italic{expected ']' after array size specification.

couldn't parse start decl from: <text>

bad decl end... restarting at next semicolon (or function body) after: <text>

expected close paren after <function>

expected paren after <function>

}These are low-level errors, indicating either a C syntax error or a bug in 
the converter. The resulting files may be syntactically incorrect, or 
otherwise corrupted.


}\enddata{text,17171476}
